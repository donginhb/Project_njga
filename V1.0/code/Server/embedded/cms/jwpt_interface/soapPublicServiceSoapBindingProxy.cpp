/* soapPublicServiceSoapBindingProxy.cpp
   Generated by gSOAP 2.8.45 for PublicService.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include "soapPublicServiceSoapBindingProxy.h"

PublicServiceSoapBindingProxy::PublicServiceSoapBindingProxy() : soap(SOAP_IO_DEFAULT)
{	PublicServiceSoapBindingProxy_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
}

PublicServiceSoapBindingProxy::PublicServiceSoapBindingProxy(const PublicServiceSoapBindingProxy& rhs)
{	soap_copy_context(this, &rhs);
	this->soap_endpoint = rhs.soap_endpoint;
}

PublicServiceSoapBindingProxy::PublicServiceSoapBindingProxy(const struct soap &_soap) : soap(_soap)
{ }

PublicServiceSoapBindingProxy::PublicServiceSoapBindingProxy(const char *endpoint) : soap(SOAP_IO_DEFAULT)
{	PublicServiceSoapBindingProxy_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
	soap_endpoint = endpoint;
}

PublicServiceSoapBindingProxy::PublicServiceSoapBindingProxy(soap_mode iomode) : soap(iomode)
{	PublicServiceSoapBindingProxy_init(iomode, iomode);
}

PublicServiceSoapBindingProxy::PublicServiceSoapBindingProxy(const char *endpoint, soap_mode iomode) : soap(iomode)
{	PublicServiceSoapBindingProxy_init(iomode, iomode);
	soap_endpoint = endpoint;
}

PublicServiceSoapBindingProxy::PublicServiceSoapBindingProxy(soap_mode imode, soap_mode omode) : soap(imode, omode)
{	PublicServiceSoapBindingProxy_init(imode, omode);
}

PublicServiceSoapBindingProxy::~PublicServiceSoapBindingProxy()
{
	this->destroy();
	}

void PublicServiceSoapBindingProxy::PublicServiceSoapBindingProxy_init(soap_mode imode, soap_mode omode)
{	soap_imode(this, imode);
	soap_omode(this, omode);
	soap_endpoint = NULL;
	static const struct Namespace namespaces[] = {
        {"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/", "http://www.w3.org/*/soap-envelope", NULL},
        {"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/", "http://www.w3.org/*/soap-encoding", NULL},
        {"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL},
        {"xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL},
        {"ns1", "http://webservice.qqfw.btdx.com", NULL, NULL},
        {NULL, NULL, NULL, NULL}
    };
	soap_set_namespaces(this, namespaces);
}

#ifndef WITH_PURE_VIRTUAL
PublicServiceSoapBindingProxy *PublicServiceSoapBindingProxy::copy()
{	PublicServiceSoapBindingProxy *dup = SOAP_NEW_COPY(PublicServiceSoapBindingProxy(*(struct soap*)this));
	return dup;
}
#endif

PublicServiceSoapBindingProxy& PublicServiceSoapBindingProxy::operator=(const PublicServiceSoapBindingProxy& rhs)
{	soap_copy_context(this, &rhs);
	this->soap_endpoint = rhs.soap_endpoint;
	return *this;
}

void PublicServiceSoapBindingProxy::destroy()
{	soap_destroy(this);
	soap_end(this);
}

void PublicServiceSoapBindingProxy::reset()
{	this->destroy();
	soap_done(this);
	soap_initialize(this);
	PublicServiceSoapBindingProxy_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
}

void PublicServiceSoapBindingProxy::soap_noheader()
{	this->header = NULL;
}

::SOAP_ENV__Header *PublicServiceSoapBindingProxy::soap_header()
{	return this->header;
}

::SOAP_ENV__Fault *PublicServiceSoapBindingProxy::soap_fault()
{	return this->fault;
}

const char *PublicServiceSoapBindingProxy::soap_fault_string()
{	return *soap_faultstring(this);
}

const char *PublicServiceSoapBindingProxy::soap_fault_detail()
{	return *soap_faultdetail(this);
}

int PublicServiceSoapBindingProxy::soap_close_socket()
{	return soap_closesock(this);
}

int PublicServiceSoapBindingProxy::soap_force_close_socket()
{	return soap_force_closesock(this);
}

void PublicServiceSoapBindingProxy::soap_print_fault(FILE *fd)
{	::soap_print_fault(this, fd);
}

#ifndef WITH_LEAN
#ifndef WITH_COMPAT
void PublicServiceSoapBindingProxy::soap_stream_fault(std::ostream& os)
{	::soap_stream_fault(this, os);
}
#endif

char *PublicServiceSoapBindingProxy::soap_sprint_fault(char *buf, size_t len)
{	return ::soap_sprint_fault(this, buf, len);
}
#endif

int PublicServiceSoapBindingProxy::queryObjectInfo(const char *endpoint, const char *soap_action, char *_senderID, char *_serviceID, char *_xmlSet, char *&_queryObjectInfoReturn)
{	struct soap *soap = this;
	struct ns1__queryObjectInfo soap_tmp_ns1__queryObjectInfo;
	struct ns1__queryObjectInfoResponse *soap_tmp_ns1__queryObjectInfoResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://10.33.250.125:9080/QQFWPT/services/PublicService";
	if (soap_action == NULL)
		soap_action = "";
	soap_tmp_ns1__queryObjectInfo._senderID = _senderID;
	soap_tmp_ns1__queryObjectInfo._serviceID = _serviceID;
	soap_tmp_ns1__queryObjectInfo._xmlSet = _xmlSet;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_ns1__queryObjectInfo(soap, &soap_tmp_ns1__queryObjectInfo);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__queryObjectInfo(soap, &soap_tmp_ns1__queryObjectInfo, "ns1:queryObjectInfo", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__queryObjectInfo(soap, &soap_tmp_ns1__queryObjectInfo, "ns1:queryObjectInfo", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	_queryObjectInfoReturn = NULL;
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__queryObjectInfoResponse = soap_get_ns1__queryObjectInfoResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__queryObjectInfoResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	_queryObjectInfoReturn = soap_tmp_ns1__queryObjectInfoResponse->_queryObjectInfoReturn;
	return soap_closesock(soap);
}

int PublicServiceSoapBindingProxy::insertObjectInfo(const char *endpoint, const char *soap_action, char *_senderID, char *_serviceID, char *_xmlSet, char *&_insertObjectInfoReturn)
{	struct soap *soap = this;
	struct ns1__insertObjectInfo soap_tmp_ns1__insertObjectInfo;
	struct ns1__insertObjectInfoResponse *soap_tmp_ns1__insertObjectInfoResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://10.33.250.125:9080/QQFWPT/services/PublicService";
	if (soap_action == NULL)
		soap_action = "";
	soap_tmp_ns1__insertObjectInfo._senderID = _senderID;
	soap_tmp_ns1__insertObjectInfo._serviceID = _serviceID;
	soap_tmp_ns1__insertObjectInfo._xmlSet = _xmlSet;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_ns1__insertObjectInfo(soap, &soap_tmp_ns1__insertObjectInfo);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__insertObjectInfo(soap, &soap_tmp_ns1__insertObjectInfo, "ns1:insertObjectInfo", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__insertObjectInfo(soap, &soap_tmp_ns1__insertObjectInfo, "ns1:insertObjectInfo", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	_insertObjectInfoReturn = NULL;
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__insertObjectInfoResponse = soap_get_ns1__insertObjectInfoResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__insertObjectInfoResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	_insertObjectInfoReturn = soap_tmp_ns1__insertObjectInfoResponse->_insertObjectInfoReturn;
	return soap_closesock(soap);
}

int PublicServiceSoapBindingProxy::updateObjectInfo(const char *endpoint, const char *soap_action, char *_senderID, char *_serviceID, char *_xmlSet, char *&_updateObjectInfoReturn)
{	struct soap *soap = this;
	struct ns1__updateObjectInfo soap_tmp_ns1__updateObjectInfo;
	struct ns1__updateObjectInfoResponse *soap_tmp_ns1__updateObjectInfoResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://10.33.250.125:9080/QQFWPT/services/PublicService";
	if (soap_action == NULL)
		soap_action = "";
	soap_tmp_ns1__updateObjectInfo._senderID = _senderID;
	soap_tmp_ns1__updateObjectInfo._serviceID = _serviceID;
	soap_tmp_ns1__updateObjectInfo._xmlSet = _xmlSet;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_ns1__updateObjectInfo(soap, &soap_tmp_ns1__updateObjectInfo);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__updateObjectInfo(soap, &soap_tmp_ns1__updateObjectInfo, "ns1:updateObjectInfo", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__updateObjectInfo(soap, &soap_tmp_ns1__updateObjectInfo, "ns1:updateObjectInfo", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	_updateObjectInfoReturn = NULL;
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__updateObjectInfoResponse = soap_get_ns1__updateObjectInfoResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__updateObjectInfoResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	_updateObjectInfoReturn = soap_tmp_ns1__updateObjectInfoResponse->_updateObjectInfoReturn;
	return soap_closesock(soap);
}

int PublicServiceSoapBindingProxy::deleteObjectInfo(const char *endpoint, const char *soap_action, char *_senderID, char *_serviceID, char *_xmlSet, char *&_deleteObjectInfoReturn)
{	struct soap *soap = this;
	struct ns1__deleteObjectInfo soap_tmp_ns1__deleteObjectInfo;
	struct ns1__deleteObjectInfoResponse *soap_tmp_ns1__deleteObjectInfoResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://10.33.250.125:9080/QQFWPT/services/PublicService";
	if (soap_action == NULL)
		soap_action = "";
	soap_tmp_ns1__deleteObjectInfo._senderID = _senderID;
	soap_tmp_ns1__deleteObjectInfo._serviceID = _serviceID;
	soap_tmp_ns1__deleteObjectInfo._xmlSet = _xmlSet;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_ns1__deleteObjectInfo(soap, &soap_tmp_ns1__deleteObjectInfo);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__deleteObjectInfo(soap, &soap_tmp_ns1__deleteObjectInfo, "ns1:deleteObjectInfo", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__deleteObjectInfo(soap, &soap_tmp_ns1__deleteObjectInfo, "ns1:deleteObjectInfo", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	_deleteObjectInfoReturn = NULL;
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__deleteObjectInfoResponse = soap_get_ns1__deleteObjectInfoResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__deleteObjectInfoResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	_deleteObjectInfoReturn = soap_tmp_ns1__deleteObjectInfoResponse->_deleteObjectInfoReturn;
	return soap_closesock(soap);
}

int PublicServiceSoapBindingProxy::callDataBaseProcess(const char *endpoint, const char *soap_action, char *_senderID, char *_serviceID, char *_xmlSet, char *&_callDataBaseProcessReturn)
{	struct soap *soap = this;
	struct ns1__callDataBaseProcess soap_tmp_ns1__callDataBaseProcess;
	struct ns1__callDataBaseProcessResponse *soap_tmp_ns1__callDataBaseProcessResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://10.33.250.125:9080/QQFWPT/services/PublicService";
	if (soap_action == NULL)
		soap_action = "";
	soap_tmp_ns1__callDataBaseProcess._senderID = _senderID;
	soap_tmp_ns1__callDataBaseProcess._serviceID = _serviceID;
	soap_tmp_ns1__callDataBaseProcess._xmlSet = _xmlSet;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_ns1__callDataBaseProcess(soap, &soap_tmp_ns1__callDataBaseProcess);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__callDataBaseProcess(soap, &soap_tmp_ns1__callDataBaseProcess, "ns1:callDataBaseProcess", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__callDataBaseProcess(soap, &soap_tmp_ns1__callDataBaseProcess, "ns1:callDataBaseProcess", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	_callDataBaseProcessReturn = NULL;
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__callDataBaseProcessResponse = soap_get_ns1__callDataBaseProcessResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__callDataBaseProcessResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	_callDataBaseProcessReturn = soap_tmp_ns1__callDataBaseProcessResponse->_callDataBaseProcessReturn;
	return soap_closesock(soap);
}

int PublicServiceSoapBindingProxy::batchObjectInfo(const char *endpoint, const char *soap_action, char *_senderID, char *_xmlSet, char *&_batchObjectInfoReturn)
{	struct soap *soap = this;
	struct ns1__batchObjectInfo soap_tmp_ns1__batchObjectInfo;
	struct ns1__batchObjectInfoResponse *soap_tmp_ns1__batchObjectInfoResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://10.33.250.125:9080/QQFWPT/services/PublicService";
	if (soap_action == NULL)
		soap_action = "";
	soap_tmp_ns1__batchObjectInfo._senderID = _senderID;
	soap_tmp_ns1__batchObjectInfo._xmlSet = _xmlSet;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_ns1__batchObjectInfo(soap, &soap_tmp_ns1__batchObjectInfo);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__batchObjectInfo(soap, &soap_tmp_ns1__batchObjectInfo, "ns1:batchObjectInfo", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__batchObjectInfo(soap, &soap_tmp_ns1__batchObjectInfo, "ns1:batchObjectInfo", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	_batchObjectInfoReturn = NULL;
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__batchObjectInfoResponse = soap_get_ns1__batchObjectInfoResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__batchObjectInfoResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	_batchObjectInfoReturn = soap_tmp_ns1__batchObjectInfoResponse->_batchObjectInfoReturn;
	return soap_closesock(soap);
}

int PublicServiceSoapBindingProxy::wsObjectInfo(const char *endpoint, const char *soap_action, char *_senderID, char *_serviceID, char *_xmlSet, char *&_wsObjectInfoReturn)
{	struct soap *soap = this;
	struct ns1__wsObjectInfo soap_tmp_ns1__wsObjectInfo;
	struct ns1__wsObjectInfoResponse *soap_tmp_ns1__wsObjectInfoResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://10.33.250.125:9080/QQFWPT/services/PublicService";
	if (soap_action == NULL)
		soap_action = "";
	soap_tmp_ns1__wsObjectInfo._senderID = _senderID;
	soap_tmp_ns1__wsObjectInfo._serviceID = _serviceID;
	soap_tmp_ns1__wsObjectInfo._xmlSet = _xmlSet;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_ns1__wsObjectInfo(soap, &soap_tmp_ns1__wsObjectInfo);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__wsObjectInfo(soap, &soap_tmp_ns1__wsObjectInfo, "ns1:wsObjectInfo", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__wsObjectInfo(soap, &soap_tmp_ns1__wsObjectInfo, "ns1:wsObjectInfo", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	_wsObjectInfoReturn = NULL;
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__wsObjectInfoResponse = soap_get_ns1__wsObjectInfoResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__wsObjectInfoResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	_wsObjectInfoReturn = soap_tmp_ns1__wsObjectInfoResponse->_wsObjectInfoReturn;
	return soap_closesock(soap);
}
/* End of client proxy code */
