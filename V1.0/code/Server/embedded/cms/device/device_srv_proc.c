
/*----------------------------------------------*
 * 包含头文件                                   *
 *----------------------------------------------*/
#include <stdio.h>
#ifdef WIN32
#include <winsock.h>
#include <sys/types.h>
#else
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <errno.h>
#endif

#include "common/gblfunc_proc.inc"
#include "common/gblconfig_proc.inc"
#include "common/log_proc.inc"

#include "device/device_srv_proc.inc"
#include "device/device_reg_proc.inc"
#include "device/device_thread_proc.inc"

#include "record/record_srv_proc.inc"

#include "user/user_srv_proc.inc"

#include "route/route_info_mgn.inc"
#include "route/route_srv_proc.inc"

#include "service/call_func_proc.inc"
#include "service/plan_srv_proc.inc"
#include "service/compress_task_proc.inc"

#include "service/alarm_proc.inc"

#include "resource/resource_info_mgn.inc"
#include "platformms/BoardInit.h"

/*----------------------------------------------*
 * 外部变量说明                                 *
 *----------------------------------------------*/
extern unsigned int g_transfer_xml_sn;    /* 全局的转发XML的SN */
extern int g_AlarmMsgSendToUserFlag;      /* 报警消息是否发送给用户,默认发送 */
extern int g_AlarmMsgSendToRouteFlag;     /* 报警消息是否发送给上级路由，默认不发送 */
extern int g_LocalMediaTransferFlag;      /* 下级媒体流是否经过本地TSU转发,默认转发 */
extern int g_DECMediaTransferFlag;        /* 下级媒体切电视墙是否经过本地TSU转发,默认转发 */
extern int g_AnalysisSubGroupFlag;        /* 是否解析下级分组，0:不解析；1:解析行政区域，2:解析分组，默认不解析 */

/*----------------------------------------------*
 * 外部函数原型说明                             *
 *----------------------------------------------*/

/*----------------------------------------------*
 * 内部函数原型说明                             *
 *----------------------------------------------*/

/*----------------------------------------------*
 * 全局变量                                     *
 *----------------------------------------------*/

/*----------------------------------------------*
 * 模块级变量                                   *
 *----------------------------------------------*/
device_srv_msg_queue g_DeviceSrvMsgQueue; /* 标准设备业务消息队列 */
#ifdef MULTI_THR
osip_mutex_t* g_DeviceSrvMsgQueueLock = NULL;
#endif

device_srv_msg_queue g_DeviceMessageSrvMsgQueue; /* 标准设备Message业务消息队列 */
#ifdef MULTI_THR
osip_mutex_t* g_DeviceMessageSrvMsgQueueLock = NULL;
#endif

diagnosis_msg_queue g_DiagnosisMsgQueue;                          /* 诊断消息队列 */
#ifdef MULTI_THR
osip_mutex_t* g_DiagnosisMsgQueueLock = NULL;
#endif

analysis_target_count_msg_queue g_AnalysisTargetCountMsgQueue;    /* 智能分析，目标计数消息队列 */
#ifdef MULTI_THR
osip_mutex_t* g_AnalysisTargetCountMsgQueueLock = NULL;
#endif

/*----------------------------------------------*
 * 常量定义                                     *
 *----------------------------------------------*/

/*----------------------------------------------*
 * 宏定义                                       *
 *----------------------------------------------*/

#if DECS("标准设备业务消息队列")
/*****************************************************************************
 函 数 名  : device_srv_msg_init
 功能描述  : 标准设备业务消息结构初始化
 输入参数  : device_srv_msg_t ** device_srv_msg
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月11日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_srv_msg_init(device_srv_msg_t** device_srv_msg)
{
    *device_srv_msg = (device_srv_msg_t*)osip_malloc(sizeof(device_srv_msg_t));

    if (*device_srv_msg == NULL)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG,  "device_srv_msg_init() exit---: *device_srv_msg Smalloc Error \r\n");
        return -1;
    }

    (*device_srv_msg)->msg_type = MSG_TYPE_NULL;
    (*device_srv_msg)->pGBDeviceInfo = NULL;
    (*device_srv_msg)->caller_id[0] = '\0';
    (*device_srv_msg)->callee_id[0] = '\0';
    (*device_srv_msg)->response_code = 0;
    (*device_srv_msg)->reasonphrase[0] = '\0';
    (*device_srv_msg)->ua_dialog_index = -1;
    (*device_srv_msg)->msg_body[0] = '\0';
    (*device_srv_msg)->msg_body_len = 0;
    (*device_srv_msg)->cr_pos = -1;

    return 0;
}

/*****************************************************************************
 函 数 名  : device_srv_msg_free
 功能描述  : 标准设备业务消息结构释放
 输入参数  : device_srv_msg_t * device_srv_msg
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月11日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
void device_srv_msg_free(device_srv_msg_t* device_srv_msg)
{
    if (device_srv_msg == NULL)
    {
        //DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG,  "device_srv_msg_free() exit---: Param Error \r\n");
        return;
    }

    device_srv_msg->msg_type = MSG_TYPE_NULL;
    device_srv_msg->pGBDeviceInfo = NULL;

    memset(device_srv_msg->caller_id, 0, MAX_ID_LEN + 4);
    memset(device_srv_msg->callee_id, 0, MAX_ID_LEN + 4);

    device_srv_msg->response_code = 0;

    memset(device_srv_msg->reasonphrase, 0, MAX_128CHAR_STRING_LEN + 4);

    device_srv_msg->ua_dialog_index = -1;

    memset(device_srv_msg->msg_body, 0, MAX_MSG_BODY_STRING_LEN + 4);

    device_srv_msg->msg_body_len = 0;
    device_srv_msg->cr_pos = -1;

    osip_free(device_srv_msg);
    device_srv_msg = NULL;

    return;
}

/*****************************************************************************
 函 数 名  : device_srv_msg_list_init
 功能描述  : 标准设备业务消息队列初始化
 输入参数  : 无
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月11日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_srv_msg_list_init()
{
    g_DeviceSrvMsgQueue.clear();

#ifdef MULTI_THR
    /* init smutex */
    g_DeviceSrvMsgQueueLock = (osip_mutex_t*)osip_mutex_init();

    if (NULL == g_DeviceSrvMsgQueueLock)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG,  "device_srv_msg_list_init() exit---: Device Service Message List Lock Init Error \r\n");
        return -1;
    }

#endif
    return 0;
}

/*****************************************************************************
 函 数 名  : device_srv_msg_list_free
 功能描述  : 标准设备业务消息队列释放
 输入参数  : 无
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月11日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
void device_srv_msg_list_free()
{
    device_srv_msg_t* pDeviceSrvMsg = NULL;

    while (!g_DeviceSrvMsgQueue.empty())
    {
        pDeviceSrvMsg = (device_srv_msg_t*) g_DeviceSrvMsgQueue.front();
        g_DeviceSrvMsgQueue.pop_front();

        if (NULL != pDeviceSrvMsg)
        {
            device_srv_msg_free(pDeviceSrvMsg);
            pDeviceSrvMsg = NULL;
        }
    }

    g_DeviceSrvMsgQueue.clear();

#ifdef MULTI_THR

    if (NULL != g_DeviceSrvMsgQueueLock)
    {
        osip_mutex_destroy((struct osip_mutex*)g_DeviceSrvMsgQueueLock);
        g_DeviceSrvMsgQueueLock = NULL;
    }

#endif

    return;
}

/*****************************************************************************
 函 数 名  : device_srv_msg_list_clean
 功能描述  : 标准设备业务消息队列清除
 输入参数  : 无
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2017年3月8日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
void device_srv_msg_list_clean()
{
    device_srv_msg_t* pDeviceSrvMsg = NULL;

    while (!g_DeviceSrvMsgQueue.empty())
    {
        pDeviceSrvMsg = (device_srv_msg_t*) g_DeviceSrvMsgQueue.front();
        g_DeviceSrvMsgQueue.pop_front();

        if (NULL != pDeviceSrvMsg)
        {
            device_srv_msg_free(pDeviceSrvMsg);
            pDeviceSrvMsg = NULL;
        }
    }

    g_DeviceSrvMsgQueue.clear();

    return;
}

/*****************************************************************************
 函 数 名  : device_srv_msg_add
 功能描述  : 添加标准设备业务消息到队列中
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             msg_type_t msg_type
             char* caller_id
             char* callee_id
             int response_code
             char* reasonphrase
             int ua_dialog_index
             char* msg_body
             int msg_body_len
             int cr_pos
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月11日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_srv_msg_add(GBDevice_info_t* pGBDeviceInfo, msg_type_t msg_type, char* caller_id, char* callee_id, int response_code, char* reasonphrase, int ua_dialog_index, char* msg_body, int msg_body_len, int cr_pos)
{
    device_srv_msg_t* pDeviceSrvMsg = NULL;
    int iRet = 0;

    if (caller_id == NULL || callee_id == NULL)
    {
        //DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG,  "device_srv_msg_add() exit---: Param Error \r\n");
        return -1;
    }

    iRet = device_srv_msg_init(&pDeviceSrvMsg);

    if (iRet != 0)
    {
        //DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_srv_msg_add() exit---: Message Init Error \r\n");
        return -1;
    }

    pDeviceSrvMsg->msg_type = msg_type;
    pDeviceSrvMsg->pGBDeviceInfo = pGBDeviceInfo;

    if (NULL != caller_id)
    {
        osip_strncpy(pDeviceSrvMsg->caller_id, caller_id, MAX_ID_LEN);
    }

    if (NULL != callee_id)
    {
        osip_strncpy(pDeviceSrvMsg->callee_id, callee_id, MAX_ID_LEN);
    }

    pDeviceSrvMsg->response_code = response_code;

    if (NULL != reasonphrase)
    {
        osip_strncpy(pDeviceSrvMsg->reasonphrase, reasonphrase, MAX_128CHAR_STRING_LEN);
    }

    pDeviceSrvMsg->ua_dialog_index = ua_dialog_index;

    if (NULL != msg_body)
    {
        osip_strncpy(pDeviceSrvMsg->msg_body, msg_body, MAX_MSG_BODY_STRING_LEN);
    }

    pDeviceSrvMsg->msg_body_len = msg_body_len;
    pDeviceSrvMsg->cr_pos = cr_pos;

#ifdef MULTI_THR
    CMS_GBL_SMUTEX_LOCK((struct osip_mutex*)g_DeviceSrvMsgQueueLock);
#endif

    g_DeviceSrvMsgQueue.push_back(pDeviceSrvMsg);

#ifdef MULTI_THR
    CMS_GBL_SMUTEX_UNLOCK((struct osip_mutex*)g_DeviceSrvMsgQueueLock);
#endif

    return 0;
}

/*****************************************************************************
 函 数 名  : scan_device_srv_msg_list
 功能描述  : 扫描设备业务消息队列
 输入参数  : 无
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月17日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
void scan_device_srv_msg_list(DBOper* pDevice_Srv_dboper)
{
    int iRet = 0;
    device_srv_msg_t* pDeviceSrvMsg = NULL;

#ifdef MULTI_THR
    CMS_GBL_SMUTEX_LOCK((struct osip_mutex*)g_DeviceSrvMsgQueueLock);
#endif

    while (!g_DeviceSrvMsgQueue.empty())
    {
        pDeviceSrvMsg = (device_srv_msg_t*) g_DeviceSrvMsgQueue.front();
        g_DeviceSrvMsgQueue.pop_front();

        if (NULL != pDeviceSrvMsg)
        {
            break;
        }
    }

#ifdef MULTI_THR
    CMS_GBL_SMUTEX_UNLOCK((struct osip_mutex*)g_DeviceSrvMsgQueueLock);
#endif

    if (NULL != pDeviceSrvMsg)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "scan_device_srv_msg_list() \
        \r\n In Param: \
        \r\n msg_type=%d \
        \r\n caller_id=%s \
        \r\n callee_id=%s \
        \r\n response_code=%d \
        \r\n ua_dialog_index=%d \
        \r\n msg_body_len=%d \
        \r\n ", pDeviceSrvMsg->msg_type, pDeviceSrvMsg->caller_id, pDeviceSrvMsg->callee_id, pDeviceSrvMsg->response_code, pDeviceSrvMsg->ua_dialog_index, pDeviceSrvMsg->msg_body_len);

        iRet = device_srv_msg_proc(pDeviceSrvMsg, pDevice_Srv_dboper);
        device_srv_msg_free(pDeviceSrvMsg);
        pDeviceSrvMsg = NULL;
    }

    return;
}

/*****************************************************************************
 函 数 名  : device_message_srv_msg_list_init
 功能描述  : 标准设备Message业务消息队列初始化
 输入参数  : 无
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月11日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_message_srv_msg_list_init()
{
    g_DeviceMessageSrvMsgQueue.clear();

#ifdef MULTI_THR
    /* init smutex */
    g_DeviceMessageSrvMsgQueueLock = (osip_mutex_t*)osip_mutex_init();

    if (NULL == g_DeviceMessageSrvMsgQueueLock)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG,  "device_message_srv_msg_list_init() exit---: Device Message Srv Msg List Lock Init Error \r\n");
        return -1;
    }

#endif
    return 0;
}

/*****************************************************************************
 函 数 名  : device_message_srv_msg_list_free
 功能描述  : 标准设备Message业务消息队列释放
 输入参数  : 无
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月11日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
void device_message_srv_msg_list_free()
{
    device_srv_msg_t* pDeviceSrvMsg = NULL;

    while (!g_DeviceMessageSrvMsgQueue.empty())
    {
        pDeviceSrvMsg = (device_srv_msg_t*) g_DeviceMessageSrvMsgQueue.front();
        g_DeviceMessageSrvMsgQueue.pop_front();

        if (NULL != pDeviceSrvMsg)
        {
            device_srv_msg_free(pDeviceSrvMsg);
            pDeviceSrvMsg = NULL;
        }
    }

    g_DeviceMessageSrvMsgQueue.clear();

#ifdef MULTI_THR

    if (NULL != g_DeviceMessageSrvMsgQueueLock)
    {
        osip_mutex_destroy((struct osip_mutex*)g_DeviceMessageSrvMsgQueueLock);
        g_DeviceMessageSrvMsgQueueLock = NULL;
    }

#endif

    return;
}

/*****************************************************************************
 函 数 名  : device_message_srv_msg_list_clean
 功能描述  :  标准设备Message业务消息队列清除
 输入参数  : 无
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2017年3月8日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
void device_message_srv_msg_list_clean()
{
    device_srv_msg_t* pDeviceSrvMsg = NULL;

    while (!g_DeviceMessageSrvMsgQueue.empty())
    {
        pDeviceSrvMsg = (device_srv_msg_t*) g_DeviceMessageSrvMsgQueue.front();
        g_DeviceMessageSrvMsgQueue.pop_front();

        if (NULL != pDeviceSrvMsg)
        {
            device_srv_msg_free(pDeviceSrvMsg);
            pDeviceSrvMsg = NULL;
        }
    }

    g_DeviceMessageSrvMsgQueue.clear();

    return;
}

/*****************************************************************************
 函 数 名  : device_message_srv_msg_add
 功能描述  : 添加标准设备Message业务消息到队列中
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             msg_type_t msg_type
             char* caller_id
             char* callee_id
             int response_code
             int ua_dialog_index
             char* msg_body
             int msg_body_len
             int cr_pos
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月11日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_message_srv_msg_add(GBDevice_info_t* pGBDeviceInfo, msg_type_t msg_type, char* caller_id, char* callee_id, int response_code, int ua_dialog_index, char* msg_body, int msg_body_len, int cr_pos)
{
    device_srv_msg_t* pDeviceSrvMsg = NULL;
    int iRet = 0;

    if (caller_id == NULL || callee_id == NULL)
    {
        //DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG,  "device_message_srv_msg_add() exit---: Param Error \r\n");
        return -1;
    }

    iRet = device_srv_msg_init(&pDeviceSrvMsg);

    if (iRet != 0)
    {
        //DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_message_srv_msg_add() exit---: Message Init Error \r\n");
        return -1;
    }

    pDeviceSrvMsg->msg_type = msg_type;
    pDeviceSrvMsg->pGBDeviceInfo = pGBDeviceInfo;

    if (NULL != caller_id)
    {
        osip_strncpy(pDeviceSrvMsg->caller_id, caller_id, MAX_ID_LEN);
    }

    if (NULL != callee_id)
    {
        osip_strncpy(pDeviceSrvMsg->callee_id, callee_id, MAX_ID_LEN);
    }

    pDeviceSrvMsg->response_code = response_code;
    pDeviceSrvMsg->ua_dialog_index = ua_dialog_index;

    if (NULL != msg_body)
    {
        osip_strncpy(pDeviceSrvMsg->msg_body, msg_body, MAX_MSG_BODY_STRING_LEN);
    }

    pDeviceSrvMsg->msg_body_len = msg_body_len;
    pDeviceSrvMsg->cr_pos = cr_pos;

#ifdef MULTI_THR
    CMS_GBL_SMUTEX_LOCK((struct osip_mutex*)g_DeviceMessageSrvMsgQueueLock);
#endif

    g_DeviceMessageSrvMsgQueue.push_back(pDeviceSrvMsg);

#ifdef MULTI_THR
    CMS_GBL_SMUTEX_UNLOCK((struct osip_mutex*)g_DeviceMessageSrvMsgQueueLock);
#endif

    return 0;
}

/*****************************************************************************
 函 数 名  : scan_device_message_srv_msg_list
 功能描述  : 扫描设备Message业务消息队列
 输入参数  : 无
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月17日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
void scan_device_message_srv_msg_list(DBOper* pDevice_Srv_dboper)
{
    int iRet = 0;
    device_srv_msg_t* pDeviceSrvMsg = NULL;

    //DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "scan_device_srv_msg_list() Enter--- \r\n");

#ifdef MULTI_THR
    CMS_GBL_SMUTEX_LOCK((struct osip_mutex*)g_DeviceMessageSrvMsgQueueLock);
#endif

    while (!g_DeviceMessageSrvMsgQueue.empty())
    {
        //DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "scan_device_srv_msg_list() g_DeviceSrvMsgQueue Not Empty \r\n");

        pDeviceSrvMsg = (device_srv_msg_t*) g_DeviceMessageSrvMsgQueue.front();
        g_DeviceMessageSrvMsgQueue.pop_front();

        if (NULL != pDeviceSrvMsg)
        {
            //DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "scan_device_srv_msg_list() DeviceSrvMsg Not NULL \r\n");
            break;
        }
    }

#ifdef MULTI_THR
    CMS_GBL_SMUTEX_UNLOCK((struct osip_mutex*)g_DeviceMessageSrvMsgQueueLock);
#endif

    if (NULL != pDeviceSrvMsg)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "scan_device_message_srv_msg_list() \
        \r\n In Param: \
        \r\n msg_type=%d \
        \r\n caller_id=%s \
        \r\n callee_id=%s \
        \r\n response_code=%d \
        \r\n ua_dialog_index=%d \
        \r\n msg_body_len=%d \
        \r\n ", pDeviceSrvMsg->msg_type, pDeviceSrvMsg->caller_id, pDeviceSrvMsg->callee_id, pDeviceSrvMsg->response_code, pDeviceSrvMsg->ua_dialog_index, pDeviceSrvMsg->msg_body_len);

        iRet = device_srv_msg_proc(pDeviceSrvMsg, pDevice_Srv_dboper);
        device_srv_msg_free(pDeviceSrvMsg);
        pDeviceSrvMsg = NULL;
    }

    //DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "scan_device_srv_msg_list() Exit--- \r\n");
    return;
}
#endif

#if DECS("诊断结果上报消息队列")
/*****************************************************************************
 函 数 名  : diagnosis_msg_init
 功能描述  : 诊断结果上报消息结构初始化
 输入参数  : diagnosis_msg_t ** diagnosis_msg
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月11日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int diagnosis_msg_init(diagnosis_msg_t** diagnosis_msg)
{
    *diagnosis_msg = (diagnosis_msg_t*)osip_malloc(sizeof(diagnosis_msg_t));

    if (*diagnosis_msg == NULL)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "diagnosis_msg_init() exit---: *diagnosis_msg Smalloc Error \r\n");
        return -1;
    }

    (*diagnosis_msg)->strSN[0] = '\0';
    (*diagnosis_msg)->strDeviceID[0] = '\0';
    (*diagnosis_msg)->strDeviceIP[0] = '\0';
    (*diagnosis_msg)->strChannelID[0] = '\0';
    (*diagnosis_msg)->strDiagnosisTime[0] = '\0';
    (*diagnosis_msg)->strImageFile[0] = '\0';
    (*diagnosis_msg)->strVideoLost[0] = '\0';
    (*diagnosis_msg)->strVideoOcclusion[0] = '\0';
    (*diagnosis_msg)->strVideoFrozen[0] = '\0';
    (*diagnosis_msg)->strVideoLum[0] = '\0';
    (*diagnosis_msg)->strVideoShake[0] = '\0';
    (*diagnosis_msg)->strVideoSnow[0] = '\0';
    (*diagnosis_msg)->strVideoBlur[0] = '\0';
    (*diagnosis_msg)->strVideoHue[0] = '\0';

    return 0;
}

/*****************************************************************************
 函 数 名  : diagnosis_msg_free
 功能描述  : 诊断结果上报消息结构释放
 输入参数  : diagnosis_msg_t * diagnosis_msg
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月11日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
void diagnosis_msg_free(diagnosis_msg_t* diagnosis_msg)
{
    if (diagnosis_msg == NULL)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "diagnosis_msg_free() exit---: Param Error \r\n");
        return;
    }

    memset(diagnosis_msg->strSN, 0, 32);
    memset(diagnosis_msg->strDeviceID, 0, MAX_ID_LEN + 4);
    memset(diagnosis_msg->strDeviceIP, 0, 16);
    memset(diagnosis_msg->strChannelID, 0, MAX_ID_LEN + 4);
    memset(diagnosis_msg->strDiagnosisTime, 0, 32);
    memset(diagnosis_msg->strImageFile, 0, 256);
    memset(diagnosis_msg->strVideoLost, 0, 32);
    memset(diagnosis_msg->strVideoOcclusion, 0, 32);
    memset(diagnosis_msg->strVideoFrozen, 0, 32);
    memset(diagnosis_msg->strVideoLum, 0, 32);
    memset(diagnosis_msg->strVideoShake, 0, 32);
    memset(diagnosis_msg->strVideoSnow, 0, 32);
    memset(diagnosis_msg->strVideoBlur, 0, 32);
    memset(diagnosis_msg->strVideoHue, 0, 32);

    return;
}

/*****************************************************************************
 函 数 名  : diagnosis_msg_list_init
 功能描述  : 诊断结果上报消息队列初始化
 输入参数  : 无
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月11日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int diagnosis_msg_list_init()
{
    g_DiagnosisMsgQueue.clear();

#ifdef MULTI_THR
    /* init smutex */
    g_DiagnosisMsgQueueLock = (osip_mutex_t*)osip_mutex_init();

    if (NULL == g_DiagnosisMsgQueueLock)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "diagnosis_msg_list_init() exit---: Diagnosis Message List Lock Init Error \r\n");
        return -1;
    }

#endif
    return 0;
}

/*****************************************************************************
 函 数 名  : diagnosis_msg_list_free
 功能描述  : 诊断结果上报消息队列释放
 输入参数  : 无
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月11日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
void diagnosis_msg_list_free()
{
    diagnosis_msg_t* pDiagnosisMsg = NULL;

    while (!g_DiagnosisMsgQueue.empty())
    {
        pDiagnosisMsg = (diagnosis_msg_t*) g_DiagnosisMsgQueue.front();
        g_DiagnosisMsgQueue.pop_front();

        if (NULL != pDiagnosisMsg)
        {
            diagnosis_msg_free(pDiagnosisMsg);
            osip_free(pDiagnosisMsg);
            pDiagnosisMsg = NULL;
        }
    }

    g_DiagnosisMsgQueue.clear();

#ifdef MULTI_THR

    if (NULL != g_DiagnosisMsgQueueLock)
    {
        osip_mutex_destroy((struct osip_mutex*)g_DiagnosisMsgQueueLock);
        g_DiagnosisMsgQueueLock = NULL;
    }

#endif

    return;
}

/*****************************************************************************
 函 数 名  : diagnosis_msg_list_clean
 功能描述  : 诊断结果上报消息队列清除
 输入参数  : 无
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2017年3月8日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
void diagnosis_msg_list_clean()
{
    diagnosis_msg_t* pDiagnosisMsg = NULL;

    while (!g_DiagnosisMsgQueue.empty())
    {
        pDiagnosisMsg = (diagnosis_msg_t*) g_DiagnosisMsgQueue.front();
        g_DiagnosisMsgQueue.pop_front();

        if (NULL != pDiagnosisMsg)
        {
            diagnosis_msg_free(pDiagnosisMsg);
            osip_free(pDiagnosisMsg);
            pDiagnosisMsg = NULL;
        }
    }

    g_DiagnosisMsgQueue.clear();

    return;
}

/*****************************************************************************
 函 数 名  : diagnosis_msg_add
 功能描述  : 添加诊断结果上报消息到队列中
 输入参数  : diagnosis_msg_t* pDiagnosisMsg
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月11日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int diagnosis_msg_add(diagnosis_msg_t* pDiagnosisMsg)
{
    int iRet = 0;

    if (NULL == pDiagnosisMsg)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "diagnosis_msg_add() exit---: Param Error \r\n");
        return -1;
    }

#ifdef MULTI_THR

    CMS_GBL_SMUTEX_LOCK((struct osip_mutex*)g_DiagnosisMsgQueueLock);

#endif

    g_DiagnosisMsgQueue.push_back(pDiagnosisMsg);

#ifdef MULTI_THR
    CMS_GBL_SMUTEX_UNLOCK((struct osip_mutex*)g_DiagnosisMsgQueueLock);
#endif

    return 0;
}

/*****************************************************************************
 函 数 名  : scan_diagnosis_msg_list
 功能描述  : 扫描诊断上报消息队列
 输入参数  : DBOper* pDboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月23日 星期四
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
void scan_diagnosis_msg_list(DBOper* pDboper)
{
    int iRet = 0;
    diagnosis_msg_t* pDiagnosisMsg = NULL;

    if (NULL == pDboper)
    {
        return;
    }

#ifdef MULTI_THR
    CMS_GBL_SMUTEX_LOCK((struct osip_mutex*)g_DiagnosisMsgQueueLock);
#endif

    while (!g_DiagnosisMsgQueue.empty())
    {
        pDiagnosisMsg = (diagnosis_msg_t*) g_DiagnosisMsgQueue.front();
        g_DiagnosisMsgQueue.pop_front();

        if (NULL != pDiagnosisMsg)
        {
            break;
        }
    }

#ifdef MULTI_THR
    CMS_GBL_SMUTEX_UNLOCK((struct osip_mutex*)g_DiagnosisMsgQueueLock);
#endif

    if (NULL != pDiagnosisMsg)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "scan_diagnosis_msg_list() \
    \r\n In Param: \
    \r\n SN=%s \
    \r\n DeviceID=%s \
    \r\n VideoChlCode=%s \
    \r\n DiagnosisTime=%s \
    \r\n ImageFile=%s \r\n ", pDiagnosisMsg->strSN, pDiagnosisMsg->strDeviceID, pDiagnosisMsg->strChannelID, pDiagnosisMsg->strDiagnosisTime, pDiagnosisMsg->strImageFile);

        iRet = diagnosis_msg_proc(pDiagnosisMsg, pDboper);
        diagnosis_msg_free(pDiagnosisMsg);
        osip_free(pDiagnosisMsg);
        pDiagnosisMsg = NULL;
    }

    return;
}

/*****************************************************************************
 函 数 名  : diagnosis_msg_proc
 功能描述  : 诊断消息处理
 输入参数  : diagnosis_msg_t* pDiagnosisMsg
             DBOper* pDboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年9月12日 星期五
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int diagnosis_msg_proc(diagnosis_msg_t* pDiagnosisMsg, DBOper* pDboper)
{
    int iRet = 0;

    if (NULL == pDiagnosisMsg || NULL == pDboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "diagnosis_msg_proc() exit---: Diagnosis Msg Error \r\n");
        return -1;
    }

    /* 将诊断结果数据写入记录表*/
    iRet = write_diagnosis_msg_to_db_proc(pDiagnosisMsg, pDboper);

    if (0 != iRet)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "diagnosis_msg_proc() write_diagnosis_msg_to_db_proc Error:iRet=%d \r\n", iRet);
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "diagnosis_msg_proc() write_diagnosis_msg_to_db_proc OK:iRet=%d \r\n", iRet);
    }

    return iRet;
}

/*****************************************************************************
 函 数 名  : write_diagnosis_msg_to_db_proc
 功能描述  : 将诊断结果信息写入数据库
 输入参数  : diagnosis_msg_t* pDiagnosisMsg
             DBOper* pDboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年9月12日 星期五
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int write_diagnosis_msg_to_db_proc(diagnosis_msg_t* pDiagnosisMsg, DBOper* pDboper)
{
    int iRet = 0;
    int record_count = -1;
    string strQuerySQL = "";
    string strInsertSQL = "";
    string strUpdateSQL = "";
    char strImageName[256] = {0};

    if (NULL == pDiagnosisMsg || NULL == pDboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "write_diagnosis_msg_to_db_proc() exit---: Param Error \r\n");
        return -1;
    }

    snprintf(strImageName, 256, "http://%s:4113/diagnose_result/%s", pDiagnosisMsg->strDeviceIP, pDiagnosisMsg->strImageFile);

    /* 1、查询SQL语句 */
    strQuerySQL.clear();
    strQuerySQL = "select * from IVASRealDiagnosis WHERE DeviceID like '";
    strQuerySQL += pDiagnosisMsg->strChannelID;
    strQuerySQL += "'";

    /* 2、插入SQL语句 */
    strInsertSQL.clear();
    strInsertSQL = "insert into IVASRealDiagnosis (DeviceID,DiagnosisTime,ImageName,VideoLost,VideoOcclusion,VideoFrozen,VideoLum,VideoShake,VideoSnow,VideoBlur,VideoHue,VideoNightMode,VideoLumLow,VideoContrastLow,VideoUpheaval,VideoMosaic,VideoStripe,VideoPTZ,VideoSceneChange,VideoNetWork,VideoLogIn,VideoNoStream) values (";

    /* 视频通道编号 */
    strInsertSQL += "'";

    strInsertSQL += pDiagnosisMsg->strChannelID;

    strInsertSQL += "'";

    strInsertSQL += ",";

    /* 诊断时间 */
    strInsertSQL += "'";

    strInsertSQL += pDiagnosisMsg->strDiagnosisTime;

    strInsertSQL += "'";

    strInsertSQL += ",";

    /* 截图路径 */
    strInsertSQL += "'";

    strInsertSQL += strImageName;

    strInsertSQL += "'";

    strInsertSQL += ",";

    /* 视频丢失     异常程度0~100 */
    if (pDiagnosisMsg->strVideoLost[0] != '\0')
    {
        strInsertSQL += pDiagnosisMsg->strVideoLost;
    }
    else
    {
        strInsertSQL += "0";
    }

    strInsertSQL += ",";

    /* 镜头遮挡     异常程度0~100 */
    if (pDiagnosisMsg->strVideoOcclusion[0] != '\0')
    {
        strInsertSQL += pDiagnosisMsg->strVideoOcclusion;
    }
    else
    {
        strInsertSQL += "0";
    }

    strInsertSQL += ",";

    /* 画面冻结     异常程度0~100 */
    if (pDiagnosisMsg->strVideoFrozen[0] != '\0')
    {
        strInsertSQL += pDiagnosisMsg->strVideoFrozen;
    }
    else
    {
        strInsertSQL += "0";
    }

    strInsertSQL += ",";

    /* 亮度异常     异常程度0~100 */
    if (pDiagnosisMsg->strVideoLum[0] != '\0')
    {
        strInsertSQL += pDiagnosisMsg->strVideoLum;
    }
    else
    {
        strInsertSQL += "0";
    }

    strInsertSQL += ",";

    /* 镜头抖动   异常程度0~100 */
    if (pDiagnosisMsg->strVideoShake[0] != '\0')
    {
        strInsertSQL += pDiagnosisMsg->strVideoShake;
    }
    else
    {
        strInsertSQL += "0";
    }

    strInsertSQL += ",";

    /* 雪花噪声     异常程度0~100 */
    if (pDiagnosisMsg->strVideoSnow[0] != '\0')
    {
        strInsertSQL += pDiagnosisMsg->strVideoSnow;
    }
    else
    {
        strInsertSQL += "0";
    }

    strInsertSQL += ",";

    /* 镜头模糊     异常程度0~100 */
    if (pDiagnosisMsg->strVideoBlur[0] != '\0')
    {
        strInsertSQL += pDiagnosisMsg->strVideoBlur;
    }
    else
    {
        strInsertSQL += "0";
    }

    strInsertSQL += ",";

    /* 画面偏色     异常程度0~100 */
    if (pDiagnosisMsg->strVideoHue[0] != '\0')
    {
        strInsertSQL += pDiagnosisMsg->strVideoHue;
    }
    else
    {
        strInsertSQL += "0";
    }

    strInsertSQL += ",";

    /* 黑白图像     异常程度0~100 */
    if (pDiagnosisMsg->strVideoNightMode[0] != '\0')
    {
        strInsertSQL += pDiagnosisMsg->strVideoNightMode;
    }
    else
    {
        strInsertSQL += "0";
    }

    strInsertSQL += ",";

    /* 图像过暗     异常程度0~100 */
    if (pDiagnosisMsg->strVideoLumLow[0] != '\0')
    {
        strInsertSQL += pDiagnosisMsg->strVideoLumLow;
    }
    else
    {
        strInsertSQL += "0";
    }

    strInsertSQL += ",";

    /* 低对比度     异常程度0~100 */
    if (pDiagnosisMsg->strVideoContrastLow[0] != '\0')
    {
        strInsertSQL += pDiagnosisMsg->strVideoContrastLow;
    }
    else
    {
        strInsertSQL += "0";
    }

    strInsertSQL += ",";

    /* 视频剧变     异常程度0~100 */
    if (pDiagnosisMsg->strVideoUpheaval[0] != '\0')
    {
        strInsertSQL += pDiagnosisMsg->strVideoUpheaval;
    }
    else
    {
        strInsertSQL += "0";
    }

    strInsertSQL += ",";

    /* 马赛克     异常程度0~100 */
    if (pDiagnosisMsg->strVideoMosaic[0] != '\0')
    {
        strInsertSQL += pDiagnosisMsg->strVideoMosaic;
    }
    else
    {
        strInsertSQL += "0";
    }

    strInsertSQL += ",";

    /* 条纹干扰     异常程度0~100 */
    if (pDiagnosisMsg->strVideoStripe[0] != '\0')
    {
        strInsertSQL += pDiagnosisMsg->strVideoStripe;
    }
    else
    {
        strInsertSQL += "0";
    }

    strInsertSQL += ",";

    /* PTZ异常     异常程度0~100 */
    if (pDiagnosisMsg->strVideoPTZ[0] != '\0')
    {
        strInsertSQL += pDiagnosisMsg->strVideoPTZ;
    }
    else
    {
        strInsertSQL += "0";
    }

    strInsertSQL += ",";

    /* 场景变更     异常程度0~100 */
    if (pDiagnosisMsg->strVideoSceneChange[0] != '\0')
    {
        strInsertSQL += pDiagnosisMsg->strVideoSceneChange;
    }
    else
    {
        strInsertSQL += "0";
    }

    strInsertSQL += ",";

    /* 网络异常     异常程度0~100 */
    if (pDiagnosisMsg->strVideoNetWork[0] != '\0')
    {
        strInsertSQL += pDiagnosisMsg->strVideoNetWork;
    }
    else
    {
        strInsertSQL += "0";
    }

    strInsertSQL += ",";

    /* 登录失败     异常程度0~100 */
    if (pDiagnosisMsg->strVideoLogIn[0] != '\0')
    {
        strInsertSQL += pDiagnosisMsg->strVideoLogIn;
    }
    else
    {
        strInsertSQL += "0";
    }

    strInsertSQL += ",";

    /* 取流失败     异常程度0~100 */
    if (pDiagnosisMsg->strVideoNoStream[0] != '\0')
    {
        strInsertSQL += pDiagnosisMsg->strVideoNoStream;
    }
    else
    {
        strInsertSQL += "0";
    }

    strInsertSQL += ")";

    /* 3、更新SQL语句 */
    strUpdateSQL.clear();
    strUpdateSQL = "UPDATE IVASRealDiagnosis SET";

    /* 诊断时间 */
    strUpdateSQL += " DiagnosisTime = ";
    strUpdateSQL += "'";
    strUpdateSQL += pDiagnosisMsg->strDiagnosisTime;
    strUpdateSQL += "'";

    strUpdateSQL += ",";

    /* 截图路径 */
    strUpdateSQL += " ImageName = ";
    strUpdateSQL += "'";
    strUpdateSQL += strImageName;
    strUpdateSQL += "'";

    /* 视频丢失     异常程度0~100 */
    if (pDiagnosisMsg->strVideoLost[0] != '\0')
    {
        strUpdateSQL += ",";

        strUpdateSQL += " VideoLost = ";
        strUpdateSQL += pDiagnosisMsg->strVideoLost;
    }

    /* 镜头遮挡     异常程度0~100 */
    if (pDiagnosisMsg->strVideoOcclusion[0] != '\0')
    {
        strUpdateSQL += ",";

        strUpdateSQL += " VideoOcclusion = ";
        strUpdateSQL += pDiagnosisMsg->strVideoOcclusion;
    }

    /* 画面冻结     异常程度0~100 */
    if (pDiagnosisMsg->strVideoFrozen[0] != '\0')
    {
        strUpdateSQL += ",";

        strUpdateSQL += " VideoFrozen = ";
        strUpdateSQL += pDiagnosisMsg->strVideoFrozen;
    }

    /* 亮度异常     异常程度0~100 */
    if (pDiagnosisMsg->strVideoLum[0] != '\0')
    {
        strUpdateSQL += ",";

        strUpdateSQL += " VideoLum = ";
        strUpdateSQL += pDiagnosisMsg->strVideoLum;
    }

    /* 镜头抖动   异常程度0~100 */
    if (pDiagnosisMsg->strVideoShake[0] != '\0')
    {
        strUpdateSQL += ",";

        strUpdateSQL += " VideoShake = ";
        strUpdateSQL += pDiagnosisMsg->strVideoShake;
    }

    /* 雪花噪声     异常程度0~100 */
    if (pDiagnosisMsg->strVideoSnow[0] != '\0')
    {
        strUpdateSQL += ",";

        strUpdateSQL += " VideoSnow = ";
        strUpdateSQL += pDiagnosisMsg->strVideoSnow;
    }

    /* 镜头模糊     异常程度0~100 */
    if (pDiagnosisMsg->strVideoBlur[0] != '\0')
    {
        strUpdateSQL += ",";

        strUpdateSQL += " VideoBlur = ";
        strUpdateSQL += pDiagnosisMsg->strVideoBlur;
    }

    /* 画面偏色     异常程度0~100 */
    if (pDiagnosisMsg->strVideoHue[0] != '\0')
    {
        strUpdateSQL += ",";

        strUpdateSQL += " VideoHue = ";
        strUpdateSQL += pDiagnosisMsg->strVideoHue;
    }

    /* 黑白图像     异常程度0~100 */
    if (pDiagnosisMsg->strVideoNightMode[0] != '\0')
    {
        strUpdateSQL += ",";

        strUpdateSQL += " VideoNightMode = ";
        strUpdateSQL += pDiagnosisMsg->strVideoNightMode;
    }

    /* 图像过暗     异常程度0~100 */
    if (pDiagnosisMsg->strVideoLumLow[0] != '\0')
    {
        strUpdateSQL += ",";

        strUpdateSQL += " VideoLumLow = ";
        strUpdateSQL += pDiagnosisMsg->strVideoLumLow;
    }

    /* 低对比度     异常程度0~100 */
    if (pDiagnosisMsg->strVideoContrastLow[0] != '\0')
    {
        strUpdateSQL += ",";

        strUpdateSQL += " VideoContrastLow = ";
        strUpdateSQL += pDiagnosisMsg->strVideoContrastLow;
    }

    /* 视频剧变     异常程度0~100 */
    if (pDiagnosisMsg->strVideoUpheaval[0] != '\0')
    {
        strUpdateSQL += ",";

        strUpdateSQL += " VideoUpheaval = ";
        strUpdateSQL += pDiagnosisMsg->strVideoUpheaval;
    }

    /* 马赛克     异常程度0~100 */
    if (pDiagnosisMsg->strVideoMosaic[0] != '\0')
    {
        strUpdateSQL += ",";

        strUpdateSQL += " VideoMosaic = ";
        strUpdateSQL += pDiagnosisMsg->strVideoMosaic;
    }

    /* 条纹干扰     异常程度0~100 */
    if (pDiagnosisMsg->strVideoStripe[0] != '\0')
    {
        strUpdateSQL += ",";

        strUpdateSQL += " VideoStripe = ";
        strUpdateSQL += pDiagnosisMsg->strVideoStripe;
    }

    /* PTZ异常     异常程度0~100 */
    if (pDiagnosisMsg->strVideoPTZ[0] != '\0')
    {
        strUpdateSQL += ",";

        strUpdateSQL += " VideoPTZ = ";
        strUpdateSQL += pDiagnosisMsg->strVideoPTZ;
    }

    /* 场景变更     异常程度0~100 */
    if (pDiagnosisMsg->strVideoSceneChange[0] != '\0')
    {
        strUpdateSQL += ",";

        strUpdateSQL += " VideoSceneChange = ";
        strUpdateSQL += pDiagnosisMsg->strVideoSceneChange;
    }

    /* 网络异常     异常程度0~100 */
    if (pDiagnosisMsg->strVideoNetWork[0] != '\0')
    {
        strUpdateSQL += ",";

        strUpdateSQL += " VideoNetWork = ";
        strUpdateSQL += pDiagnosisMsg->strVideoNetWork;
    }

    /* 登录失败     异常程度0~100 */
    if (pDiagnosisMsg->strVideoLogIn[0] != '\0')
    {
        strUpdateSQL += ",";

        strUpdateSQL += " VideoLogIn = ";
        strUpdateSQL += pDiagnosisMsg->strVideoLogIn;
    }

    /* 取流失败     异常程度0~100 */
    if (pDiagnosisMsg->strVideoNoStream[0] != '\0')
    {
        strUpdateSQL += ",";

        strUpdateSQL += " VideoNoStream = ";
        strUpdateSQL += pDiagnosisMsg->strVideoNoStream;
    }

    strUpdateSQL += " WHERE DeviceID like ";
    strUpdateSQL += "'";
    strUpdateSQL += pDiagnosisMsg->strChannelID;
    strUpdateSQL += "'";

    record_count = pDboper->DB_Select(strQuerySQL.c_str(), 1);

    if (record_count < 0) /* 数据库错误 */
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "write_diagnosis_msg_to_db_proc() DB Oper Error:strSQL=%s, record_count=%d \r\n", strQuerySQL.c_str(), record_count);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "write_diagnosis_msg_to_db_proc() ErrorMsg=%s\r\n", pDboper->GetLastDbErrorMsg());
        return -1;
    }
    else if (record_count == 0) /* 没有记录 ，插入 */
    {
        iRet = pDboper->DB_Insert("", "", strInsertSQL.c_str(), 1);

        if (iRet < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "write_diagnosis_msg_to_db_proc() DB Oper Error:strInsertSQL=%s, iRet=%d \r\n", strInsertSQL.c_str(), iRet);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "write_diagnosis_msg_to_db_proc() ErrorMsg=%s\r\n", pDboper->GetLastDbErrorMsg());
        }
    }
    else /* 更新记录 */
    {
        iRet = pDboper->DB_Update(strUpdateSQL.c_str(), 1);

        if (iRet < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "write_diagnosis_msg_to_db_proc() DB Oper Error:strUpdateSQL=%s, iRet=%d \r\n", strUpdateSQL.c_str(), iRet);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "write_diagnosis_msg_to_db_proc() ErrorMsg=%s\r\n", pDboper->GetLastDbErrorMsg());
        }
    }

    return 0;
}
#endif

#if DECS("智能分析，目标计数结果上报消息队列")
/*****************************************************************************
 函 数 名  : analysis_target_count_msg_init
 功能描述  : 智能分析，目标计数结果上报消息结构初始化
 输入参数  : analysis_target_count_msg_t ** analysis_target_count_msg
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月11日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int analysis_target_count_msg_init(analysis_target_count_msg_t** analysis_target_count_msg)
{
    *analysis_target_count_msg = (analysis_target_count_msg_t*)osip_malloc(sizeof(analysis_target_count_msg_t));

    if (*analysis_target_count_msg == NULL)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "analysis_target_count_msg_init() exit---: *analysis_target_count_msg Smalloc Error \r\n");
        return -1;
    }

    (*analysis_target_count_msg)->strSN[0] = '\0';
    (*analysis_target_count_msg)->strDeviceID[0] = '\0';
    (*analysis_target_count_msg)->strChannelID[0] = '\0';

    (*analysis_target_count_msg)->strAreaIndex[0] = '\0';
    (*analysis_target_count_msg)->strAreaName[0] = '\0';
    (*analysis_target_count_msg)->strTargetCountTime[0] = '\0';

    (*analysis_target_count_msg)->strEnterPeople[0] = '\0';
    (*analysis_target_count_msg)->strEnterCar[0] = '\0';
    (*analysis_target_count_msg)->strLeavePeople[0] = '\0';
    (*analysis_target_count_msg)->strLeaveCar[0] = '\0';

    return 0;
}

/*****************************************************************************
 函 数 名  : analysis_target_count_msg_free
 功能描述  : 智能分析，目标计数结果上报消息结构释放
 输入参数  : analysis_target_count_msg_t * analysis_target_count_msg
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月11日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
void analysis_target_count_msg_free(analysis_target_count_msg_t* analysis_target_count_msg)
{
    if (analysis_target_count_msg == NULL)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "analysis_target_count_msg_free() exit---: Param Error \r\n");
        return;
    }

    memset(analysis_target_count_msg->strSN, 0, 32);
    memset(analysis_target_count_msg->strDeviceID, 0, MAX_ID_LEN + 4);
    memset(analysis_target_count_msg->strChannelID, 0, MAX_ID_LEN + 4);

    memset(analysis_target_count_msg->strAreaIndex, 0, 32);
    memset(analysis_target_count_msg->strAreaName, 0, 32);
    memset(analysis_target_count_msg->strTargetCountTime, 0, 32);

    memset(analysis_target_count_msg->strEnterPeople, 0, 32);
    memset(analysis_target_count_msg->strEnterCar, 0, 32);
    memset(analysis_target_count_msg->strLeavePeople, 0, 32);
    memset(analysis_target_count_msg->strLeaveCar, 0, 32);

    return;
}

/*****************************************************************************
 函 数 名  : analysis_target_count_msg_list_init
 功能描述  : 智能分析，目标计数结果上报消息队列初始化
 输入参数  : 无
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月11日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int analysis_target_count_msg_list_init()
{
    g_AnalysisTargetCountMsgQueue.clear();

#ifdef MULTI_THR
    /* init smutex */
    g_AnalysisTargetCountMsgQueueLock = (osip_mutex_t*)osip_mutex_init();

    if (NULL == g_AnalysisTargetCountMsgQueueLock)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "analysis_target_count_msg_list_init() exit---: Analysis Target Count Message List Lock Init Error \r\n");
        return -1;
    }

#endif
    return 0;
}

/*****************************************************************************
 函 数 名  : analysis_target_count_msg_list_free
 功能描述  : 智能分析，目标计数结果上报消息队列释放
 输入参数  : 无
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月11日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
void analysis_target_count_msg_list_free()
{
    analysis_target_count_msg_t* pAnalysisTargetCountMsg = NULL;

    while (!g_AnalysisTargetCountMsgQueue.empty())
    {
        pAnalysisTargetCountMsg = (analysis_target_count_msg_t*) g_AnalysisTargetCountMsgQueue.front();
        g_AnalysisTargetCountMsgQueue.pop_front();

        if (NULL != pAnalysisTargetCountMsg)
        {
            analysis_target_count_msg_free(pAnalysisTargetCountMsg);
            osip_free(pAnalysisTargetCountMsg);
            pAnalysisTargetCountMsg = NULL;
        }
    }

    g_AnalysisTargetCountMsgQueue.clear();

#ifdef MULTI_THR

    if (NULL != g_AnalysisTargetCountMsgQueueLock)
    {
        osip_mutex_destroy((struct osip_mutex*)g_AnalysisTargetCountMsgQueueLock);
        g_AnalysisTargetCountMsgQueueLock = NULL;
    }

#endif

    return;
}

/*****************************************************************************
 函 数 名  : analysis_target_count_msg_list_clean
 功能描述  : 智能分析，目标计数结果上报消息队列清除
 输入参数  : 无
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2017年3月8日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
void analysis_target_count_msg_list_clean()
{
    analysis_target_count_msg_t* pAnalysisTargetCountMsg = NULL;

    while (!g_AnalysisTargetCountMsgQueue.empty())
    {
        pAnalysisTargetCountMsg = (analysis_target_count_msg_t*) g_AnalysisTargetCountMsgQueue.front();
        g_AnalysisTargetCountMsgQueue.pop_front();

        if (NULL != pAnalysisTargetCountMsg)
        {
            analysis_target_count_msg_free(pAnalysisTargetCountMsg);
            osip_free(pAnalysisTargetCountMsg);
            pAnalysisTargetCountMsg = NULL;
        }
    }

    g_AnalysisTargetCountMsgQueue.clear();

    return;
}

/*****************************************************************************
 函 数 名  : analysis_target_count_msg_add
 功能描述  : 添加智能分析，目标计数结果上报消息到队列中
 输入参数  : analysis_target_count_msg_t* pAnalysisTargetCountMsg
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月11日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int analysis_target_count_msg_add(analysis_target_count_msg_t* pAnalysisTargetCountMsg)
{
    int iRet = 0;

    if (NULL == pAnalysisTargetCountMsg)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "analysis_target_count_msg_add() exit---: Param Error \r\n");
        return -1;
    }

#ifdef MULTI_THR
    CMS_GBL_SMUTEX_LOCK((struct osip_mutex*)g_AnalysisTargetCountMsgQueueLock);
#endif

    g_AnalysisTargetCountMsgQueue.push_back(pAnalysisTargetCountMsg);

#ifdef MULTI_THR
    CMS_GBL_SMUTEX_UNLOCK((struct osip_mutex*)g_AnalysisTargetCountMsgQueueLock);
#endif

    return 0;
}

/*****************************************************************************
 函 数 名  : scan_analysis_target_count_msg_list
 功能描述  : 扫描智能分析，目标计数上报消息队列
 输入参数  : DBOper* pDboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月23日 星期四
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
void scan_analysis_target_count_msg_list(DBOper* pDboper)
{
    int iRet = 0;
    analysis_target_count_msg_t* pAnalysisTargetCountMsg = NULL;

    if (NULL == pDboper)
    {
        return;
    }

#ifdef MULTI_THR
    CMS_GBL_SMUTEX_LOCK((struct osip_mutex*)g_AnalysisTargetCountMsgQueueLock);
#endif

    while (!g_AnalysisTargetCountMsgQueue.empty())
    {
        pAnalysisTargetCountMsg = (analysis_target_count_msg_t*) g_AnalysisTargetCountMsgQueue.front();
        g_AnalysisTargetCountMsgQueue.pop_front();

        if (NULL != pAnalysisTargetCountMsg)
        {
            break;
        }
    }

#ifdef MULTI_THR
    CMS_GBL_SMUTEX_UNLOCK((struct osip_mutex*)g_AnalysisTargetCountMsgQueueLock);
#endif

    if (NULL != pAnalysisTargetCountMsg)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "scan_analysis_target_count_msg_list() \
    \r\n In Param: \
    \r\n SN=%s \
    \r\n DeviceID=%s \
    \r\n VideoChlCode=%s \
    \r\n TargetCountTime=%s \
    \r\n AreaIndex=%s \r\n ", pAnalysisTargetCountMsg->strSN, pAnalysisTargetCountMsg->strDeviceID, pAnalysisTargetCountMsg->strChannelID, pAnalysisTargetCountMsg->strTargetCountTime, pAnalysisTargetCountMsg->strAreaIndex);

        iRet = analysis_target_count_msg_proc(pAnalysisTargetCountMsg, pDboper);
        analysis_target_count_msg_free(pAnalysisTargetCountMsg);
        osip_free(pAnalysisTargetCountMsg);
        pAnalysisTargetCountMsg = NULL;
    }

    return;
}

/*****************************************************************************
 函 数 名  : analysis_target_count_msg_proc
 功能描述  : 智能分析，目标计数消息处理
 输入参数  : analysis_target_count_msg_t* pAnalysisTargetCountMsg
             DBOper* pDboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年9月12日 星期五
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int analysis_target_count_msg_proc(analysis_target_count_msg_t* pAnalysisTargetCountMsg, DBOper* pDboper)
{
    int iRet = 0;

    if (NULL == pAnalysisTargetCountMsg || NULL == pDboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "analysis_target_count_msg_proc() exit---: Analysis Target Count Msg Error \r\n");
        return -1;
    }

    /* 将智能分析，目标计数结果数据写入记录表*/
    iRet = write_analysis_target_count_msg_to_db_proc(pAnalysisTargetCountMsg, pDboper);

    if (0 != iRet)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "analysis_target_count_msg_proc() write_analysis_target_count_msg_to_db_proc Error:iRet=%d \r\n", iRet);
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "analysis_target_count_msg_proc() write_analysis_target_count_msg_to_db_proc OK:iRet=%d \r\n", iRet);
    }

    return iRet;
}

/*****************************************************************************
 函 数 名  : write_analysis_target_count_msg_to_db_proc
 功能描述  : 将智能分析，目标计数结果信息写入数据库
 输入参数  : analysis_target_count_msg_t* pDiagnosisMsg
             DBOper* pDboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年9月12日 星期五
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int write_analysis_target_count_msg_to_db_proc(analysis_target_count_msg_t* pAnalysisTargetCountMsg, DBOper* pDboper)
{
    int iRet = 0;
    string strInsertSQL = "";

    if (NULL == pAnalysisTargetCountMsg || NULL == pDboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "write_analysis_target_count_msg_to_db_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 1、插入SQL语句 */
    strInsertSQL.clear();
    strInsertSQL = "insert into IVASCount (DeviceIndex,DeviceCode,AreaIndex,AreaName,Time,EnterPeople,EnterCar,LeavePeople,LeaveCar) values (";

    /* 逻辑设备DeviceID，20位国标编码，确定分析通道  */
    strInsertSQL += "'";

    strInsertSQL += pAnalysisTargetCountMsg->strChannelID;

    strInsertSQL += "'";

    strInsertSQL += ",";

    /* 诊断设备编码 */
    strInsertSQL += "'";

    strInsertSQL += pAnalysisTargetCountMsg->strDeviceID;

    strInsertSQL += "'";

    strInsertSQL += ",";

    /* 分析区域index，确定分析区域 */
    strInsertSQL += pAnalysisTargetCountMsg->strAreaIndex;

    strInsertSQL += ",";

    /* 分析区域name，确定分析区域名称  */
    strInsertSQL += "'";

    strInsertSQL += pAnalysisTargetCountMsg->strAreaName;

    strInsertSQL += "'";

    strInsertSQL += ",";

    /* 时间 */
    strInsertSQL += "'";

    strInsertSQL += pAnalysisTargetCountMsg->strTargetCountTime;

    strInsertSQL += "'";

    strInsertSQL += ",";

    /* 进入分析区域人数 */
    strInsertSQL += pAnalysisTargetCountMsg->strEnterPeople;

    strInsertSQL += ",";

    /* 进入分析区域车辆数 */
    strInsertSQL += pAnalysisTargetCountMsg->strEnterCar;

    strInsertSQL += ",";

    /* 离开分析区域人数 */
    strInsertSQL += pAnalysisTargetCountMsg->strLeavePeople;

    strInsertSQL += ",";

    /* 离开分析区域车辆数 */
    strInsertSQL += pAnalysisTargetCountMsg->strLeaveCar;

    strInsertSQL += ")";

    iRet = pDboper->DB_Insert("", "", strInsertSQL.c_str(), 1);

    if (iRet < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "write_analysis_target_count_msg_to_db_proc() DB Oper Error:strInsertSQL=%s, iRet=%d \r\n", strInsertSQL.c_str(), iRet);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "write_analysis_target_count_msg_to_db_proc() ErrorMsg=%s\r\n", pDboper->GetLastDbErrorMsg());
    }

    return 0;
}
#endif

/*****************************************************************************
 函 数 名  : device_srv_msg_proc
 功能描述  : 设备业务消息处理
 输入参数  : device_srv_msg_t* pDeviceSrvMsg
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月17日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_srv_msg_proc(device_srv_msg_t* pDeviceSrvMsg, DBOper* pDevice_Srv_dboper)
{
    int i = 0;

    if (NULL == pDeviceSrvMsg)
    {
        return -1;
    }

    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_srv_msg_proc() msg_type=%d \r\n ", pDeviceSrvMsg->msg_type);

    switch (pDeviceSrvMsg->msg_type)
    {
        case MSG_INVITE:
            i = device_invite_msg_proc(pDeviceSrvMsg->pGBDeviceInfo, pDeviceSrvMsg->caller_id, pDeviceSrvMsg->callee_id, pDeviceSrvMsg->ua_dialog_index, pDeviceSrvMsg->msg_body, pDeviceSrvMsg->msg_body_len);
            break;

        case  MSG_INVITE_RESPONSE:
            i = device_invite_response_msg_proc(pDeviceSrvMsg->cr_pos, pDeviceSrvMsg->ua_dialog_index, pDeviceSrvMsg->response_code, pDeviceSrvMsg->reasonphrase, pDeviceSrvMsg->msg_body, pDeviceSrvMsg->msg_body_len);
            break;

        case MSG_CANCEL:
            i = device_cancel_msg_proc(pDeviceSrvMsg->cr_pos, pDeviceSrvMsg->ua_dialog_index);
            break;

        case MSG_ACK:
            i = device_ack_msg_proc(pDeviceSrvMsg->cr_pos, pDeviceSrvMsg->ua_dialog_index);
            break;

        case  MSG_BYE:
            i = device_bye_msg_proc(pDeviceSrvMsg->cr_pos, pDeviceSrvMsg->ua_dialog_index);
            break;

        case  MSG_BYE_RESPONSE:
            i = device_bye_response_msg_proc(pDeviceSrvMsg->cr_pos, pDeviceSrvMsg->ua_dialog_index, pDeviceSrvMsg->response_code);
            break;

        case  MSG_INFO:
            i = device_info_msg_proc(pDeviceSrvMsg->caller_id, pDeviceSrvMsg->callee_id, pDeviceSrvMsg->ua_dialog_index, pDeviceSrvMsg->msg_body, pDeviceSrvMsg->msg_body_len);
            break;

        case MSG_MESSAGE:
            i = device_message_msg_proc(pDeviceSrvMsg->pGBDeviceInfo, pDeviceSrvMsg->caller_id, pDeviceSrvMsg->callee_id, pDeviceSrvMsg->ua_dialog_index, pDeviceSrvMsg->msg_body, pDeviceSrvMsg->msg_body_len, pDevice_Srv_dboper);
            break;

        case MSG_NOTIFY:
            i = device_notify_msg_proc(pDeviceSrvMsg->pGBDeviceInfo, pDeviceSrvMsg->caller_id, pDeviceSrvMsg->callee_id, pDeviceSrvMsg->msg_body, pDeviceSrvMsg->msg_body_len, pDevice_Srv_dboper);
            break;

        default:
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_srv_msg_proc() exit---: Not Support Message Type:%d \r\n", pDeviceSrvMsg->msg_type);
            return -1;
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_invite_msg_proc
 功能描述  : 前端设备发送过来的INVITE消息处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             int ua_dialog_index
             char* msg_body
             int msg_body_len
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年8月4日 星期一
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_invite_msg_proc(GBDevice_info_t* pGBDeviceInfo, char* caller_id, char* callee_id, int ua_dialog_index, char* msg_body, int msg_body_len)
{
    int i = 0;
    sdp_message_t* pClientSDP = NULL;
    sdp_param_t stClientSDPParam;
    sdp_extend_param_t stClientSDPExParam;
    GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo = NULL;
    char strErrorCode[32] = {0};

    if (NULL == pGBDeviceInfo)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLER_DEVICE_INFO_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"GBDevice Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_msg_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if ((NULL == caller_id) || (NULL == callee_id))
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_PARAM_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Param Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_msg_proc() exit---: Param Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end equipment real-time video request:front-end device ID=%s, IP=%s, port=%d, logic device ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);

    if (NULL == msg_body || msg_body_len == 0)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLER_MSG_BODY_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Get Message SDP Body Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_msg_proc() exit---: Get Message SDP Body Error \r\n");
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"获取请求方SDP消息体失败");
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Access SDP message body from the requester failed.");

        return -1;
    }

    /* 智能分析和智能诊断请求的码流，首先看一下是否原先有码流请求，如果有，那么先拆除原先的码流 */
    if (EV9000_DEVICETYPE_VIDEODIAGNOSIS == pGBDeviceInfo->device_type
        || EV9000_DEVICETYPE_INTELLIGENTANALYSIS == pGBDeviceInfo->device_type)
    {
        i = StopDiagnosisService(callee_id, pGBDeviceInfo->device_id);

        if (0 != i)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_invite_msg_proc() StopDiagnosisService Error:DeviceID=%s, CallerID=%s \r\n", callee_id, pGBDeviceInfo->device_id);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_invite_msg_proc() StopDiagnosisService OK:DeviceID=%s, CallerID=%s \r\n", callee_id, pGBDeviceInfo->device_id);
        }
    }

    /* 解码器请求的码流，首先看一下该通道是否原先有码流请求，如果有，那么先拆除原先的码流 */
    if (EV9000_DEVICETYPE_DECODER == pGBDeviceInfo->device_type)
    {
        i = StopDecServiceByDecInfo(pGBDeviceInfo->device_id, stClientSDPParam.sdp_ip, stClientSDPParam.video_port);

        if (0 != i)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_invite_msg_proc() StopDecServiceByDecInfo Error:DeviceID=%s, CallerID=%s \r\n", callee_id, pGBDeviceInfo->device_id);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_invite_msg_proc() StopDecServiceByDecInfo OK:DeviceID=%s, CallerID=%s \r\n", callee_id, pGBDeviceInfo->device_id);
        }
    }

    /* 1、查找逻辑设备信息 */
    pCalleeGBLogicDeviceInfo = GBLogicDevice_info_find(callee_id);

    if (NULL == pCalleeGBLogicDeviceInfo)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLEE_LOGIC_DEVICE_INFO_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Get Callee GBlogicDevice Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_msg_proc() exit---: Get Callee GBlogicDevice Info Error \r\n");
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"获取逻辑设备信息失败");
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Access logical device information failed");

        return -1;
    }

    /* 2、获取来源的客户端sdp信息，根据其中的s字段，判断业务类型 */
    i = sdp_message_init(&pClientSDP);

    if (0 != i)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_SDP_MSG_INIT_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"SDP Message Init Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_msg_proc() exit---: SDP Message Init Error \r\n");
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"SDP消息初始化失败");
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Access logical device information failed");

        return -1;
    }

    i = sdp_message_parse(pClientSDP, msg_body);

    if (0 != i)
    {
        sdp_message_free(pClientSDP);
        pClientSDP = NULL;

        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_SDP_MSG_PARSE_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"SDP Message Parse Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_msg_proc() exit---: SDP Message Parse Error \r\n");
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"SDP消息解析失败");
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"SDP message initialization failed");

        return -1;
    }

    /* 3、解析sdp中的信息*/
    memset(&stClientSDPParam, 0, sizeof(sdp_param_t));
    memset(&stClientSDPExParam, 0, sizeof(sdp_extend_param_t));

    i = SIP_GetSDPInfoEx(pClientSDP, &stClientSDPParam, &stClientSDPExParam);

    if (i != 0)
    {
        sdp_message_free(pClientSDP);
        pClientSDP = NULL;

        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_SDP_GET_VIDEO_INFO_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Get Client SDP Video Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_msg_proc() exit---: Get Client SDP Video Info Error \r\n");
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"获取SDP消息中的信息失败");
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"SDP message parsing failed");

        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 请求方携带的视频参数:audio_port=%d, audio_code_type=%d, video_port=%d, video_code_type=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, stClientSDPParam.audio_port, stClientSDPParam.audio_code_type, stClientSDPParam.video_port, stClientSDPParam.video_code_type);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Real-time video requests from the front-end device:front-end deviceID=%s, IP=%s, port=%d, logic device ID=%s,The requester to carry video parameters:audio_port=%d, audio_code_type=%d, video_port=%d, video_code_type=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, stClientSDPParam.audio_port, stClientSDPParam.audio_code_type, stClientSDPParam.video_port, stClientSDPParam.video_code_type);

    /* 判断请求类型，是视频请求还是音频请求 */
    if (stClientSDPParam.audio_port > 0
        && stClientSDPParam.video_port <= 0)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 用户请求的是音频对讲业务", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Real-time video requests from the front-end device:front-end deviceID=%s, IP=%s, port=%d, logic device ID=%s, User request is audio speaker business", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
        i = device_invite_audio_msg_proc(pGBDeviceInfo, pClientSDP, &stClientSDPParam, pCalleeGBLogicDeviceInfo, caller_id, callee_id, ua_dialog_index);

        if (i != 0)
        {
            sdp_message_free(pClientSDP);
            pClientSDP = NULL;
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_msg_proc() exit---: Audio Invite Proc Error \r\n");
            return -1;
        }
    }
    else
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 用户请求的是实时视频业务", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Real-time video requests from the front-end device:front-end deviceID=%s, IP=%s, port=%d, logic device ID=%s, User request is real-time video business", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);

        i = device_invite_video_msg_proc(pGBDeviceInfo, pClientSDP, &stClientSDPParam, pCalleeGBLogicDeviceInfo, caller_id, callee_id, ua_dialog_index);

        if (i != 0)
        {
            sdp_message_free(pClientSDP);
            pClientSDP = NULL;
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_msg_proc() exit---: Video Invite Proc Error \r\n");
            return -1;
        }
    }

    sdp_message_free(pClientSDP);
    pClientSDP = NULL;

    return i;
}

/*****************************************************************************
 函 数 名  : device_invite_video_msg_proc
 功能描述  : 前端设备发送过来的INVITE消息视频请求处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             sdp_message_t* pClientSDP
             sdp_param_t* pClientSDPParam
             GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo
             char* caller_id
             char* callee_id
             int ua_dialog_index
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年8月4日 星期一
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_invite_video_msg_proc(GBDevice_info_t* pGBDeviceInfo, sdp_message_t* pClientSDP, sdp_param_t* pClientSDPParam, GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo, char* caller_id, char* callee_id, int ua_dialog_index)
{
    int i = 0;
    char strErrorCode[32] = {0};

    if (NULL == pGBDeviceInfo)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLER_DEVICE_INFO_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"GBDevice Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_msg_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == pClientSDP)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLER_SDP_MSG_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Client SDP Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_msg_proc() exit---: Client SDP Info Error \r\n");
        return -1;
    }

    if (NULL == pClientSDPParam)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLER_SDP_PARAM_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Client SDP Param Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_msg_proc() exit---: Client SDP Param Info Error \r\n");
        return -1;
    }

    if (NULL == pCalleeGBLogicDeviceInfo)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLEE_LOGIC_DEVICE_INFO_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Callee GBLogic Device Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_msg_proc() exit---: Callee GBLogic Device Info Error \r\n");
        return -1;
    }

    /* 根据逻辑设备所属域进行判断，决定消息走向 */
    if (1 == pCalleeGBLogicDeviceInfo->other_realm)
    {
        i = device_invite_route_video_msg_proc(pGBDeviceInfo, pClientSDP, pClientSDPParam, pCalleeGBLogicDeviceInfo, caller_id, callee_id, ua_dialog_index);
    }
    else
    {
        i = device_invite_sub_video_msg_proc(pGBDeviceInfo, pClientSDP, pClientSDPParam, pCalleeGBLogicDeviceInfo, caller_id, callee_id, ua_dialog_index);
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_invite_sub_video_msg_proc
 功能描述  : 前端设备发送过来的INVITE消息视频请求处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             sdp_message_t* pClientSDP
             sdp_param_t* pClientSDPParam
             GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo
             char* caller_id
             char* callee_id
             int ua_dialog_index
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年8月4日 星期一
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_invite_sub_video_msg_proc(GBDevice_info_t* pGBDeviceInfo, sdp_message_t* pClientSDP, sdp_param_t* pClientSDPParam, GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo, char* caller_id, char* callee_id, int ua_dialog_index)
{
    int i = 0;
    int cr_pos = -1;
    cr_t* pCrData = NULL;
    int record_info_pos = -1;
    record_info_t* pRecordInfo = NULL;

    GBDevice_info_t* pCalleeGBDeviceInfo = NULL;
    GBDevice_info_t* pCalleeCmsGBDeviceInfo = NULL;

    char* sdp_url = NULL;
    char* sdp_ssrc = NULL;
    char* o_name = NULL;
    char* o_sess_id = NULL;
    char* o_sess_version = NULL;
    char* time_r_repeat = NULL;
    //char strSDPUrl[128] = {0};
    call_type_t eCallType = CALL_TYPE_NULL;
    int stream_type = 0;
    int record_type = 0;
    transfer_protocol_type_t trans_type = TRANSFER_PROTOCOL_NULL;

    char strStartTime[64] = {0};
    char strEndTime[64] = {0};
    char strPlayBackURL[64] = {0};
    int iPlaybackTimeGap = 0;
    char strErrorCode[32] = {0};
    int record_cr_index = -1;

    if (NULL == pGBDeviceInfo)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLER_DEVICE_INFO_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"GBDevice Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_sub_video_msg_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == pClientSDP)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLER_SDP_MSG_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Client SDP Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_sub_video_msg_proc() exit---: Client SDP Info Error \r\n");
        return -1;
    }

    if (NULL == pClientSDPParam)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLER_SDP_PARAM_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Client SDP Param Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_sub_video_msg_proc() exit---: Client SDP Param Info Error \r\n");
        return -1;
    }

    if (NULL == pCalleeGBLogicDeviceInfo)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLEE_LOGIC_DEVICE_INFO_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Callee GBLogic Device Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_sub_video_msg_proc() exit---: Callee GBLogic Device Info Error \r\n");
        return -1;
    }

    /* 1、获取流类型，查找对应的物理设备 */
    if (pClientSDPParam->stream_type <= 0)
    {
        stream_type = EV9000_STREAM_TYPE_MASTER;
    }
    else
    {
        stream_type = pClientSDPParam->stream_type;
    }

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_sub_video_msg_proc() Stream Type=%d \r\n", stream_type);

    if (stream_type == EV9000_STREAM_TYPE_SLAVE && pCalleeGBLogicDeviceInfo->stream_count == 1)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLEE_NOT_SUPPORT_MULTI_STREAM_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Callee GBDevice Not Support Multi stream");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_sub_video_msg_proc() exit---: Callee GBDevice Not Support Multi stream \r\n");
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s ", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"逻辑设备信息不支持多码流");
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s ", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Logic device information does not support multi stream");

        return -1;
    }

    /* 3、获取传输类型 */
    if (pClientSDPParam->trans_type <= 0)
    {
        trans_type = TRANSFER_PROTOCOL_UDP;
    }
    else if (pClientSDPParam->trans_type == 2)
    {
        trans_type = TRANSFER_PROTOCOL_TCP;
    }
    else
    {
        trans_type = TRANSFER_PROTOCOL_UDP;
    }

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_sub_video_msg_proc() Transfer Protocol Type=%d \r\n", trans_type);

    /* 查找目的物理设备信息 */
    pCalleeGBDeviceInfo = GBDevice_info_get_by_stream_type(pCalleeGBLogicDeviceInfo, stream_type);

    if (NULL == pCalleeGBDeviceInfo)
    {
        /* 如果是智能分析流，可能是下级平台的点位，这个时候需要再查找一下主流设备 */
        if (EV9000_STREAM_TYPE_INTELLIGENCE == stream_type)
        {
            pCalleeCmsGBDeviceInfo = GBDevice_info_get_by_stream_type(pCalleeGBLogicDeviceInfo, EV9000_STREAM_TYPE_MASTER);

            if (NULL != pCalleeCmsGBDeviceInfo
                && EV9000_DEVICETYPE_SIPSERVER == pCalleeCmsGBDeviceInfo->device_type)
            {
                pCalleeGBDeviceInfo = pCalleeCmsGBDeviceInfo;
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_sub_video_msg_proc() CalleeCmsGBDevice: id=%s, ip=%s \r\n", pCalleeCmsGBDeviceInfo->device_id, pCalleeCmsGBDeviceInfo->login_ip);
            }
        }
        else if (EV9000_STREAM_TYPE_SLAVE == stream_type) /* 如果是辅流，再找一下主流设备 */
        {
            pCalleeGBDeviceInfo = GBDevice_info_get_by_stream_type(pCalleeGBLogicDeviceInfo, EV9000_STREAM_TYPE_MASTER);
        }
    }

    if (NULL == pCalleeGBDeviceInfo)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLEE_DEVICE_INFO_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Get Callee GBDevice Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_sub_video_msg_proc() exit---: Get Callee GBDevice Info Error \r\n");
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, 媒体流类型=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"获取逻辑设备对应的物理设备信息失败", stream_type);
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s, media stream type=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Physical device obtain the corresponding logical device information failed", stream_type);

        return -1;
    }

    /* 如果是第三方平台，去掉扩展的SDP信息 */
    if (EV9000_DEVICETYPE_SIPSERVER == pCalleeGBDeviceInfo->device_type
        && 1 == pCalleeGBDeviceInfo->three_party_flag)
    {
        DelSDPMediaAttributeByName(pClientSDP, (char*)"recordtype");
        DelSDPMediaAttributeByName(pClientSDP, (char*)"streamtype");

        /* 修改名称 */
        o_name = sdp_message_o_username_get(pClientSDP);

        if (NULL != o_name && 0 != sstrcmp(o_name, local_cms_id_get()))
        {
            osip_free(o_name);
            o_name = NULL;

            o_name = osip_getcopy(local_cms_id_get());
            sdp_message_o_username_set(pClientSDP, o_name);
        }
        else if (NULL == o_name)
        {
            o_name = osip_getcopy(local_cms_id_get());
            sdp_message_o_username_set(pClientSDP, o_name);
        }

        o_sess_id = sdp_message_o_sess_id_get(pClientSDP);

        if (NULL != o_sess_id && 0 != sstrcmp(o_sess_id, (char*)"0"))
        {
            osip_free(o_sess_id);
            o_sess_id = NULL;

            o_sess_id = osip_getcopy((char*)"0");
            sdp_message_o_sess_id_set(pClientSDP, o_sess_id);
        }
        else if (NULL == o_sess_id)
        {
            o_sess_id = osip_getcopy(local_cms_id_get());
            sdp_message_o_sess_id_set(pClientSDP, o_sess_id);
        }

        o_sess_version = sdp_message_o_sess_version_get(pClientSDP);

        if (NULL != o_sess_version && 0 != sstrcmp(o_sess_version, (char*)"0"))
        {
            osip_free(o_sess_version);
            o_sess_version = NULL;

            o_sess_version = osip_getcopy((char*)"0");
            sdp_message_o_sess_version_set(pClientSDP, o_sess_version);
        }
        else if (NULL == o_sess_version)
        {
            o_sess_version = osip_getcopy(local_cms_id_get());
            sdp_message_o_sess_version_set(pClientSDP, o_sess_version);
        }

        time_r_repeat = sdp_message_r_repeat_get(pClientSDP, 0, 0);

        if (NULL != time_r_repeat)
        {
            DelSDPTimeRepeatInfo(pClientSDP);
        }
    }

    if (0 == strncmp(pClientSDPParam->s_name, (char*)"Playback", 8))
    {
        eCallType = CALL_TYPE_RECORD_PLAY;

        sdp_url = sdp_message_u_uri_get(pClientSDP);

        if (NULL == sdp_url)
        {
            snprintf(strPlayBackURL, 64, "%s:%s", callee_id, (char*)"application");
            sdp_url = osip_getcopy(strPlayBackURL);
            sdp_message_u_uri_set(pClientSDP, sdp_url);
        }
        else
        {
            osip_free(sdp_url);
            sdp_url = NULL;

            snprintf(strPlayBackURL, 64, "%s:%s", callee_id, (char*)"application");
            sdp_url = osip_getcopy(strPlayBackURL);
            sdp_message_u_uri_set(pClientSDP, sdp_url);
        }

#if 1
        sdp_ssrc = sdp_message_y_ssrc_get(pClientSDP);

        if (NULL == sdp_ssrc)
        {
            sdp_ssrc = osip_getcopy((char*)"1100000001");
            sdp_message_y_ssrc_set(pClientSDP, sdp_ssrc);
        }

#endif

        /* 确定录像类型 */
        if (pClientSDPParam->record_type <= 0)
        {
            record_type = EV9000_RECORD_TYPE_NORMAL;
        }
        else
        {
            record_type = pClientSDPParam->record_type;
        }

        i = format_time(pClientSDPParam->start_time, strStartTime);
        i = format_time(pClientSDPParam->end_time, strEndTime);

#if 0

        /* 如果是前端的NVR或者DVR录像，则修改播放时间 */
        if (EV9000_DEVICETYPE_DVR == pCalleeGBDeviceInfo->device_type || EV9000_DEVICETYPE_NVR == pCalleeGBDeviceInfo->device_type)
        {
            if (1 == pCalleeGBLogicDeviceInfo->record_type)
            {
                i = ModifySDPRecordPlayTime(pClientSDP);
                iPlaybackTimeGap = pClientSDPParam->play_time - pClientSDPParam->start_time;
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_sub_video_msg_proc() PlaybackTimeGap=%d \r\n", iPlaybackTimeGap);
            }
        }
        else if (EV9000_DEVICETYPE_SIPSERVER == pCalleeGBDeviceInfo->device_type && 1 == pCalleeGBDeviceInfo->three_party_flag) /* 第三方平台 */
        {
            i = ModifySDPRecordPlayTime(pClientSDP);
            iPlaybackTimeGap = pClientSDPParam->play_time - pClientSDPParam->start_time;
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_sub_video_msg_proc() PlaybackTimeGap=%d \r\n", iPlaybackTimeGap);
        }

#endif
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的历史视频回放请求:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 录像类型=%d, 媒体流类型=%d, 传输方式=%d, 回放开始时间=%s, 结束时间=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, record_type, stream_type, trans_type, strStartTime, strEndTime);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Historical video playback request from the front-end device:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, media stream type=%d, transmission method=%d, playback start time=%s, end time=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, stream_type, trans_type, strStartTime, strEndTime);
    }
    else if (0 == strncmp(pClientSDPParam->s_name, (char*)"Play", 4))
    {
        eCallType = CALL_TYPE_REALTIME;

#if 1
        sdp_ssrc = sdp_message_y_ssrc_get(pClientSDP);

        if (NULL == sdp_ssrc)
        {
            sdp_ssrc = osip_getcopy((char*)"0100000001");
            sdp_message_y_ssrc_set(pClientSDP, sdp_ssrc);
        }

#endif

        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, 前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 媒体流类型=%d, 传输方式=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, stream_type, trans_type);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Real-time monitoring request from the front-end device:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, media stream type=%d, transmission method=%d, playback start time=%s, end time=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, stream_type, trans_type, strStartTime, strEndTime);
    }
    else if (0 == strncmp(pClientSDPParam->s_name, (char*)"Download", 8))
    {
        eCallType = CALL_TYPE_DOWNLOAD;

        sdp_url = sdp_message_u_uri_get(pClientSDP);

        if (NULL == sdp_url)
        {
            snprintf(strPlayBackURL, 64, "%s:%s", callee_id, (char*)"application");
            sdp_url = osip_getcopy(strPlayBackURL);
            sdp_message_u_uri_set(pClientSDP, sdp_url);
        }
        else
        {
            osip_free(sdp_url);
            sdp_url = NULL;

            snprintf(strPlayBackURL, 64, "%s:%s", callee_id, (char*)"application");
            sdp_url = osip_getcopy(strPlayBackURL);
            sdp_message_u_uri_set(pClientSDP, sdp_url);
        }

#if 1
        sdp_ssrc = sdp_message_y_ssrc_get(pClientSDP);

        if (NULL == sdp_ssrc)
        {
            sdp_ssrc = osip_getcopy((char*)"1100000001");
            sdp_message_y_ssrc_set(pClientSDP, sdp_ssrc);
        }

#endif

        /* 确定录像类型 */
        if (pClientSDPParam->record_type <= 0)
        {
            record_type = EV9000_RECORD_TYPE_NORMAL;
        }
        else
        {
            record_type = pClientSDPParam->record_type;
        }

        i = format_time(pClientSDPParam->start_time, strStartTime);
        i = format_time(pClientSDPParam->end_time, strEndTime);

#if 0

        /* 如果是前端的NVR或者DVR录像，则修改播放时间 */
        if (EV9000_DEVICETYPE_DVR == pCalleeGBDeviceInfo->device_type || EV9000_DEVICETYPE_NVR == pCalleeGBDeviceInfo->device_type)
        {
            if (1 == pCalleeGBLogicDeviceInfo->record_type)
            {
                i = ModifySDPRecordPlayTime(pClientSDP);
                iPlaybackTimeGap = pClientSDPParam->play_time - pClientSDPParam->start_time;
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_sub_video_msg_proc() PlaybackTimeGap=%d \r\n", iPlaybackTimeGap);
            }
        }
        else if (EV9000_DEVICETYPE_SIPSERVER == pCalleeGBDeviceInfo->device_type && 1 == pCalleeGBDeviceInfo->three_party_flag) /* 第三方平台 */
        {
            i = ModifySDPRecordPlayTime(pClientSDP);
            iPlaybackTimeGap = pClientSDPParam->play_time - pClientSDPParam->start_time;
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_sub_video_msg_proc() PlaybackTimeGap=%d \r\n", iPlaybackTimeGap);
        }

#endif
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的历史视频文件下载请求:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 录像类型=%d, 媒体流类型=%d, 传输方式=%d, 回放开始时间=%s, 结束时间=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, record_type, stream_type, trans_type, strStartTime, strEndTime);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Historical video file download request from the front-end device:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, media stream type=%d, transmission method=%d, playback start time=%s, end time=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, stream_type, trans_type, strStartTime, strEndTime);
    }
    else
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_SDP_NOT_SUPPORT_S_TYPE_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 488, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 488, (char*)"SDP S Type Not Support");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_sub_video_msg_proc() exit---: SDP S Type Not Support \r\n");
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, S名称=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"不支持的S名称类型", pClientSDPParam->s_name);
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s, S name =%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Do not support S name type.", pClientSDPParam->s_name);
        return -1;
    }

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_sub_video_msg_proc() Call Type=%d \r\n", eCallType);

    /* 实时视频查看需要判断设备在线状态 */
    if (eCallType == CALL_TYPE_REALTIME)
    {
        /* 看物理设备是否在线 */
        if (0 == pCalleeGBDeviceInfo->reg_status)
        {
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_DEVICE_OFFLINE_ERROR);
            SIP_AnswerToInvite(ua_dialog_index, 480, strErrorCode);
            //SIP_AnswerToInvite(ua_dialog_index, 480, NULL);

            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_sub_video_msg_proc() exit---: Device Not Online:device_id=%s \r\n", pCalleeGBDeviceInfo->device_id);

            if (EV9000_DEVICETYPE_VIDEODIAGNOSIS == pGBDeviceInfo->device_type
                || EV9000_DEVICETYPE_INTELLIGENTANALYSIS == pGBDeviceInfo->device_type)
            {
                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, 物理设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"前端物理设备不在线", pCalleeGBDeviceInfo->device_id);
                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_NORMAL, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s, physical device ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Front end physical device is not online.", pCalleeGBDeviceInfo->device_id);
            }
            else
            {
                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, 物理设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"前端物理设备不在线", pCalleeGBDeviceInfo->device_id);
                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s, physical device ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Front end physical device is not online.", pCalleeGBDeviceInfo->device_id);
            }

            return -1;
        }

        /* 看逻辑设备点位状态, 如果是下级CMS的点，则不需要判断 */
        if (EV9000_DEVICETYPE_SIPSERVER != pCalleeGBDeviceInfo->device_type && 0 == pCalleeGBLogicDeviceInfo->status)
        {
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_DEVICE_LOGIC_DEVICE_OFFLINE_ERROR);
            SIP_AnswerToInvite(ua_dialog_index, 480, strErrorCode);
            //SIP_AnswerToInvite(ua_dialog_index, 480, NULL);

            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_sub_video_msg_proc() exit---: GBLogic Device Not Online \r\n");

            if (EV9000_DEVICETYPE_VIDEODIAGNOSIS == pGBDeviceInfo->device_type
                || EV9000_DEVICETYPE_INTELLIGENTANALYSIS == pGBDeviceInfo->device_type)
            {
                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"前端逻辑设备不在线");
                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_NORMAL, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Front end logic device is not online.");
            }
            else
            {
                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"前端逻辑设备不在线");
                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Front end logic device is not online.");
            }

            return -1;
        }

#if 0

        if (2 == pCalleeGBLogicDeviceInfo->status)
        {
            SIP_AnswerToInvite(ua_dialog_index, 480, NULL);
            DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_invite_sub_video_msg_proc() exit---: GBLogic Device No Stream \r\n");
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"前端逻辑设备没有码流");
            return -1;
        }

#endif

        if (3 == pCalleeGBLogicDeviceInfo->status)
        {
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_DEVICE_LOGIC_DEVICE_UNREACHED_ERROR);
            SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
            //SIP_AnswerToInvite(ua_dialog_index, 480, NULL);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_sub_video_msg_proc() exit---: GBLogic Device NetWork UnReached \r\n");

            if (EV9000_DEVICETYPE_VIDEODIAGNOSIS == pGBDeviceInfo->device_type
                || EV9000_DEVICETYPE_INTELLIGENTANALYSIS == pGBDeviceInfo->device_type)
            {
                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"前端逻辑设备网络不可达");
                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_NORMAL, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Network of front-end logic device is not accessable.");
            }
            else
            {
                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"前端逻辑设备网络不可达");
                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Network of front-end logic device is not accessable.");
            }

            return -1;
        }
    }

    /* 3、申请呼叫资源 */
    cr_pos = call_record_add();
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_sub_video_msg_proc() call_record_add:cr_pos=%d \r\n", cr_pos);

    pCrData = call_record_get(cr_pos);

    if (NULL == pCrData)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_GET_IDLE_CR_DATA_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Get Call Record Data Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_sub_video_msg_proc() exit---: Get Call Record Data Error \r\n");
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"申请呼叫资源失败");
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Apply to call resource failed");

        return -1;
    }

    pCrData->call_type = eCallType;

    /* 4、添加 主被叫信息到呼叫资源信息 */
    /* 主叫端信息 */
    osip_strncpy(pCrData->caller_id, caller_id, MAX_ID_LEN);
    osip_strncpy(pCrData->caller_ip, pGBDeviceInfo->login_ip, MAX_IP_LEN);
    pCrData->caller_port = pGBDeviceInfo->login_port;
    pCrData->caller_ua_index = ua_dialog_index;
    osip_strncpy(pCrData->caller_server_ip_ethname, pGBDeviceInfo->strRegServerEthName, MAX_IP_LEN);
    osip_strncpy(pCrData->caller_server_ip, pGBDeviceInfo->strRegServerIP, MAX_IP_LEN);
    pCrData->caller_server_port = pGBDeviceInfo->iRegServerPort;
    pCrData->caller_transfer_type = trans_type;
    pCrData->iPlaybackTimeGap = iPlaybackTimeGap;

    /* 主叫端的SDP信息 */
    osip_strncpy(pCrData->caller_sdp_ip, pClientSDPParam->sdp_ip, MAX_IP_LEN);
    pCrData->caller_sdp_port = pClientSDPParam->video_port;

#if 0
    printf("\r\n\r\n ************************************************* \r\n");
    printf(" device_invite_sub_video_msg_proc() pCrData->caller_id=%s \r\n", pCrData->caller_id);
    printf(" device_invite_sub_video_msg_proc() pCrData->caller_ip=%s \r\n", pCrData->caller_ip);
    printf(" device_invite_sub_video_msg_proc() pCrData->caller_port=%d \r\n", pCrData->caller_port);
    printf(" device_invite_sub_video_msg_proc() pCrData->caller_sdp_ip=%s \r\n", pCrData->caller_sdp_ip);
    printf(" device_invite_sub_video_msg_proc() pCrData->caller_sdp_port=%d \r\n", pCrData->caller_sdp_port);
    printf(" device_invite_sub_video_msg_proc() pCrData->caller_ua_index=%d \r\n", pCrData->caller_ua_index);
    printf(" ************************************************* \r\n\r\n ");
#endif

    /* 被叫端信息 */
    osip_strncpy(pCrData->callee_id, callee_id, MAX_ID_LEN);
    osip_strncpy(pCrData->callee_ip, pCalleeGBDeviceInfo->login_ip, MAX_IP_LEN);
    pCrData->callee_port = pCalleeGBDeviceInfo->login_port;
    osip_strncpy(pCrData->callee_server_ip_ethname, pCalleeGBDeviceInfo->strRegServerEthName, MAX_IP_LEN);
    osip_strncpy(pCrData->callee_server_ip, pCalleeGBDeviceInfo->strRegServerIP, MAX_IP_LEN);
    pCrData->callee_server_port = pCalleeGBDeviceInfo->iRegServerPort;
    pCrData->callee_framerate = pCalleeGBLogicDeviceInfo->frame_count;
    pCrData->callee_stream_type = stream_type;
    pCrData->callee_gb_device_type = pCalleeGBDeviceInfo->device_type;

    if (1 == pCalleeGBDeviceInfo->trans_protocol)
    {
        pCrData->callee_transfer_type = TRANSFER_PROTOCOL_TCP;
    }
    else
    {
        pCrData->callee_transfer_type = TRANSFER_PROTOCOL_UDP; /* 默认UDP */
    }

#if 0
    printf("\r\n\r\n ************************************************* \r\n");
    printf(" device_invite_sub_video_msg_proc() pCrData->callee_id=%s \r\n", pCrData->callee_id);
    printf(" device_invite_sub_video_msg_proc() pCrData->callee_ip=%s \r\n", pCrData->callee_ip);
    printf(" device_invite_sub_video_msg_proc() pCrData->callee_port=%d \r\n", pCrData->callee_port);
    printf(" ************************************************* \r\n\r\n ");
#endif

    /* 如果是录像回放或者下载, 判断录像是在前端还是在本地,如果录在本地，则不需要转到前端处理 */
    if (eCallType == CALL_TYPE_RECORD_PLAY || eCallType == CALL_TYPE_DOWNLOAD)
    {
        /* 查看该点位是否配置了录像 */
        if (EV9000_RECORD_TYPE_NORMAL == record_type
            || EV9000_RECORD_TYPE_ALARM == record_type)
        {
            record_info_pos = record_info_find_by_stream_type(pCalleeGBLogicDeviceInfo->id, EV9000_STREAM_TYPE_MASTER);
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_sub_video_msg_proc() record_info_find_by_stream_type:device_id=%s, stream_type=%d, record_info_pos=%d \r\n", pCalleeGBLogicDeviceInfo->device_id, EV9000_STREAM_TYPE_MASTER, record_info_pos);
        }
        else if (EV9000_RECORD_TYPE_BACKUP == record_type)
        {
            record_info_pos = record_info_find_by_stream_type(pCalleeGBLogicDeviceInfo->id, EV9000_STREAM_TYPE_SLAVE);
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_sub_video_msg_proc() record_info_find_by_stream_type:device_id=%s, stream_type=%d, record_info_pos=%d \r\n", pCalleeGBLogicDeviceInfo->device_id, EV9000_STREAM_TYPE_SLAVE, record_info_pos);
        }
        else if (EV9000_RECORD_TYPE_INTELLIGENCE == record_type)
        {
            record_info_pos = record_info_find_by_stream_type(pCalleeGBLogicDeviceInfo->id, EV9000_STREAM_TYPE_INTELLIGENCE);
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_sub_video_msg_proc() record_info_find_by_stream_type:device_id=%s, stream_type=%d, record_info_pos=%d \r\n", pCalleeGBLogicDeviceInfo->device_id, EV9000_STREAM_TYPE_INTELLIGENCE, record_info_pos);
        }
        else
        {
            record_info_pos = record_info_find_by_stream_type(pCalleeGBLogicDeviceInfo->id, EV9000_STREAM_TYPE_MASTER);
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_sub_video_msg_proc() record_info_find_by_stream_type:device_id=%s, stream_type=%d, record_info_pos=%d \r\n", pCalleeGBLogicDeviceInfo->device_id, EV9000_STREAM_TYPE_MASTER, record_info_pos);
        }

        if (record_info_pos >= 0)
        {
            pRecordInfo = record_info_get(record_info_pos);

            if (NULL != pRecordInfo)
            {
                if (1 == pRecordInfo->record_enable)
                {
                    i = user_video_sevice_current_cms_proc(pCrData, pClientSDP, eCallType, pClientSDPParam->start_time, pClientSDPParam->end_time, pClientSDPParam->play_time, 0, record_type);

                    if (0 != i)
                    {
                        memset(strErrorCode, 0, 32);
                        snprintf(strErrorCode, 32, "%d", i);
                        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
                        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Current CMS Proc Error");
                        i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
                        i = call_record_remove(cr_pos);

                        if (0 != i)
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_sub_video_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
                        }
                        else
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_sub_video_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
                        }
                    }

                    return i;
                }
            }
        }
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_sub_video_msg_proc() CalleeGBLogicDeviceInfo Record Type=%d, Status=%d \r\n", pCalleeGBLogicDeviceInfo->record_type, pCalleeGBLogicDeviceInfo->status);

        if (0 == pCalleeGBLogicDeviceInfo->record_type && 2 != pCalleeGBLogicDeviceInfo->status)/* 本地录像并且不是前端没有码流的状态情况下检查录像信息，因为前端没有码流情况下不影响实时视频流程 */
        {
            /* 检查该点位是否录像了 */
            record_info_pos = record_info_find_by_stream_type(pCalleeGBLogicDeviceInfo->id, stream_type);
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_sub_video_msg_proc() record_info_find_by_stream_type:device_id=%s, stream_type=%d, record_info_pos=%d \r\n", pCalleeGBLogicDeviceInfo->device_id, stream_type, record_info_pos);

            if (record_info_pos >= 0)
            {
                pRecordInfo = record_info_get(record_info_pos);

                if (NULL != pRecordInfo)
                {
                    if (1 == pRecordInfo->record_enable)
                    {
                        if (pRecordInfo->record_cr_index < 0 && pRecordInfo->record_status != RECORD_STATUS_NO_TSU)
                        {
                            record_cr_index = StartDeviceRecord(pRecordInfo);

                            if (record_cr_index >= 0)
                            {
                                pRecordInfo->record_retry_interval = 5;
                                pRecordInfo->record_try_count = 0;
                                pRecordInfo->iTSUPauseStatus = 0;
                                pRecordInfo->iTSUResumeStatus = 0;
                                pRecordInfo->iTSUAlarmRecordStatus = 0;

                                i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_ANSWER);
                                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_WARNING, "前端设备过来的实时视频请求:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 等待逻辑设备录像业务流程结束", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
                                return 0;
                            }
                            else
                            {
                                pRecordInfo->tsu_index = -1;
                                pRecordInfo->iTSUPauseStatus = 0;
                                pRecordInfo->iTSUResumeStatus = 0;
                                pRecordInfo->iTSUAlarmRecordStatus = 0;

                                if (-2 == record_cr_index)
                                {
                                    pRecordInfo->record_status = RECORD_STATUS_OFFLINE;
                                }
                                else if (-3 == record_cr_index)
                                {
                                    pRecordInfo->record_status = RECORD_STATUS_NOSTREAM;
                                }
                                else if (-5 == record_cr_index)
                                {
                                    pRecordInfo->record_status = RECORD_STATUS_NETWORK_ERROR;
                                }
                                else if (-4 == record_cr_index)
                                {
                                    pRecordInfo->record_status = RECORD_STATUS_NO_TSU;
                                }
                                else if (-6 == record_cr_index)
                                {
                                    pRecordInfo->record_status = RECORD_STATUS_NOT_SUPPORT_MULTI_STREAM;
                                }
                                else
                                {
                                    pRecordInfo->record_status = RECORD_STATUS_INIT;
                                }

                                pRecordInfo->record_start_time = 0;

                                pRecordInfo->record_try_count++;

                                if (pRecordInfo->record_try_count >= 3)
                                {
                                    pRecordInfo->record_try_count = 0;
                                    pRecordInfo->record_retry_interval = 5;
                                }

                                memset(strErrorCode, 0, 32);
                                snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLEE_RECORD_NOT_START_ERROR);
                                SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);

                                i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
                                i = call_record_remove(cr_pos);

                                if (0 != i)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_sub_video_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_sub_video_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
                                }

                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_sub_video_msg_proc() exit---: Callee GBDevice Not Start Record \r\n");
                                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"逻辑设备配置了录像，但是启动录像失败了");
                                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"The logic device is configured for video, but it has not been started.");

                                return -1;
                            }
                        }
                        else if (pRecordInfo->record_cr_index >= 0 && pRecordInfo->record_status != RECORD_STATUS_COMPLETE)
                        {
                            i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_ANSWER);
                            SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_WARNING, "前端设备过来的实时视频请求:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 等待逻辑设备录像业务流程结束", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
                            return 0;
                        }
                    }
                }
            }
        }
    }

    /* 5、根据设备类型作不同的处理 */
    if (pCalleeGBDeviceInfo->device_type == EV9000_DEVICETYPE_SIPSERVER)
    {
        i = user_video_sevice_sub_cms_proc(pCrData, pClientSDP, eCallType);

        if (EV9000_CMS_ERR_INVITE_CALLEE_RECORD_NOT_COMPLETE_ERROR == i)
        {
            i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_ANSWER);
            SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_WARNING, "前端设备过来的实时视频请求:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 等待逻辑设备录像业务流程结束", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
            return 0;
        }
        else if (EV9000_CMS_ERR_INVITE_CALLEE_VIDEO_NOT_COMPLETE_ERROR == i)
        {
            i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_ANSWER);
            SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_WARNING, "前端设备过来的实时视频请求:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 等待逻辑设备视频业务流程结束", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
            return 0;
        }
        else if (0 != i)
        {
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", i);
            SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
            //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Sub CMS Proc rror");
            i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
            i = call_record_remove(cr_pos);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_sub_video_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_sub_video_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
            }
        }
    }
    else
    {
        i = user_video_sevice_current_cms_proc(pCrData, pClientSDP, eCallType, pClientSDPParam->start_time, pClientSDPParam->end_time, pClientSDPParam->play_time, pCalleeGBLogicDeviceInfo->record_type, record_type);

        if (EV9000_CMS_ERR_INVITE_CALLEE_RECORD_NOT_COMPLETE_ERROR == i)
        {
            i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_ANSWER);
            SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_WARNING, "前端设备过来的实时视频请求:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 等待逻辑设备录像业务流程结束", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
            return 0;
        }
        else if (EV9000_CMS_ERR_INVITE_CALLEE_VIDEO_NOT_COMPLETE_ERROR == i)
        {
            i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_ANSWER);
            SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_WARNING, "前端设备过来的实时视频请求:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 等待逻辑设备视频业务流程结束", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
            return 0;
        }
        else if (0 != i)
        {
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", i);
            SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
            //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Current CMS Proc rror");
            i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
            i = call_record_remove(cr_pos);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_sub_video_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_sub_video_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
            }
        }
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_invite_route_video_msg_proc
 功能描述  : 前端设备发送过来的INVITE消息视频请求处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             sdp_message_t* pClientSDP
             sdp_param_t* pClientSDPParam
             GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo
             char* caller_id
             char* callee_id
             int ua_dialog_index
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年8月4日 星期一
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_invite_route_video_msg_proc(GBDevice_info_t* pGBDeviceInfo, sdp_message_t* pClientSDP, sdp_param_t* pClientSDPParam, GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo, char* caller_id, char* callee_id, int ua_dialog_index)
{
    int i = 0;
    int cr_pos = -1;
    cr_t* pCrData = NULL;
    int iCalleeRoutePos = 0;
    route_info_t* pCalleeRouteInfo = NULL;

    char* sdp_url = NULL;
    char* sdp_ssrc = NULL;
    char* o_name = NULL;
    char* o_sess_id = NULL;
    char* o_sess_version = NULL;
    char* time_r_repeat = NULL;
    call_type_t eCallType = CALL_TYPE_NULL;
    int stream_type = 0;
    int record_type = 0;
    transfer_protocol_type_t trans_type = TRANSFER_PROTOCOL_NULL;

    char strStartTime[64] = {0};
    char strEndTime[64] = {0};
    char strPlayBackURL[64] = {0};
    int iPlaybackTimeGap = 0;
    char strErrorCode[32] = {0};

    if (NULL == pGBDeviceInfo)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLER_DEVICE_INFO_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"GBDevice Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == pClientSDP)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLER_SDP_MSG_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Client SDP Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: Client SDP Info Error \r\n");
        return -1;
    }

    if (NULL == pClientSDPParam)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLER_SDP_PARAM_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Client SDP Param Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: Client SDP Param Info Error \r\n");
        return -1;
    }

    if (NULL == pCalleeGBLogicDeviceInfo)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLEE_LOGIC_DEVICE_INFO_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Callee GBLogic Device Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: Callee GBLogic Device Info Error \r\n");
        return -1;
    }

    /* 1、获取流类型，查找对应的物理设备 */
    if (pClientSDPParam->stream_type <= 0)
    {
        stream_type = EV9000_STREAM_TYPE_MASTER;
    }
    else
    {
        stream_type = pClientSDPParam->stream_type;
    }

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_route_video_msg_proc() Stream Type=%d \r\n", stream_type);

    if (stream_type == EV9000_STREAM_TYPE_SLAVE && pCalleeGBLogicDeviceInfo->stream_count == 1)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLEE_NOT_SUPPORT_MULTI_STREAM_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Callee GBDevice Not Support Multi stream");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: Callee GBDevice Not Support Multi stream \r\n");
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s ", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"逻辑设备信息不支持多码流");
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s ", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Logic device information does not support multi stream");

        return -1;
    }

    /* 2、获取传输类型 */
    if (pClientSDPParam->trans_type <= 0)
    {
        trans_type = TRANSFER_PROTOCOL_UDP;
    }
    else if (pClientSDPParam->trans_type == 2)
    {
        trans_type = TRANSFER_PROTOCOL_TCP;
    }
    else
    {
        trans_type = TRANSFER_PROTOCOL_UDP;
    }

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_route_video_msg_proc() Transfer Protocol Type=%d \r\n", trans_type);

    /* 查找目的上级路由信息 */
    iCalleeRoutePos = route_info_find(pCalleeGBLogicDeviceInfo->cms_id);

    if (iCalleeRoutePos < 0)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLEE_ROUTE_INFO_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Find Callee Route Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: Find Callee Route Info Error \r\n");
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, 媒体流类型=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"查找逻辑设备对应的上级路由信息失败", stream_type);
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, reason=%s, Media stream type=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Find the route information which corresponding to logical device failed.", stream_type);
        return -1;
    }

    pCalleeRouteInfo = route_info_get(iCalleeRoutePos);

    if (NULL == pCalleeRouteInfo)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLEE_ROUTE_INFO_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Get Callee Route Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: Get Callee Route Info Error \r\n");
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, 媒体流类型=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"获取逻辑设备对应的上级路由信息失败", stream_type);
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, reason=%s, Media stream type=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Get the route information which corresponding to logical device failed.", stream_type);
        return -1;
    }

    /* 如果是第三方平台，去掉扩展的SDP信息 */
    if (1 == pCalleeRouteInfo->three_party_flag)
    {
        DelSDPMediaAttributeByName(pClientSDP, (char*)"recordtype");
        DelSDPMediaAttributeByName(pClientSDP, (char*)"streamtype");

        /* 修改名称 */
        o_name = sdp_message_o_username_get(pClientSDP);

        if (NULL != o_name && 0 != sstrcmp(o_name, local_cms_id_get()))
        {
            osip_free(o_name);
            o_name = NULL;

            o_name = osip_getcopy(local_cms_id_get());
            sdp_message_o_username_set(pClientSDP, o_name);
        }
        else if (NULL == o_name)
        {
            o_name = osip_getcopy(local_cms_id_get());
            sdp_message_o_username_set(pClientSDP, o_name);
        }

        o_sess_id = sdp_message_o_sess_id_get(pClientSDP);

        if (NULL != o_sess_id && 0 != sstrcmp(o_sess_id, (char*)"0"))
        {
            osip_free(o_sess_id);
            o_sess_id = NULL;

            o_sess_id = osip_getcopy((char*)"0");
            sdp_message_o_sess_id_set(pClientSDP, o_sess_id);
        }
        else if (NULL == o_sess_id)
        {
            o_sess_id = osip_getcopy(local_cms_id_get());
            sdp_message_o_sess_id_set(pClientSDP, o_sess_id);
        }

        o_sess_version = sdp_message_o_sess_version_get(pClientSDP);

        if (NULL != o_sess_version && 0 != sstrcmp(o_sess_version, (char*)"0"))
        {
            osip_free(o_sess_version);
            o_sess_version = NULL;

            o_sess_version = osip_getcopy((char*)"0");
            sdp_message_o_sess_version_set(pClientSDP, o_sess_version);
        }
        else if (NULL == o_sess_version)
        {
            o_sess_version = osip_getcopy(local_cms_id_get());
            sdp_message_o_sess_version_set(pClientSDP, o_sess_version);
        }

        time_r_repeat = sdp_message_r_repeat_get(pClientSDP, 0, 0);

        if (NULL != time_r_repeat)
        {
            DelSDPTimeRepeatInfo(pClientSDP);
        }
    }

    if (0 == strncmp(pClientSDPParam->s_name, (char*)"Playback", 8))
    {
        eCallType = CALL_TYPE_RECORD_PLAY;

        sdp_url = sdp_message_u_uri_get(pClientSDP);

        if (NULL == sdp_url)
        {
            snprintf(strPlayBackURL, 64, "%s:%s", callee_id, (char*)"application");
            sdp_url = osip_getcopy(strPlayBackURL);
            sdp_message_u_uri_set(pClientSDP, sdp_url);
        }
        else
        {
            osip_free(sdp_url);
            sdp_url = NULL;

            snprintf(strPlayBackURL, 64, "%s:%s", callee_id, (char*)"application");
            sdp_url = osip_getcopy(strPlayBackURL);
            sdp_message_u_uri_set(pClientSDP, sdp_url);
        }

#if 1
        sdp_ssrc = sdp_message_y_ssrc_get(pClientSDP);

        if (NULL == sdp_ssrc)
        {
            sdp_ssrc = osip_getcopy((char*)"1100000001");
            sdp_message_y_ssrc_set(pClientSDP, sdp_ssrc);
        }

#endif

        /* 确定录像类型 */
        if (pClientSDPParam->record_type <= 0)
        {
            record_type = EV9000_RECORD_TYPE_NORMAL;
        }
        else
        {
            record_type = pClientSDPParam->record_type;
        }

        i = format_time(pClientSDPParam->start_time, strStartTime);
        i = format_time(pClientSDPParam->end_time, strEndTime);

#if 0

        /* 如果是前端的NVR或者DVR录像，则修改播放时间 */
        if (EV9000_DEVICETYPE_DVR == pCalleeGBDeviceInfo->device_type || EV9000_DEVICETYPE_NVR == pCalleeGBDeviceInfo->device_type)
        {
            if (1 == pCalleeGBLogicDeviceInfo->record_type)
            {
                i = ModifySDPRecordPlayTime(pClientSDP);
                iPlaybackTimeGap = pClientSDPParam->play_time - pClientSDPParam->start_time;
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_route_video_msg_proc() PlaybackTimeGap=%d \r\n", iPlaybackTimeGap);
            }
        }
        else if (EV9000_DEVICETYPE_SIPSERVER == pCalleeGBDeviceInfo->device_type && 1 == pCalleeGBDeviceInfo->three_party_flag) /* 第三方平台 */
        {
            i = ModifySDPRecordPlayTime(pClientSDP);
            iPlaybackTimeGap = pClientSDPParam->play_time - pClientSDPParam->start_time;
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_route_video_msg_proc() PlaybackTimeGap=%d \r\n", iPlaybackTimeGap);
        }

#endif
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的历史视频回放请求:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 录像类型=%d, 媒体流类型=%d, 传输方式=%d, 回放开始时间=%s, 结束时间=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, record_type, stream_type, trans_type, strStartTime, strEndTime);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Historical video playback request from the front-end device:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, media stream type=%d, transmission method=%d, playback start time=%s, end time=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, stream_type, trans_type, strStartTime, strEndTime);
    }
    else if (0 == strncmp(pClientSDPParam->s_name, (char*)"Play", 4))
    {
        eCallType = CALL_TYPE_REALTIME;

#if 1
        sdp_ssrc = sdp_message_y_ssrc_get(pClientSDP);

        if (NULL == sdp_ssrc)
        {
            sdp_ssrc = osip_getcopy((char*)"0100000001");
            sdp_message_y_ssrc_set(pClientSDP, sdp_ssrc);
        }

#endif

        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, 前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 媒体流类型=%d, 传输方式=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, stream_type, trans_type);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Real-time monitoring request from the front-end device:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, media stream type=%d, transmission method=%d, playback start time=%s, end time=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, stream_type, trans_type, strStartTime, strEndTime);
    }
    else if (0 == strncmp(pClientSDPParam->s_name, (char*)"Download", 8))
    {
        eCallType = CALL_TYPE_DOWNLOAD;

        sdp_url = sdp_message_u_uri_get(pClientSDP);

        if (NULL == sdp_url)
        {
            snprintf(strPlayBackURL, 64, "%s:%s", callee_id, (char*)"application");
            sdp_url = osip_getcopy(strPlayBackURL);
            sdp_message_u_uri_set(pClientSDP, sdp_url);
        }
        else
        {
            osip_free(sdp_url);
            sdp_url = NULL;

            snprintf(strPlayBackURL, 64, "%s:%s", callee_id, (char*)"application");
            sdp_url = osip_getcopy(strPlayBackURL);
            sdp_message_u_uri_set(pClientSDP, sdp_url);
        }

#if 1
        sdp_ssrc = sdp_message_y_ssrc_get(pClientSDP);

        if (NULL == sdp_ssrc)
        {
            sdp_ssrc = osip_getcopy((char*)"1100000001");
            sdp_message_y_ssrc_set(pClientSDP, sdp_ssrc);
        }

#endif

        /* 确定录像类型 */
        if (pClientSDPParam->record_type <= 0)
        {
            record_type = EV9000_RECORD_TYPE_NORMAL;
        }
        else
        {
            record_type = pClientSDPParam->record_type;
        }

        i = format_time(pClientSDPParam->start_time, strStartTime);
        i = format_time(pClientSDPParam->end_time, strEndTime);

#if 0

        /* 如果是前端的NVR或者DVR录像，则修改播放时间 */
        if (EV9000_DEVICETYPE_DVR == pCalleeGBDeviceInfo->device_type || EV9000_DEVICETYPE_NVR == pCalleeGBDeviceInfo->device_type)
        {
            if (1 == pCalleeGBLogicDeviceInfo->record_type)
            {
                i = ModifySDPRecordPlayTime(pClientSDP);
                iPlaybackTimeGap = pClientSDPParam->play_time - pClientSDPParam->start_time;
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_route_video_msg_proc() PlaybackTimeGap=%d \r\n", iPlaybackTimeGap);
            }
        }
        else if (EV9000_DEVICETYPE_SIPSERVER == pCalleeGBDeviceInfo->device_type && 1 == pCalleeGBDeviceInfo->three_party_flag) /* 第三方平台 */
        {
            i = ModifySDPRecordPlayTime(pClientSDP);
            iPlaybackTimeGap = pClientSDPParam->play_time - pClientSDPParam->start_time;
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_route_video_msg_proc() PlaybackTimeGap=%d \r\n", iPlaybackTimeGap);
        }

#endif
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的历史视频文件下载请求:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 录像类型=%d, 媒体流类型=%d, 传输方式=%d, 回放开始时间=%s, 结束时间=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, record_type, stream_type, trans_type, strStartTime, strEndTime);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Historical video file download request from the front-end device:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, media stream type=%d, transmission method=%d, playback start time=%s, end time=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, stream_type, trans_type, strStartTime, strEndTime);
    }
    else
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_SDP_NOT_SUPPORT_S_TYPE_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 488, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 488, (char*)"SDP S Type Not Support");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: SDP S Type Not Support \r\n");
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, S名称=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"不支持的S名称类型", pClientSDPParam->s_name);
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s, S name =%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Do not support S name type.", pClientSDPParam->s_name);
        return -1;
    }

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_route_video_msg_proc() Call Type=%d \r\n", eCallType);

    /* 实时视频查看需要判断设备在线状态 */
    if (eCallType == CALL_TYPE_REALTIME)
    {
        /* 看物理设备是否在线 */
        if (0 == pCalleeRouteInfo->reg_status)
        {
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_DEVICE_OFFLINE_ERROR);
            SIP_AnswerToInvite(ua_dialog_index, 480, strErrorCode);
            //SIP_AnswerToInvite(ua_dialog_index, 480, NULL);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: Device Not Online:device_id=%s \r\n", pCalleeRouteInfo->server_id);

            if (EV9000_DEVICETYPE_VIDEODIAGNOSIS == pGBDeviceInfo->device_type
                || EV9000_DEVICETYPE_INTELLIGENTANALYSIS == pGBDeviceInfo->device_type)
            {
                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, 物理设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"前端物理设备不在线", pCalleeRouteInfo->server_id);
                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_NORMAL, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s, physical device ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Front end physical device is not online.", pCalleeRouteInfo->server_id);
            }
            else
            {
                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, 物理设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"前端物理设备不在线", pCalleeRouteInfo->server_id);
                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s, physical device ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Front end physical device is not online.", pCalleeRouteInfo->server_id);
            }

            return -1;
        }

#if 0

        /* 看逻辑设备点位状态 */
        if (0 == pCalleeGBLogicDeviceInfo->status)
        {
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_DEVICE_LOGIC_DEVICE_OFFLINE_ERROR);
            SIP_AnswerToInvite(ua_dialog_index, 480, strErrorCode);
            //SIP_AnswerToInvite(ua_dialog_index, 480, NULL);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: GBLogic Device Not Online \r\n");
            SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"前端逻辑设备不在线");
            EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Front end logic device is not online.");

            return -1;
        }


        if (2 == pCalleeGBLogicDeviceInfo->status)
        {
            SIP_AnswerToInvite(ua_dialog_index, 480, NULL);
            DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_invite_route_video_msg_proc() exit---: GBLogic Device No Stream \r\n");
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"前端逻辑设备没有码流");
            return -1;
        }

#endif

        if (3 == pCalleeGBLogicDeviceInfo->status)
        {
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_DEVICE_LOGIC_DEVICE_UNREACHED_ERROR);
            SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
            //SIP_AnswerToInvite(ua_dialog_index, 480, NULL);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: GBLogic Device NetWork UnReached \r\n");

            if (EV9000_DEVICETYPE_VIDEODIAGNOSIS == pGBDeviceInfo->device_type
                || EV9000_DEVICETYPE_INTELLIGENTANALYSIS == pGBDeviceInfo->device_type)
            {
                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"前端逻辑设备网络不可达");
                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_NORMAL, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Network of front-end logic device is not accessable.");
            }
            else
            {
                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"前端逻辑设备网络不可达");
                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Network of front-end logic device is not accessable.");
            }

            return -1;
        }
    }

    /* 3、申请呼叫资源 */
    cr_pos = call_record_add();
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_route_video_msg_proc() call_record_add:cr_pos=%d \r\n", cr_pos);

    pCrData = call_record_get(cr_pos);

    if (NULL == pCrData)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_GET_IDLE_CR_DATA_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Get Call Record Data Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: Get Call Record Data Error \r\n");
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"申请呼叫资源失败");
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end deviceID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause =%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Apply to call resource failed");

        return -1;
    }

    pCrData->call_type = eCallType;

    /* 4、添加 主被叫信息到呼叫资源信息 */
    /* 主叫端信息 */
    osip_strncpy(pCrData->caller_id, caller_id, MAX_ID_LEN);
    osip_strncpy(pCrData->caller_ip, pGBDeviceInfo->login_ip, MAX_IP_LEN);
    pCrData->caller_port = pGBDeviceInfo->login_port;
    pCrData->caller_ua_index = ua_dialog_index;
    osip_strncpy(pCrData->caller_server_ip_ethname, pGBDeviceInfo->strRegServerEthName, MAX_IP_LEN);
    osip_strncpy(pCrData->caller_server_ip, pGBDeviceInfo->strRegServerIP, MAX_IP_LEN);
    pCrData->caller_server_port = pGBDeviceInfo->iRegServerPort;
    pCrData->caller_transfer_type = trans_type;
    pCrData->iPlaybackTimeGap = iPlaybackTimeGap;

    /* 主叫端的SDP信息 */
    osip_strncpy(pCrData->caller_sdp_ip, pClientSDPParam->sdp_ip, MAX_IP_LEN);
    pCrData->caller_sdp_port = pClientSDPParam->video_port;

#if 0
    printf("\r\n\r\n ************************************************* \r\n");
    printf(" device_invite_route_video_msg_proc() pCrData->caller_id=%s \r\n", pCrData->caller_id);
    printf(" device_invite_route_video_msg_proc() pCrData->caller_ip=%s \r\n", pCrData->caller_ip);
    printf(" device_invite_route_video_msg_proc() pCrData->caller_port=%d \r\n", pCrData->caller_port);
    printf(" device_invite_route_video_msg_proc() pCrData->caller_sdp_ip=%s \r\n", pCrData->caller_sdp_ip);
    printf(" device_invite_route_video_msg_proc() pCrData->caller_sdp_port=%d \r\n", pCrData->caller_sdp_port);
    printf(" device_invite_route_video_msg_proc() pCrData->caller_ua_index=%d \r\n", pCrData->caller_ua_index);
    printf(" ************************************************* \r\n\r\n ");
#endif

    /* 被叫端信息 */
    osip_strncpy(pCrData->callee_id, callee_id, MAX_ID_LEN);
    osip_strncpy(pCrData->callee_ip, pCalleeRouteInfo->server_ip, MAX_IP_LEN);
    pCrData->callee_port = pCalleeRouteInfo->server_port;
    osip_strncpy(pCrData->callee_server_ip_ethname, pCalleeRouteInfo->strRegLocalEthName, MAX_IP_LEN);
    osip_strncpy(pCrData->callee_server_ip, pCalleeRouteInfo->strRegLocalIP, MAX_IP_LEN);
    pCrData->callee_server_port = pCalleeRouteInfo->iRegLocalPort;
    pCrData->callee_framerate = pCalleeGBLogicDeviceInfo->frame_count;
    pCrData->callee_stream_type = stream_type;
    pCrData->callee_gb_device_type = EV9000_DEVICETYPE_SIPSERVER;

    if (1 == pCalleeRouteInfo->trans_protocol)
    {
        pCrData->callee_transfer_type = TRANSFER_PROTOCOL_TCP;
    }
    else
    {
        pCrData->callee_transfer_type = TRANSFER_PROTOCOL_UDP; /* 默认UDP */
    }

#if 0
    printf("\r\n\r\n ************************************************* \r\n");
    printf(" device_invite_route_video_msg_proc() pCrData->callee_id=%s \r\n", pCrData->callee_id);
    printf(" device_invite_route_video_msg_proc() pCrData->callee_ip=%s \r\n", pCrData->callee_ip);
    printf(" device_invite_route_video_msg_proc() pCrData->callee_port=%d \r\n", pCrData->callee_port);
    printf(" ************************************************* \r\n\r\n ");
#endif

    i = user_video_sevice_sub_cms_proc(pCrData, pClientSDP, eCallType);

    if (EV9000_CMS_ERR_INVITE_CALLEE_RECORD_NOT_COMPLETE_ERROR == i)
    {
        i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_ANSWER);
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_WARNING, "前端设备过来的实时视频请求:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 等待逻辑设备录像业务流程结束", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
        return 0;
    }
    else if (EV9000_CMS_ERR_INVITE_CALLEE_VIDEO_NOT_COMPLETE_ERROR == i)
    {
        i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_ANSWER);
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_WARNING, "前端设备过来的实时视频请求:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 等待逻辑设备视频业务流程结束", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
        return 0;
    }
    else if (0 != i)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", i);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Route CMS Proc rror");
        i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
        i = call_record_remove(cr_pos);

        if (0 != i)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_route_video_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
        }
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_invite_audio_msg_proc
 功能描述  : 前端设备发送过来的INVITE消息音频请求处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             sdp_message_t* pClientSDP
             sdp_param_t* pClientSDPParam
             GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo
             char* caller_id
             char* callee_id
             int ua_dialog_index
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年8月4日 星期一
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_invite_audio_msg_proc(GBDevice_info_t* pGBDeviceInfo, sdp_message_t* pClientSDP, sdp_param_t* pClientSDPParam, GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo, char* caller_id, char* callee_id, int ua_dialog_index)
{
    int i = 0;
    int cr_pos = -1;
    cr_t* pCrData = NULL;

    GBDevice_info_t* pCalleeGBDeviceInfo = NULL;
    call_type_t eCallType = CALL_TYPE_NULL;
    char strErrorCode[32] = {0};

    if (NULL == pGBDeviceInfo)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLER_DEVICE_INFO_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"GBDevice Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == pClientSDP)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLER_SDP_MSG_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Client SDP Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: Client SDP Info Error \r\n");
        return -1;
    }

    if (NULL == pClientSDPParam)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLER_SDP_PARAM_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Client SDP Param Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: Client SDP Param Info Error \r\n");
        return -1;
    }

    if (NULL == pCalleeGBLogicDeviceInfo)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLEE_LOGIC_DEVICE_INFO_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Callee GBLogic Device Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: Callee GBLogic Device Info Error \r\n");
        return -1;
    }

    /* 1、查找对应的物理设备 */
    pCalleeGBDeviceInfo = GBDevice_info_get_by_stream_type(pCalleeGBLogicDeviceInfo, EV9000_STREAM_TYPE_MASTER);

    if (NULL == pCalleeGBDeviceInfo)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLEE_DEVICE_INFO_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Get Callee GBDevice Info Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: Get Callee GBDevice Info Error \r\n");
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时音频对讲请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"获取逻辑设备对应的物理设备信息失败");
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Access logic device corresponded physical device info failed");
        return -1;
    }

    /* 目前语音对讲只支持实时对讲 */
    if (0 == strncmp(pClientSDPParam->s_name, "Play", 4))
    {
        eCallType = CALL_TYPE_AUDIO;
    }
    else
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_SDP_NOT_SUPPORT_S_TYPE_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 488, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 488, (char*)"SDP S Type Not Support");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: SDP S Type Not Support \r\n");
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频音频对讲失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, S名称=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"不支持的S名称类型", pClientSDPParam->s_name);
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Do not support S name type");
        return -1;
    }

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_route_video_msg_proc() Call Type=%d \r\n", eCallType);

    /* 看物理设备是否在线 */
    if (0 == pCalleeGBDeviceInfo->reg_status)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_DEVICE_OFFLINE_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 480, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 480, NULL);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: Device Not Online:device_id=%s \r\n", pCalleeGBDeviceInfo->device_id);
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时音频对讲请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, 物理设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"前端物理设备不在线", pCalleeGBDeviceInfo->device_id);
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Front-end physical device not online");
        return -1;
    }

    /* 看逻辑设备点位状态, 如果是下级CMS的点，则不需要判断 */
    if (EV9000_DEVICETYPE_SIPSERVER != pCalleeGBDeviceInfo->device_type && 0 == pCalleeGBLogicDeviceInfo->status)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_DEVICE_LOGIC_DEVICE_OFFLINE_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 480, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 480, NULL);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: GBLogic Device Not Online \r\n");
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时音频对讲请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"前端逻辑设备不在线");
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Front-end logic device is not online");
        return -1;
    }

    if (3 == pCalleeGBLogicDeviceInfo->status)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_DEVICE_LOGIC_DEVICE_UNREACHED_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 480, NULL);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: GBLogic Device NetWork UnReached \r\n");
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时音频对讲请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"前端逻辑设备网络不可达");
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Front-end logic device network unaccessable");
        return -1;
    }

    /* 3、申请呼叫资源 */
    cr_pos = call_record_add();
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_route_video_msg_proc() call_record_add:cr_pos=%d \r\n", cr_pos);

    pCrData = call_record_get(cr_pos);

    if (NULL == pCrData)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_GET_IDLE_CR_DATA_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Get Call Record Data Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: Get Call Record Data Error \r\n");
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时音频对讲请求失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"申请呼叫资源失败");
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Failure of real-time video requests from the front-end device:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, (char*)"Apply to call resource failed");

        return -1;
    }

    pCrData->call_type = eCallType;

    /* 4、添加 主被叫信息到呼叫资源信息 */
    /* 主叫端信息 */
    osip_strncpy(pCrData->caller_id, caller_id, MAX_ID_LEN);
    osip_strncpy(pCrData->caller_ip, pGBDeviceInfo->login_ip, MAX_IP_LEN);
    pCrData->caller_port = pGBDeviceInfo->login_port;
    pCrData->caller_ua_index = ua_dialog_index;
    osip_strncpy(pCrData->caller_server_ip_ethname, pGBDeviceInfo->strRegServerEthName, MAX_IP_LEN);
    osip_strncpy(pCrData->caller_server_ip, pGBDeviceInfo->strRegServerIP, MAX_IP_LEN);
    pCrData->caller_server_port = pGBDeviceInfo->iRegServerPort;
    pCrData->caller_transfer_type = TRANSFER_PROTOCOL_UDP; /* 赋默认值 */

    /* 主叫端的SDP信息 */
    osip_strncpy(pCrData->caller_sdp_ip, pClientSDPParam->sdp_ip, MAX_IP_LEN);
    pCrData->caller_sdp_port = pClientSDPParam->video_port;

#if 0
    printf("\r\n\r\n ************************************************* \r\n");
    printf(" device_invite_route_video_msg_proc() pCrData->caller_id=%s \r\n", pCrData->caller_id);
    printf(" device_invite_route_video_msg_proc() pCrData->caller_ip=%s \r\n", pCrData->caller_ip);
    printf(" device_invite_route_video_msg_proc() pCrData->caller_port=%d \r\n", pCrData->caller_port);
    printf(" device_invite_route_video_msg_proc() pCrData->caller_sdp_ip=%s \r\n", pCrData->caller_sdp_ip);
    printf(" device_invite_route_video_msg_proc() pCrData->caller_sdp_port=%d \r\n", pCrData->caller_sdp_port);
    printf(" device_invite_route_video_msg_proc() pCrData->caller_ua_index=%d \r\n", pCrData->caller_ua_index);
    printf(" ************************************************* \r\n\r\n ");
#endif

    /* 被叫端信息 */
    osip_strncpy(pCrData->callee_id, callee_id, MAX_ID_LEN);
    osip_strncpy(pCrData->callee_ip, pCalleeGBDeviceInfo->login_ip, MAX_IP_LEN);
    pCrData->callee_port = pCalleeGBDeviceInfo->login_port;
    osip_strncpy(pCrData->callee_server_ip_ethname, pCalleeGBDeviceInfo->strRegServerEthName, MAX_IP_LEN);
    osip_strncpy(pCrData->callee_server_ip, pCalleeGBDeviceInfo->strRegServerIP, MAX_IP_LEN);
    pCrData->callee_server_port = pCalleeGBDeviceInfo->iRegServerPort;
    pCrData->callee_framerate = pCalleeGBLogicDeviceInfo->frame_count;
    pCrData->callee_stream_type = EV9000_STREAM_TYPE_MASTER;
    pCrData->callee_transfer_type = TRANSFER_PROTOCOL_UDP; /* 赋默认值 */
    pCrData->callee_gb_device_type = pCalleeGBDeviceInfo->device_type;

#if 0
    printf("\r\n\r\n ************************************************* \r\n");
    printf(" device_invite_route_video_msg_proc() pCrData->callee_id=%s \r\n", pCrData->callee_id);
    printf(" device_invite_route_video_msg_proc() pCrData->callee_ip=%s \r\n", pCrData->callee_ip);
    printf(" device_invite_route_video_msg_proc() pCrData->callee_port=%d \r\n", pCrData->callee_port);
    printf(" ************************************************* \r\n\r\n ");
#endif

    /* 5、转发消息到前端 */
    i = user_transfer_invite_to_dest_for_audio_proc(pCrData, pClientSDP);

    if (0 != i)
    {
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_TRANSFER_MSG_TO_DEST_ERROR);
        SIP_AnswerToInvite(ua_dialog_index, 503, strErrorCode);
        //SIP_AnswerToInvite(ua_dialog_index, 503, (char*)"Transfer Invite Message Proc Error");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() exit---: Transfer Invite Message Proc Error \r\n");
        i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
        i = call_record_remove(cr_pos);

        if (0 != i)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_route_video_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_route_video_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
        }
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_invite_response_msg_proc
 功能描述  : 设备收到Invite响应的处理
 输入参数  : int cr_pos
             int ua_dialog_index
             int response_code
             char* reasonphrase
             char* msg_body
             int msg_body_len
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年8月14日 星期三
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_invite_response_msg_proc(int cr_pos, int ua_dialog_index, int response_code, char* reasonphrase, char* msg_body, int msg_body_len)
{
    int i = 0;
    cr_t* pCrData = NULL;
    sdp_message_t* pRemoteSDP = NULL;
    sdp_param_t stRemoteSDPParam;
    sdp_extend_param_t stRemoteSDPExParam;
    GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo = NULL;
    char strErrorCode[32] = {0};

    if (cr_pos < 0)
    {
        if (200 == response_code)
        {
            i = SIP_SendAck(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            i = SIP_SendBye(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);
        }

        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_response_msg_proc() exit---: Param Error \r\n");
        return -1;
    }

    pCrData = call_record_get(cr_pos);

    if (NULL == pCrData)
    {
        if (200 == response_code)
        {
            i = SIP_SendAck(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            i = SIP_SendBye(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);
        }

        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_response_msg_proc() exit---: Get Call Record Error \r\n");
        return -1;
    }

    /* invite的响应一般由被叫发送过来,设备接收到invite响应，
         主要用于DC解码器的第三方呼叫
         可能是DC 设备的响应，也有可能是源设备的响应
      */

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_response_msg_proc():caller_id=%s, caller_ip=%s, callee_id=%s, callee_ip=%s \r\n", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);
    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, INVITE回应消息处理:前端设备ID=%s, IP地址=%s, 逻辑设备ID=%s, IP地址=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "INVITE response message processing for real-time video request from front end devices:front-end device ID=%s, IPaddress=%s, logic deviceID=%s, IPaddress=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);

    /* 查找逻辑设备信息 */
    pCalleeGBLogicDeviceInfo = GBLogicDevice_info_find(pCrData->callee_id);

    if (NULL == pCalleeGBLogicDeviceInfo)
    {
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"获对前端逻辑设备信息失败");
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Real-time monitoring request from front end device, INVITE response message process failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Access front-end logical device information failed");

        if (200 == response_code)
        {
            /* 回应消息给被叫 */
            i = SIP_SendAck(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            i = SIP_SendBye(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            /* 回应消息给主叫 */
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLEE_LOGIC_DEVICE_INFO_ERROR);
            SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
            //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Get Callee GBlogicDevice Info Error");
        }

        i = return_error_for_wait_answer_call_record(pCrData, EV9000_CMS_ERR_INVITE_CALLEE_LOGIC_DEVICE_INFO_ERROR);

        i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
        i = call_record_remove(cr_pos);

        if (0 != i)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_response_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_response_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
        }

        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_response_msg_proc() exit---: Get Callee GBlogicDevice Info Error \r\n");
        return -1;
    }

    if (CALL_TYPE_DC == pCrData->call_type) /* 第三方的DC流程 */
    {
        i = device_invite_dc_response_msg_proc(cr_pos, ua_dialog_index, response_code, pCrData, msg_body, msg_body_len);
    }
    else
    {
        /* 根据响应码作不同的处理 */
        if (200 == response_code)
        {
            if (NULL == msg_body || msg_body_len == 0)
            {
                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"获对端的SDP信息失败");
                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Real-time monitoring request from front end device, INVITE response message process failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Access opposite end SDP info failed");

                /* 回应消息给被叫 */
                i = SIP_SendAck(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                i = SIP_SendBye(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                /* 回应消息给主叫 */
                memset(strErrorCode, 0, 32);
                snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_CALLEE_MSG_BODY_ERROR);
                SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);

                i = return_error_for_wait_answer_call_record(pCrData, EV9000_CMS_ERR_INVITE_CALLEE_MSG_BODY_ERROR);

                i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
                i = call_record_remove(cr_pos);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_response_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_response_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
                }

                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_response_msg_proc() exit---: Get Remote Message SDP Body Error \r\n");
                return -1;
            }

            /* 获取200消息中的被叫的sdp信息 */
            i = sdp_message_init(&pRemoteSDP);

            if (0 != i)
            {
                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"SDP初始化失败");
                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video requests from front end devices failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"SDP initialization failed.");

                /* 回应消息给被叫 */
                i = SIP_SendAck(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                i = SIP_SendBye(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                /* 回应消息给主叫 */
                memset(strErrorCode, 0, 32);
                snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_SDP_MSG_INIT_ERROR);
                SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);

                i = return_error_for_wait_answer_call_record(pCrData, EV9000_CMS_ERR_SDP_MSG_INIT_ERROR);

                i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
                i = call_record_remove(cr_pos);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_response_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_response_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
                }

                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_response_msg_proc() exit---: Remote SDP Message Init Error \r\n");
                return -1;
            }

            i = sdp_message_parse(pRemoteSDP, msg_body); /*parse body */

            if (0 != i)
            {
                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"SDP信息解析失败");
                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video requests from front end devices failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"SDP information analysis failed.");

                /* 回应消息给被叫 */
                i = SIP_SendAck(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                i = SIP_SendBye(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                /* 回应消息给主叫 */
                memset(strErrorCode, 0, 32);
                snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_SDP_MSG_PARSE_ERROR);
                SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);

                i = return_error_for_wait_answer_call_record(pCrData, EV9000_CMS_ERR_SDP_MSG_PARSE_ERROR);

                i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
                i = call_record_remove(cr_pos);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_response_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_response_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
                }

                sdp_message_free(pRemoteSDP);
                pRemoteSDP = NULL;

                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_response_msg_proc() exit---: Remote SDP Message Parse Error \r\n");
                return -1;
            }

            /* 获取协商的SDP信息 */
            memset(&stRemoteSDPParam, 0, sizeof(sdp_param_t));
            memset(&stRemoteSDPExParam, 0, sizeof(sdp_extend_param_t));

            i = SIP_GetSDPInfoEx(pRemoteSDP, &stRemoteSDPParam, &stRemoteSDPExParam);

            if (0 != i)
            {
                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"获取SDP中的信息失败");
                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video requests from front end devices failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Access the information from SDP failed.");

                /* 回应消息给被叫 */
                i = SIP_SendAck(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                i = SIP_SendBye(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                /* 回应消息给主叫 */
                memset(strErrorCode, 0, 32);
                snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_SDP_GET_VIDEO_INFO_ERROR);
                SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);

                i = return_error_for_wait_answer_call_record(pCrData, EV9000_CMS_ERR_SDP_GET_VIDEO_INFO_ERROR);

                i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
                i = call_record_remove(cr_pos);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_response_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_response_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
                }

                sdp_message_free(pRemoteSDP);
                pRemoteSDP = NULL;

                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_response_msg_proc() exit---: Get Remote SDP Video Info Error \r\n");
                return -1;
            }

            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_response_msg_proc() addr=%s,port=%d,code=%d,flag=%d \r\n", stRemoteSDPParam.sdp_ip, stRemoteSDPParam.video_port, stRemoteSDPParam.video_code_type, stRemoteSDPParam.media_direction);

            /* 判断前端设备的ONVIF URL */
            if (stRemoteSDPExParam.onvif_url[0] != '\0')
            {
                if (strlen(stRemoteSDPExParam.onvif_url) < 255)
                {
                    osip_strncpy(pCrData->callee_onvif_url, stRemoteSDPExParam.onvif_url, strlen(stRemoteSDPExParam.onvif_url));
                }
                else
                {
                    osip_strncpy(pCrData->callee_onvif_url, stRemoteSDPExParam.onvif_url, 255);
                }

                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_response_msg_proc() callee_onvif_url=%s \r\n", pCrData->callee_onvif_url);

                /* 被叫侧的协议类型改为RTSP */
                //pCrData->callee_transfer_type = TRANSFER_PROTOCOL_RTSP;
            }

            /* 添加被叫的SDP 信息 */
            osip_strncpy(pCrData->callee_sdp_ip, stRemoteSDPParam.sdp_ip, MAX_IP_LEN);

#if 0
            printf("\r\n\r\n ************************************************* \r\n");
            printf(" device_invite_response_msg_proc() pCrData->callee_sdp_ip=%s \r\n", pCrData->callee_sdp_ip);
            printf(" device_invite_response_msg_proc() pCrData->callee_sdp_port=%d \r\n", pCrData->callee_sdp_port);
            printf(" device_invite_response_msg_proc() pCrData->tsu_code=%d \r\n", pCrData->tsu_code);
            printf(" ************************************************* \r\n\r\n ");
#endif

            if (CALL_TYPE_AUDIO == pCrData->call_type)
            {
                pCrData->callee_sdp_port = stRemoteSDPParam.audio_port;
                pCrData->tsu_code = stRemoteSDPParam.audio_code_type;

                i = device_invite_audio_response_msg_proc(cr_pos, ua_dialog_index, pCrData, pRemoteSDP, pCalleeGBLogicDeviceInfo);
            }
            else
            {
                pCrData->callee_sdp_port = stRemoteSDPParam.video_port;
                pCrData->tsu_code = stRemoteSDPParam.video_code_type;

                i = device_invite_video_response_msg_proc(cr_pos, ua_dialog_index, pCrData, pRemoteSDP, pCalleeGBLogicDeviceInfo);
            }

            if (i != 0)
            {
                i = return_error_for_wait_answer_call_record(pCrData, i);

                i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
                i = call_record_remove(cr_pos);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_response_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_response_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
                }

                sdp_message_free(pRemoteSDP);
                pRemoteSDP = NULL;

                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_response_msg_proc() exit---: Accept Invite Error \r\n");
                return -1;
            }

            /* 通知等待的呼叫任务，接受请求，通知TSU转发码流 */
            i = resumed_wait_answer_call_record1(pCrData);

            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, INVITE回应消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment real-time video request, respond the INVITE message processing success: ID = % s front-end equipment, IP address = % s, port = % d, logical device ID = %s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id);
            sdp_message_free(pRemoteSDP);
            pRemoteSDP = NULL;
        }
        else
        {
            SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, 错误码=%d, reasonphrase=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"非200的错误响应消息", response_code, reasonphrase);
            EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video requests from front end devices failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s, error code=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"not 200 response message error", response_code);

            if (EV9000_DEVICETYPE_SIPSERVER == pCrData->callee_gb_device_type)/* 可能是下级CMS返回的有具体错误原因 */
            {
                if (NULL != reasonphrase && reasonphrase[0] != '\0')
                {
                    SIP_AnswerToInvite(pCrData->caller_ua_index, response_code, reasonphrase);
                    i = return_error_for_wait_answer_call_record(pCrData, response_code);
                }
                else
                {
                    memset(strErrorCode, 0, 32);
                    snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_FRONT_RETURN_ERROR);
                    SIP_AnswerToInvite(pCrData->caller_ua_index, response_code, strErrorCode);
                    i = return_error_for_wait_answer_call_record(pCrData, EV9000_CMS_ERR_INVITE_FRONT_RETURN_ERROR);
                }
            }
            else
            {
                memset(strErrorCode, 0, 32);
                snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_FRONT_RETURN_ERROR);
                SIP_AnswerToInvite(pCrData->caller_ua_index, response_code, strErrorCode);
                i = return_error_for_wait_answer_call_record(pCrData, EV9000_CMS_ERR_INVITE_FRONT_RETURN_ERROR);
            }
        }

        /* 4、如果是错误回应，移除呼叫信息 */
        if (response_code >= 400)
        {
            i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
            i = call_record_remove(cr_pos);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_response_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_response_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
            }
        }
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_invite_dc_response_msg_proc
 功能描述  : 设备收到Invite响应的处理
 输入参数  : int cr_pos
             int ua_dialog_index
             int response_code
             cr_t* pCrData
             char* msg_body
             int msg_body_len
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年8月14日 星期三
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_invite_dc_response_msg_proc(int cr_pos, int ua_dialog_index, int response_code, cr_t* pCrData, char* msg_body, int msg_body_len)
{
    int i = 0;

    if (pCrData->callee_ua_index == ua_dialog_index)    /*收到源设备端的响应*/
    {
        i = device_answer_source_invite_response_for_dc_proc(pCrData, response_code, msg_body, msg_body_len);

        if (0 != i)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_invite_dc_response_msg_proc() device_answer_source_invite_response_for_dc_proc Error \r\n");

            /* 回应Message响应给客户端 */
            i = SendConnectTVResponseToUser(0, ua_dialog_index);

            if (200 == response_code)
            {
                /* 回应消息给源端设备 */
                i = SIP_SendAck(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_dc_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                i = SIP_SendBye(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_dc_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);
            }

            SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 发送通知消息给客户端, 电视墙业务失败:逻辑设备ID=%s, 电视墙通道ID=%s", pCrData->callee_id, pCrData->caller_id);
            EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, send notification to the client, TV wall business failed: logic device ID=%s, TV wall channel ID=%s", pCrData->callee_id, pCrData->caller_id);

            /* 移除呼叫业务 */
            i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
            i = call_record_remove(cr_pos);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_dc_response_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_dc_response_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
            }
        }
        else
        {
            if (200 == response_code)
            {
                if (!g_DECMediaTransferFlag
                    && EV9000_DEVICETYPE_SIPSERVER == pCrData->callee_gb_device_type)
                {
                    /* 如果是跨级CMS的点位并且不需要本级TSU转发码流，直接转发消息 */
                    i = SIP_SendAck(ua_dialog_index);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_dc_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);
                }
                else
                {
                    /* 加入待发送ACK 消息队列 */
                    if (ua_dialog_index == pCrData->caller_ua_index)
                    {
                        i = ack_send_use(cr_pos, ua_dialog_index, -1);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_dc_response_msg_proc() ack_send_use:cr_pos=%d, caller_ua_index=%d \r\n", cr_pos, ua_dialog_index);
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "电视墙业务, 收到源设备端的响应处理, 添加等待TSU通知任务创建结果消息处理结果事件, 等待发送ACK消息:cr_pos=%d, caller_ua_index=%d, iRet=%d", cr_pos, ua_dialog_index, i);
                    }
                    else if (ua_dialog_index == pCrData->callee_ua_index)
                    {
                        i = ack_send_use(cr_pos, -1, ua_dialog_index);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_dc_response_msg_proc() ack_send_use:cr_pos=%d, callee_ua_index=%d \r\n", cr_pos, ua_dialog_index);
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "电视墙业务, 收到源设备端的响应处理, 添加等待TSU通知任务创建结果消息处理结果事件, 等待发送ACK消息:cr_pos=%d, callee_ua_index=%d, iRet=%d", cr_pos, ua_dialog_index, i);
                    }
                }
            }
        }
    }
    else if (pCrData->caller_ua_index == ua_dialog_index) /* 收到DC端的响应 */
    {
        /* 根据呼叫类型作不同的处理 */
        if (pCrData->callee_ua_index < 0)
        {
            /* CMS主动发起呼叫后收到DC解码器的INVITE 响应*/
            i = device_answer_dc_invite_response_proc(pCrData, response_code, msg_body, msg_body_len);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_invite_dc_response_msg_proc() device_answer_dc_invite_response_proc Error \r\n");

                /* 回应Message响应给客户端 */
                i = SendConnectTVResponseToUser(0, ua_dialog_index);

                if (200 == response_code)
                {
                    /* 回应消息给DC */
                    i = SIP_SendAck(ua_dialog_index);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_dc_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                    i = SIP_SendBye(ua_dialog_index);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_dc_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);
                }

                SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 发送通知消息给客户端, 电视墙业务失败:逻辑设备ID=%s, 电视墙通道ID=%s", pCrData->callee_id, pCrData->caller_id);
                EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, send notification to the client, TV wall business failed: logic device ID=%s, TV wall channel ID=%s", pCrData->callee_id, pCrData->caller_id);

                /* 移除呼叫业务 */
                i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
                i = call_record_remove(cr_pos);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_dc_response_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_dc_response_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
                }
            }
            else
            {
                /* 回应Message响应给客户端 */
                i = SendConnectTVResponseToUser(1, ua_dialog_index);

                if (200 == response_code)
                {
#if 0

                    /* 加入待发送ACK 消息队列 */
                    if (ua_dialog_index == pCrData->caller_ua_index)
                    {
                        i = ack_send_use(cr_pos, ua_dialog_index, -1);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_dc_response_msg_proc() ack_send_use:cr_pos=%d, caller_ua_index=%d \r\n", cr_pos, ua_dialog_index);
                    }
                    else if (ua_dialog_index == pCrData->callee_ua_index)
                    {
                        i = ack_send_use(cr_pos, -1, ua_dialog_index);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_dc_response_msg_proc() ack_send_use:cr_pos=%d, callee_ua_index=%d \r\n", cr_pos, ua_dialog_index);
                    }

#endif
                    /* 回应消息给DC */
                    i = SIP_SendAck(ua_dialog_index);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_dc_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);
                }

                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "电视墙业务, 发送通知消息给客户端, 电视墙业务成功:逻辑设备ID=%s, 电视墙通道ID=%s", pCrData->callee_id, pCrData->caller_id);
                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "TV wall, send a notification message to the client, TV wall business success:Logic Device ID=%s, TV wall Chanal_ID=%s", pCrData->callee_id, pCrData->caller_id);
            }
        }
        else if (pCrData->callee_ua_index >= 0)
        {
            /* 用户启动DC后发送请求到源再收到DC端的Invite响应处理 */
            i = device_answer_dc_invite_response_proc(pCrData, response_code, msg_body, msg_body_len);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_invite_dc_response_msg_proc() device_answer_dc_invite_response_proc Error \r\n");

                /* 回应Message响应给客户端 */
                i = SendConnectTVResponseToUser(0, pCrData->callee_ua_index);

                if (200 == response_code)
                {
                    /* 回应消息给DC */
                    i = SIP_SendAck(ua_dialog_index);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_dc_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                    i = SIP_SendBye(ua_dialog_index);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_dc_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);
                }

                /* 发送Bye 给源 */
                i = SIP_SendBye(pCrData->callee_ua_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_dc_response_msg_proc() SIP_SendBye:callee_ua_index=%d, i=%d \r\n", pCrData->callee_ua_index, i);

                SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 发送通知消息给客户端, 电视墙业务失败:逻辑设备ID=%s, 电视墙通道ID=%s", pCrData->callee_id, pCrData->caller_id);
                EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, send notification to the client, TV wall business failed: logic device ID=%s, TV wall channel ID=%s", pCrData->callee_id, pCrData->caller_id);

                /* 移除呼叫业务 */
                i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
                i = call_record_remove(cr_pos);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_dc_response_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_dc_response_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
                }
            }
            else
            {
                /* 回应Message响应给客户端 */
                i = SendConnectTVResponseToUser(1, pCrData->callee_ua_index);

                if (200 == response_code)
                {
#if 0

                    /* 加入待发送ACK 消息队列 */
                    if (ua_dialog_index == pCrData->caller_ua_index)
                    {
                        i = ack_send_use(cr_pos, ua_dialog_index, -1);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_response_msg_proc() ack_send_use:cr_pos=%d, caller_ua_index=%d \r\n", cr_pos, ua_dialog_index);
                    }
                    else if (ua_dialog_index == pCrData->callee_ua_index)
                    {
                        i = ack_send_use(cr_pos, -1, ua_dialog_index);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_response_msg_proc() ack_send_use:cr_pos=%d, callee_ua_index=%d \r\n", cr_pos, ua_dialog_index);
                    }

#endif
                    /* 回应消息给DC */
                    i = SIP_SendAck(ua_dialog_index);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_dc_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);
                }

                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "电视墙业务, 发送通知消息给客户端, 电视墙业务成功:逻辑设备ID=%s, 电视墙通道ID=%s", pCrData->callee_id, pCrData->caller_id);
                EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_NORMAL, "TV wall business, send notification to the client, TV wall business failed: logic device ID=%s, TV wall channel ID=%s", pCrData->callee_id, pCrData->caller_id);
            }
        }
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_invite_video_response_msg_proc
 功能描述  : 设备收到Invite响应的处理
 输入参数  : int cr_pos
             int ua_dialog_index
             cr_t* pCrData
             sdp_message_t* pRemoteSDP
             GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年8月14日 星期三
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_invite_video_response_msg_proc(int cr_pos, int ua_dialog_index, cr_t* pCrData, sdp_message_t* pRemoteSDP, GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo)
{
    int i = 0;

    /* 根据逻辑设备所属域进行判断，决定消息走向 */
    if (1 == pCalleeGBLogicDeviceInfo->other_realm)
    {
        i = device_invite_video_route_response_msg_proc(cr_pos, ua_dialog_index, pCrData, pRemoteSDP, pCalleeGBLogicDeviceInfo);
    }
    else
    {
        i = device_invite_video_sub_response_msg_proc(cr_pos, ua_dialog_index, pCrData, pRemoteSDP, pCalleeGBLogicDeviceInfo);
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_invite_video_sub_response_msg_proc
 功能描述  : 设备收到Invite响应的处理
 输入参数  : int cr_pos
             int ua_dialog_index
             cr_t* pCrData
             sdp_message_t* pRemoteSDP
             GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年8月14日 星期三
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_invite_video_sub_response_msg_proc(int cr_pos, int ua_dialog_index, cr_t* pCrData, sdp_message_t* pRemoteSDP, GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo)
{
    int i = 0;
    int send_port = 0;
    char* sdp_tsu_ip = NULL;
    char strErrorCode[32] = {0};

    if (!g_LocalMediaTransferFlag
        && EV9000_DEVICETYPE_SIPSERVER == pCrData->callee_gb_device_type)
    {
        /* 如果是跨级CMS的点位并且不需要本级TSU转发码流，直接转发消息 */
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, INVITE回应消息处理:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 媒体流不经过本级转发, 直接转发消息到媒体流请求方", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "INVITE response message processing for real-time video request from front end device:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, Media stream without forward at the corresponding level, the forward message directly to the requesting party media flow", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id);
    }
    else
    {
        if (EV9000_DEVICETYPE_SIPSERVER == pCrData->callee_gb_device_type
            && (pCrData->call_type == CALL_TYPE_RECORD_PLAY || pCrData->call_type == CALL_TYPE_DOWNLOAD)) /* 下级CMS 过来的 */
        {
            //发送端口号从新获取
            /* 获取TSU 发送端口号 */
            send_port = get_send_port_by_tsu_resource(pCrData->tsu_ip);

            if (send_port <= 0)
            {
                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, tsu_ip=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"获取TSU的发送端口号失败", pCrData->tsu_ip);
                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video request from front end device failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s, tsu_ip=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Access TSU send port number failed.", pCrData->tsu_ip);

                /* 回应消息给被叫 */
                i = SIP_SendAck(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                i = SIP_SendBye(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                /* 回应消息给主叫 */
                memset(strErrorCode, 0, 32);
                snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_TSU_GET_SEND_PORT_ERROR);
                SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
                //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Get TSU Send Port Error");

                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_sub_response_msg_proc() exit---: Get TSU Send Port Error:tsu_ip=%s \r\n", pCrData->tsu_ip);
                return EV9000_CMS_ERR_TSU_GET_SEND_PORT_ERROR;
            }

            pCrData->tsu_send_port = send_port;

            /* 通知TSU开始转发码流 */
            i = notify_tsu_add_transfer_for_replay_task(pCrData, 0, pCrData->callee_stream_type);
        }
        else if (pCalleeGBLogicDeviceInfo->record_type == 1 && (pCrData->call_type == CALL_TYPE_RECORD_PLAY || pCrData->call_type == CALL_TYPE_DOWNLOAD)) /* 调看前端录像 */
        {
            //发送端口号从新获取
            /* 获取TSU 发送端口号 */
            send_port = get_send_port_by_tsu_resource(pCrData->tsu_ip);

            if (send_port <= 0)
            {
                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, tsu_ip=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"获取TSU的发送端口号失败", pCrData->tsu_ip);
                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video requests from front end devices failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s, tsu_ip=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Access TSU send port number failed.", pCrData->tsu_ip);

                /* 回应消息给被叫 */
                i = SIP_SendAck(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                i = SIP_SendBye(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                /* 回应消息给主叫 */
                memset(strErrorCode, 0, 32);
                snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_TSU_GET_SEND_PORT_ERROR);
                SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
                //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Get TSU Send Port Error");

                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_sub_response_msg_proc() exit---: Get TSU Send Port Error:tsu_ip=%s \r\n", pCrData->tsu_ip);
                return EV9000_CMS_ERR_TSU_GET_SEND_PORT_ERROR;
            }

            pCrData->tsu_send_port = send_port;

            /* 通知TSU开始转发码流 */
            i = notify_tsu_add_transfer_for_replay_task(pCrData, 0, pCrData->callee_stream_type);
        }
        else
        {
            if (TRANSFER_PROTOCOL_TCP == pCrData->caller_transfer_type) /* TCP的情况下，直接调用TSU转发接口，返回值是TSU的发送端口号 */
            {
                /* 通知TSU开始转发码流 */
                i = notify_tsu_add_transfer_task(pCrData, pCrData->callee_service_type, pCrData->callee_stream_type);

                if (i > 0)
                {
                    pCrData->tsu_send_port = i;
                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_video_sub_response_msg_proc() tsu_send_port=%d \r\n", pCrData->tsu_send_port);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_sub_response_msg_proc() tsu_send_port=%d \r\n", pCrData->tsu_send_port);
                }
            }
            else
            {
                //发送端口号从新获取
                /* 获取TSU 发送端口号 */
                send_port = get_send_port_by_tsu_resource(pCrData->tsu_ip);

                if (send_port <= 0)
                {
                    SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, tsu_ip=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"获取TSU的发送端口号失败", pCrData->tsu_ip);
                    EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video requests from front end devices failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s, tsu_ip=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Access TSU send port number failed", pCrData->tsu_ip);

                    /* 回应消息给被叫 */
                    i = SIP_SendAck(ua_dialog_index);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                    i = SIP_SendBye(ua_dialog_index);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                    /* 回应消息给主叫 */
                    memset(strErrorCode, 0, 32);
                    snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_TSU_GET_SEND_PORT_ERROR);
                    SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
                    //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Get TSU Send Port Error");

                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_sub_response_msg_proc() exit---: Get TSU Send Port Error:tsu_ip=%s \r\n", pCrData->tsu_ip);
                    return EV9000_CMS_ERR_TSU_GET_SEND_PORT_ERROR;
                }

                pCrData->tsu_send_port = send_port;

                /* 通知TSU开始转发码流 */
                i = notify_tsu_add_transfer_task(pCrData, pCrData->callee_service_type, pCrData->callee_stream_type);
            }
        }

        if (i < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_sub_response_msg_proc() exit---: notify_tsu_add_transfer_task Error: TSU IP=%s, i=%d \r\n", pCrData->tsu_ip, i);
            SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, TSU IP=%s, iRet=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"通知TSU添加转发任务失败", pCrData->tsu_ip, i);
            EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video requests from front end devices failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s, TSU IP=%s, iRet=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Notify TSU to add forwarding task failed", pCrData->tsu_ip, i);

            /* 回应消息给被叫 */
            i = SIP_SendAck(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            i = SIP_SendBye(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            /* 回应消息给主叫 */
            i = SIP_SendBye(pCrData->caller_ua_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendBye:caller_ua_index=%d, i=%d \r\n", pCrData->caller_ua_index, i);
            return EV9000_CMS_ERR_TSU_NOTIFY_ADD_TRANSFER_ERROR;
        }
        else
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, INVITE回应消息处理:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 通知TSU添加转发任务成功, TSU IP=%s, task_id=%s, iRet=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, pCrData->tsu_ip, pCrData->task_id, i);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "INVITE response message processing for real-time video requests from front end devices:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, Notify the TSU add forward task successfully, TSU IP=%s, task_id=%s, iRet=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, pCrData->tsu_ip, pCrData->task_id, i);
        }

        /* 组建本地SDP信息*/
        sdp_tsu_ip = get_cr_sdp_tsu_ip(pCrData, pCrData->caller_server_ip_ethname);

        if (NULL == sdp_tsu_ip)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_sub_response_msg_proc() exit---: Get Caller TSU SDP IP Error:callee_server_ip_ethname=%s\r\n", pCrData->caller_server_ip_ethname);
            SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, callee_server_ip_ethname=%s, iRet=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"获取主叫侧的SDP消息中的TSU的IP地址失败", pCrData->caller_server_ip_ethname, i);
            EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video requests from front end devices failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s, callee_server_ip_ethname=%s, iRet=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)" Access TSU IP address from calling side SDP message failed.", pCrData->caller_server_ip_ethname, i);

            /* 通知TSU停止转发码流 */
            i = notify_tsu_delete_transfer_task(pCrData->tsu_ip, pCrData->task_id);

            /* 回应消息给被叫 */
            i = SIP_SendAck(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            i = SIP_SendBye(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            /* 回应消息给主叫 */
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_TSU_GET_CALLER_TSU_IP_ERROR);
            SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
            //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Modify SDP S Name Error");

            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_sub_response_msg_proc() exit---: Get sdp_tsu_ip Error \r\n");

            return EV9000_CMS_ERR_TSU_GET_CALLER_TSU_IP_ERROR;
        }

        /* 修改SDP中的S Name */
        i = ModifySDPSName(pRemoteSDP, pCrData->call_type);

        if (i != 0)
        {
            SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"修改SDP中的S Name失败");
            EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video requests from front end devices failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Modify S name in SDP failed.");

            /* 通知TSU停止转发码流 */
            i = notify_tsu_delete_transfer_task(pCrData->tsu_ip, pCrData->task_id);

            /* 回应消息给被叫 */
            i = SIP_SendAck(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            i = SIP_SendBye(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            /* 回应消息给主叫 */
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_SDP_MODIFY_S_NAME_ERROR);
            SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
            //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Modify SDP S Name Error");

            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_sub_response_msg_proc() exit---: Modify SDP S Name Error \r\n");
            return EV9000_CMS_ERR_SDP_MODIFY_S_NAME_ERROR;
        }

        /* 修改SDP中的ip地址和端口号*/
        i = ModifySDPIPAndPort(pRemoteSDP, sdp_tsu_ip, pCrData->tsu_send_port);

        if (i != 0)
        {
            SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"修改SDP中的IP和端口号失败");
            EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video requests from front end devices failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Modify IP and port number in SDP failed.");

            /* 通知TSU停止转发码流 */
            i = notify_tsu_delete_transfer_task(pCrData->tsu_ip, pCrData->task_id);

            /* 回应消息给被叫 */
            i = SIP_SendAck(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            i = SIP_SendBye(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            /* 回应消息给主叫 */
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_SDP_MODIFY_IP_ERROR);
            SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
            //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Modify SDP IP And Addr Error");

            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_sub_response_msg_proc() exit---: Modify SDP IP And Addr Error \r\n");
            return EV9000_CMS_ERR_SDP_MODIFY_IP_ERROR;
        }

        /* 修改SDP中的协议传输类型 */
        if (pCrData->caller_transfer_type != pCrData->callee_transfer_type)
        {
            if (TRANSFER_PROTOCOL_TCP == pCrData->caller_transfer_type)
            {
                i = ModifySDPTransProtocol(pRemoteSDP, 1);
            }
            else
            {
                i = ModifySDPTransProtocol(pRemoteSDP, 0);
            }

            if (i != 0)
            {
                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"修改SDP中的协议传输类型失败");
                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video requests from front end devices failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Modify the protocol type in SDP failed.");

                /* 通知TSU停止转发码流 */
                i = notify_tsu_delete_transfer_task(pCrData->tsu_ip, pCrData->task_id);

                /* 回应消息给被叫 */
                i = SIP_SendAck(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                i = SIP_SendBye(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                /* 回应消息给主叫 */
                memset(strErrorCode, 0, 32);
                snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_SDP_MODIFY_PROTOCOL_ERROR);
                SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
                //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Modify SDP Protocol Error");

                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_sub_response_msg_proc() exit---: Modify SDP Protocol Error \r\n");
                return EV9000_CMS_ERR_SDP_MODIFY_PROTOCOL_ERROR;
            }
        }
    }

    /* 接收主叫方的呼叫*/
    i = SIP_AcceptInvite(pCrData->caller_ua_index, pRemoteSDP);

    if (i != 0)
    {
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"接收客户端的INVITE消息失败");
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video requests from front end devices failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Failed to receive INVITE message from the client.");

        if (!g_LocalMediaTransferFlag
            && EV9000_DEVICETYPE_SIPSERVER == pCrData->callee_gb_device_type)
        {
            /* 如果是跨级CMS的点位并且不需要本级TSU转发码流，直接转发消息 */
        }
        else
        {
            /* 通知TSU停止转发码流 */
            i = notify_tsu_delete_transfer_task(pCrData->tsu_ip, pCrData->task_id);
        }

        /* 回应消息给被叫 */
        i = SIP_SendAck(ua_dialog_index);
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

        i = SIP_SendBye(ua_dialog_index);
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

        /* 回应消息给主叫 */
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_ACCEPT_ERROR);
        SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
        //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Accept Invite Error");

        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_sub_response_msg_proc() exit---: Accept Invite Error \r\n");
        return EV9000_CMS_ERR_INVITE_ACCEPT_ERROR;
    }

    if (!g_LocalMediaTransferFlag
        && EV9000_DEVICETYPE_SIPSERVER == pCrData->callee_gb_device_type)
    {
        /* 如果是跨级CMS的点位并且不需要本级TSU转发码流，直接转发消息 */
        i = SIP_SendAck(ua_dialog_index);
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);
    }
    else
    {
        if (EV9000_DEVICETYPE_SIPSERVER == pCrData->callee_gb_device_type
            && (pCrData->call_type == CALL_TYPE_RECORD_PLAY || pCrData->call_type == CALL_TYPE_DOWNLOAD)) /* 下级CMS 过来的 */
        {
            i = SIP_SendAck(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);
        }
        else if (pCalleeGBLogicDeviceInfo->record_type == 1 && (pCrData->call_type == CALL_TYPE_RECORD_PLAY || pCrData->call_type == CALL_TYPE_DOWNLOAD)) /* 调看前端录像 */
        {
            i = SIP_SendAck(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);
        }
        else
        {
            /* 加入待发送ACK 消息队列 */
            if (ua_dialog_index == pCrData->caller_ua_index)
            {
                i = ack_send_use(cr_pos, ua_dialog_index, -1);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() ack_send_use:cr_pos=%d, caller_ua_index=%d \r\n", cr_pos, ua_dialog_index);
                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, INVITE回应消息处理, 添加等待TSU通知任务创建结果消息处理结果事件, 等待发送ACK消息:cr_pos=%d, caller_ua_index=%d, iRet=%d", cr_pos, ua_dialog_index, i);
            }
            else if (ua_dialog_index == pCrData->callee_ua_index)
            {
                i = ack_send_use(cr_pos, -1, ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_sub_response_msg_proc() ack_send_use:cr_pos=%d, callee_ua_index=%d \r\n", cr_pos, ua_dialog_index);
                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, INVITE回应消息处理, 添加等待TSU通知任务创建结果消息处理结果事件, 等待发送ACK消息:cr_pos=%d, callee_ua_index=%d, iRet=%d", cr_pos, ua_dialog_index, i);
            }
        }
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, INVITE回应消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "INVITE response message processing for real-time video requests from front end devices successfully:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id);
    return 0;
}

/*****************************************************************************
 函 数 名  : device_invite_video_route_response_msg_proc
 功能描述  : 设备收到Invite响应的处理
 输入参数  : int cr_pos
             int ua_dialog_index
             cr_t* pCrData
             sdp_message_t* pRemoteSDP
             GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年8月14日 星期三
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_invite_video_route_response_msg_proc(int cr_pos, int ua_dialog_index, cr_t* pCrData, sdp_message_t* pRemoteSDP, GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo)
{
    int i = 0;
    int send_port = 0;
    char* sdp_tsu_ip = NULL;
    char strErrorCode[32] = {0};

    if (!g_LocalMediaTransferFlag)
    {
        /* 如果是跨级CMS的点位并且不需要本级TSU转发码流，直接转发消息 */
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, INVITE回应消息处理:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 媒体流不经过本级转发, 直接转发消息到媒体流请求方", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "INVITE response message processing for real-time video request from front end device:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, Media stream without forward at the corresponding level, the forward message directly to the requesting party media flow", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id);
    }
    else
    {
        if (pCrData->call_type == CALL_TYPE_RECORD_PLAY || pCrData->call_type == CALL_TYPE_DOWNLOAD) /* 下级CMS 过来的 */
        {
            //发送端口号从新获取
            /* 获取TSU 发送端口号 */
            send_port = get_send_port_by_tsu_resource(pCrData->tsu_ip);

            if (send_port <= 0)
            {
                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, tsu_ip=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"获取TSU的发送端口号失败", pCrData->tsu_ip);
                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video request from front end device failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s, tsu_ip=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Access TSU send port number failed.", pCrData->tsu_ip);

                /* 回应消息给被叫 */
                i = SIP_SendAck(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                i = SIP_SendBye(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                /* 回应消息给主叫 */
                memset(strErrorCode, 0, 32);
                snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_TSU_GET_SEND_PORT_ERROR);
                SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
                //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Get TSU Send Port Error");

                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_route_response_msg_proc() exit---: Get TSU Send Port Error:tsu_ip=%s \r\n", pCrData->tsu_ip);
                return EV9000_CMS_ERR_TSU_GET_SEND_PORT_ERROR;
            }

            pCrData->tsu_send_port = send_port;

            /* 通知TSU开始转发码流 */
            i = notify_tsu_add_transfer_for_replay_task(pCrData, 0, pCrData->callee_stream_type);
        }
        else
        {
            if (TRANSFER_PROTOCOL_TCP == pCrData->caller_transfer_type) /* TCP的情况下，直接调用TSU转发接口，返回值是TSU的发送端口号 */
            {
                /* 通知TSU开始转发码流 */
                i = notify_tsu_add_transfer_task(pCrData, pCrData->callee_service_type, pCrData->callee_stream_type);

                if (i > 0)
                {
                    pCrData->tsu_send_port = i;
                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_invite_video_route_response_msg_proc() tsu_send_port=%d \r\n", pCrData->tsu_send_port);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_route_response_msg_proc() tsu_send_port=%d \r\n", pCrData->tsu_send_port);
                }
            }
            else
            {
                //发送端口号从新获取
                /* 获取TSU 发送端口号 */
                send_port = get_send_port_by_tsu_resource(pCrData->tsu_ip);

                if (send_port <= 0)
                {
                    SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, tsu_ip=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"获取TSU的发送端口号失败", pCrData->tsu_ip);
                    EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video requests from front end devices failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s, tsu_ip=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Access TSU send port number failed", pCrData->tsu_ip);

                    /* 回应消息给被叫 */
                    i = SIP_SendAck(ua_dialog_index);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                    i = SIP_SendBye(ua_dialog_index);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                    /* 回应消息给主叫 */
                    memset(strErrorCode, 0, 32);
                    snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_TSU_GET_SEND_PORT_ERROR);
                    SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
                    //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Get TSU Send Port Error");

                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_route_response_msg_proc() exit---: Get TSU Send Port Error:tsu_ip=%s \r\n", pCrData->tsu_ip);
                    return EV9000_CMS_ERR_TSU_GET_SEND_PORT_ERROR;
                }

                pCrData->tsu_send_port = send_port;

                /* 通知TSU开始转发码流 */
                i = notify_tsu_add_transfer_task(pCrData, pCrData->callee_service_type, pCrData->callee_stream_type);
            }
        }

        if (i < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_route_response_msg_proc() exit---: notify_tsu_add_transfer_task Error: TSU IP=%s, i=%d \r\n", pCrData->tsu_ip, i);
            SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, TSU IP=%s, iRet=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"通知TSU添加转发任务失败", pCrData->tsu_ip, i);
            EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video requests from front end devices failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s, TSU IP=%s, iRet=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Notify TSU to add forwarding task failed", pCrData->tsu_ip, i);

            /* 回应消息给被叫 */
            i = SIP_SendAck(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            i = SIP_SendBye(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            /* 回应消息给主叫 */
            i = SIP_SendBye(pCrData->caller_ua_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() SIP_SendBye:caller_ua_index=%d, i=%d \r\n", pCrData->caller_ua_index, i);
            return EV9000_CMS_ERR_TSU_NOTIFY_ADD_TRANSFER_ERROR;
        }
        else
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, INVITE回应消息处理:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 通知TSU添加转发任务成功, TSU IP=%s, task_id=%s, iRet=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, pCrData->tsu_ip, pCrData->task_id, i);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "INVITE response message processing for real-time video requests from front end devices:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, Notify the TSU add forward task successfully, TSU IP=%s, task_id=%s, iRet=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, pCrData->tsu_ip, pCrData->task_id, i);
        }

        /* 组建本地SDP信息*/
        sdp_tsu_ip = get_cr_sdp_tsu_ip(pCrData, pCrData->caller_server_ip_ethname);

        if (NULL == sdp_tsu_ip)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_route_response_msg_proc() exit---: Get Caller TSU SDP IP Error:callee_server_ip_ethname=%s\r\n", pCrData->caller_server_ip_ethname);
            SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, callee_server_ip_ethname=%s, iRet=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"获取主叫侧的SDP消息中的TSU的IP地址失败", pCrData->caller_server_ip_ethname, i);
            EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video requests from front end devices failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s, callee_server_ip_ethname=%s, iRet=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)" Access TSU IP address from calling side SDP message failed.", pCrData->caller_server_ip_ethname, i);

            /* 通知TSU停止转发码流 */
            i = notify_tsu_delete_transfer_task(pCrData->tsu_ip, pCrData->task_id);

            /* 回应消息给被叫 */
            i = SIP_SendAck(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            i = SIP_SendBye(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            /* 回应消息给主叫 */
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_TSU_GET_CALLER_TSU_IP_ERROR);
            SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
            //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Modify SDP S Name Error");

            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_route_response_msg_proc() exit---: Get sdp_tsu_ip Error \r\n");

            return EV9000_CMS_ERR_TSU_GET_CALLER_TSU_IP_ERROR;
        }

        /* 修改SDP中的S Name */
        i = ModifySDPSName(pRemoteSDP, pCrData->call_type);

        if (i != 0)
        {
            SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"修改SDP中的S Name失败");
            EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video requests from front end devices failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Modify S name in SDP failed.");

            /* 通知TSU停止转发码流 */
            i = notify_tsu_delete_transfer_task(pCrData->tsu_ip, pCrData->task_id);

            /* 回应消息给被叫 */
            i = SIP_SendAck(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            i = SIP_SendBye(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            /* 回应消息给主叫 */
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_SDP_MODIFY_S_NAME_ERROR);
            SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
            //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Modify SDP S Name Error");

            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_route_response_msg_proc() exit---: Modify SDP S Name Error \r\n");
            return EV9000_CMS_ERR_SDP_MODIFY_S_NAME_ERROR;
        }

        /* 修改SDP中的ip地址和端口号*/
        i = ModifySDPIPAndPort(pRemoteSDP, sdp_tsu_ip, pCrData->tsu_send_port);

        if (i != 0)
        {
            SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"修改SDP中的IP和端口号失败");
            EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video requests from front end devices failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Modify IP and port number in SDP failed.");

            /* 通知TSU停止转发码流 */
            i = notify_tsu_delete_transfer_task(pCrData->tsu_ip, pCrData->task_id);

            /* 回应消息给被叫 */
            i = SIP_SendAck(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            i = SIP_SendBye(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            /* 回应消息给主叫 */
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_SDP_MODIFY_IP_ERROR);
            SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
            //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Modify SDP IP And Addr Error");

            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_route_response_msg_proc() exit---: Modify SDP IP And Addr Error \r\n");
            return EV9000_CMS_ERR_SDP_MODIFY_IP_ERROR;
        }

        /* 修改SDP中的协议传输类型 */
        if (pCrData->caller_transfer_type != pCrData->callee_transfer_type)
        {
            if (TRANSFER_PROTOCOL_TCP == pCrData->caller_transfer_type)
            {
                i = ModifySDPTransProtocol(pRemoteSDP, 1);
            }
            else
            {
                i = ModifySDPTransProtocol(pRemoteSDP, 0);
            }

            if (i != 0)
            {
                SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"修改SDP中的协议传输类型失败");
                EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video requests from front end devices failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Modify the protocol type in SDP failed.");

                /* 通知TSU停止转发码流 */
                i = notify_tsu_delete_transfer_task(pCrData->tsu_ip, pCrData->task_id);

                /* 回应消息给被叫 */
                i = SIP_SendAck(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                i = SIP_SendBye(ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

                /* 回应消息给主叫 */
                memset(strErrorCode, 0, 32);
                snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_SDP_MODIFY_PROTOCOL_ERROR);
                SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
                //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Modify SDP Protocol Error");

                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_route_response_msg_proc() exit---: Modify SDP Protocol Error \r\n");
                return EV9000_CMS_ERR_SDP_MODIFY_PROTOCOL_ERROR;
            }
        }

        /* 去除SDP中的ONVIF URL，级联之间不能用RTSP */
        if (NULL != pRemoteSDP->u_uri)
        {
            osip_free(pRemoteSDP->u_uri);
            pRemoteSDP->u_uri = NULL;
        }
    }

    /* 接收主叫方的呼叫*/
    i = SIP_AcceptInvite(pCrData->caller_ua_index, pRemoteSDP);

    if (i != 0)
    {
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时视频请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"接收客户端的INVITE消息失败");
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "INVITE response message processing for real-time video requests from front end devices failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Failed to receive INVITE message from the client.");

        if (!g_LocalMediaTransferFlag)
        {
            /* 如果是跨级CMS的点位并且不需要本级TSU转发码流，直接转发消息 */
        }
        else
        {
            /* 通知TSU停止转发码流 */
            i = notify_tsu_delete_transfer_task(pCrData->tsu_ip, pCrData->task_id);
        }

        /* 回应消息给被叫 */
        i = SIP_SendAck(ua_dialog_index);
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

        i = SIP_SendBye(ua_dialog_index);
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

        /* 回应消息给主叫 */
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_ACCEPT_ERROR);
        SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
        //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Accept Invite Error");

        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_video_route_response_msg_proc() exit---: Accept Invite Error \r\n");
        return EV9000_CMS_ERR_INVITE_ACCEPT_ERROR;
    }

    if (!g_LocalMediaTransferFlag)
    {
        /* 如果是跨级CMS的点位并且不需要本级TSU转发码流，直接转发消息 */
        i = SIP_SendAck(ua_dialog_index);
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);
    }
    else
    {
        if (pCrData->call_type == CALL_TYPE_RECORD_PLAY || pCrData->call_type == CALL_TYPE_DOWNLOAD) /* 下级CMS 过来的 */
        {
            i = SIP_SendAck(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);
        }
        else
        {
            /* 加入待发送ACK 消息队列 */
            if (ua_dialog_index == pCrData->caller_ua_index)
            {
                i = ack_send_use(cr_pos, ua_dialog_index, -1);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() ack_send_use:cr_pos=%d, caller_ua_index=%d \r\n", cr_pos, ua_dialog_index);
                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, INVITE回应消息处理, 添加等待TSU通知任务创建结果消息处理结果事件, 等待发送ACK消息:cr_pos=%d, caller_ua_index=%d, iRet=%d", cr_pos, ua_dialog_index, i);
            }
            else if (ua_dialog_index == pCrData->callee_ua_index)
            {
                i = ack_send_use(cr_pos, -1, ua_dialog_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_video_route_response_msg_proc() ack_send_use:cr_pos=%d, callee_ua_index=%d \r\n", cr_pos, ua_dialog_index);
                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, INVITE回应消息处理, 添加等待TSU通知任务创建结果消息处理结果事件, 等待发送ACK消息:cr_pos=%d, callee_ua_index=%d, iRet=%d", cr_pos, ua_dialog_index, i);
            }
        }
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, INVITE回应消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "INVITE response message processing for real-time video requests from front end devices successfully:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s,", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id);
    return 0;
}

/*****************************************************************************
 函 数 名  : device_invite_audio_response_msg_proc
 功能描述  : 设备收到Invite响应的处理
 输入参数  : int cr_pos
             int ua_dialog_index
             cr_t* pCrData
             sdp_message_t* pRemoteSDP
             GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年8月14日 星期三
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_invite_audio_response_msg_proc(int cr_pos, int ua_dialog_index, cr_t* pCrData, sdp_message_t* pRemoteSDP, GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo)
{
    int i = 0;
    int recv_port = 0;
    char* sdp_tsu_ip = NULL;
    char strErrorCode[32] = {0};

    if (!g_LocalMediaTransferFlag
        && EV9000_DEVICETYPE_SIPSERVER == pCrData->callee_gb_device_type)
    {
        /* 如果是跨级CMS的点位并且不需要本级TSU转发码流，直接转发消息 */
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时音频对讲请求, INVITE回应消息处理:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 媒体流不经过本级转发, 直接转发消息到媒体流请求方", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "INVITE response message processing for real-time audio request from front end device:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, Media stream without forward at the corresponding level, the forward message directly to the requesting party media flow", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id);
    }
    else
    {
        /* 获取TSU 音频接收端口号 */
        recv_port = get_tsu_audio_recv_port(pCrData->tsu_ip);

        if (recv_port <= 0)
        {
            SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时音频对讲请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, tsu_ip=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"获取TSU的接收端口号失败", pCrData->tsu_ip);
            EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Real time audio intercom request from front end device: INVITE response message process failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s, tsu_ip=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Access receive port number of TSU failed.", pCrData->tsu_ip);

            /* 回应消息给被叫 */
            i = SIP_SendAck(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_audio_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            i = SIP_SendBye(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_audio_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            /* 回应消息给主叫 */
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_TSU_GET_RECV_PORT_ERROR);
            SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
            //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Get TSU Send Port rror");

            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_audio_response_msg_proc() exit---: Get TSU Send Port Error:tsu_ip=%s \r\n", pCrData->tsu_ip);
            return EV9000_CMS_ERR_TSU_GET_RECV_PORT_ERROR;
        }

        pCrData->tsu_recv_port = recv_port;

        /* 组建本地SDP信息*/
        sdp_tsu_ip = get_cr_sdp_tsu_ip(pCrData, pCrData->caller_server_ip_ethname);

        if (NULL == sdp_tsu_ip)
        {
            SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时音频对讲请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, callee_server_ip_ethname=%s, iRet=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"获取主叫侧的SDP消息中的TSU的IP地址失败", pCrData->caller_server_ip_ethname, i);
            EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Real time audio intercom request from front end device: INVITE response message process failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s, callee_server_ip_ethname=%s, iRet=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Access IP address from caller side SDP message", pCrData->caller_server_ip_ethname, i);

            /* 回应消息给被叫 */
            i = SIP_SendAck(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_audio_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            i = SIP_SendBye(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_audio_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            /* 回应消息给主叫 */
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_TSU_GET_CALLER_TSU_IP_ERROR);
            SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
            //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Get Caller TSU SDP IP Error");

            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_audio_response_msg_proc() exit---: Get Caller TSU SDP IP Error \r\n");
            return EV9000_CMS_ERR_TSU_GET_CALLER_TSU_IP_ERROR;
        }

        /* 修改SDP中的ip地址和端口号*/
        i = ModifySDPIPAndPort(pRemoteSDP, sdp_tsu_ip, pCrData->tsu_recv_port);

        if (i != 0)
        {
            SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时音频对讲请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"修改SDP中的IP和端口号失败");
            EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Real time audio intercom request from front end device: INVITE response message process failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Edit IP and port number in SDP failed");

            /* 回应消息给被叫 */
            i = SIP_SendAck(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_audio_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            i = SIP_SendBye(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_audio_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            /* 回应消息给主叫 */
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_SDP_MODIFY_IP_ERROR);
            SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
            //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Modify SDP Info Error");

            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_audio_response_msg_proc() exit---: Modify SDP Info Error \r\n");
            return EV9000_CMS_ERR_SDP_MODIFY_IP_ERROR;
        }
    }

    /* 接收主叫方的呼叫*/
    i = SIP_AcceptInvite(pCrData->caller_ua_index, pRemoteSDP);

    if (i != 0)
    {
        SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时音频对讲请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"接收客户端的INVITE消息失败");
        EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Real time audio intercom request from front end device: INVITE response message process failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Receive INVITE message from client failed");

        /* 回应消息给被叫 */
        i = SIP_SendAck(ua_dialog_index);
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_audio_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

        i = SIP_SendBye(ua_dialog_index);
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_audio_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

        /* 回应消息给主叫 */
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_INVITE_ACCEPT_ERROR);
        SIP_AnswerToInvite(pCrData->caller_ua_index, 503, strErrorCode);
        //SIP_AnswerToInvite(pCrData->caller_ua_index, 503, (char*)"Accept Invite Error");

        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_audio_response_msg_proc() exit---: Accept Invite Error \r\n");
        return EV9000_CMS_ERR_INVITE_ACCEPT_ERROR;
    }

    if (!g_LocalMediaTransferFlag
        && EV9000_DEVICETYPE_SIPSERVER == pCrData->callee_gb_device_type)
    {
        /* 如果是跨级CMS的点位并且不需要本级TSU转发码流，直接转发消息 */
    }
    else
    {
        /* 通知TSU开始转发音频流 */
        i = notify_tsu_add_audio_transfer_task(pCrData);

        if (i < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_invite_audio_response_msg_proc() exit---: notify_tsu_add_audio_transfer_task Error: TSU IP=%s, i=%d \r\n", pCrData->tsu_ip, i);
            SystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的实时音频对讲请求, INVITE回应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, TSU IP=%s, iRet=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"通知TSU添加转发任务失败", pCrData->tsu_ip, i);
            EnSystemLog(EV9000_CMS_VIDEO_REQUEST_ERROR, EV9000_LOG_LEVEL_ERROR, "Real time audio intercom request from front end device: INVITE response message process failed:front-end device ID=%s, IPaddress=%s, port number=%d, logic device ID=%s, cause=%s, TSU IP=%s, iRet=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, pCrData->callee_id, (char*)"Notify TSU to add forwarding task failed", pCrData->tsu_ip, i);

            /* 回应消息给被叫 */
            i = SIP_SendAck(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_audio_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            i = SIP_SendBye(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_audio_response_msg_proc() SIP_SendBye:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

            /* 回应消息给主叫 */
            i = SIP_SendBye(pCrData->caller_ua_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_audio_response_msg_proc() SIP_SendBye:caller_ua_index=%d, i=%d \r\n", pCrData->caller_ua_index, i);

            return EV9000_CMS_ERR_TSU_NOTIFY_ADD_TRANSFER_ERROR;
        }
    }

    i = SIP_SendAck(ua_dialog_index);
    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_invite_audio_response_msg_proc() SIP_SendAck:ua_dialog_index=%d, i=%d \r\n", ua_dialog_index, i);

    return 0;
}

/*****************************************************************************
 函 数 名  : device_cancel_msg_proc
 功能描述  : 收到前端设备的取消消息处理
 输入参数  : int cr_pos
             int ua_dialog_index
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2016年1月5日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_cancel_msg_proc(int cr_pos, int ua_dialog_index)
{
    int i = 0;
    cr_t* pCrData = NULL;

    if (cr_pos < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_cancel_msg_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* Cancel消息由客户端在发送Invite之后没有收到最终应答前发出 */
    pCrData = call_record_get(cr_pos);

    if (NULL == pCrData)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_cancel_msg_proc() exit---: Get Call Record Error:cr_pos=%d \r\n", cr_pos);
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, 收到CANCEL取消处理, 实时视频关闭:前端设备ID=%s, IP地址=%s, 逻辑设备ID=%s, IP地址=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Real-time video requests from front-end devices, receive cancel message processing:User ID=%s, User IP=%s,Logic Device ID=%s, IP Address=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);

    /* 2、如果是实时视频业务，服务器需要将Cancel 消息转发给被叫方 */
    if (pCrData->callee_ua_index >= 0)
    {
        i = SIP_SendCancel(pCrData->callee_ua_index);
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_cancel_msg_proc() SIP_SendCancel:callee_ua_index=%d, i=%d \r\n", pCrData->callee_ua_index, i);
    }

    /* 3、移除呼叫记录信息 */
    i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
    i = call_record_remove(cr_pos);

    if (0 != i)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_cancel_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_cancel_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_ack_msg_proc
 功能描述  : 收到前端设备ack消息处理
 输入参数  : int cr_pos
             int ua_dialog_index
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2016年1月5日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_ack_msg_proc(int cr_pos, int ua_dialog_index)
{
    int i = 0;
    cr_t* pCrData = NULL;

    if (cr_pos < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_ack_msg_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* Ack消息由上级CMS 收到200后发出 */
    pCrData = call_record_get(cr_pos);

    if (NULL == pCrData)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_ack_msg_proc() exit---: Get Call Record Error:cr_pos=%d \r\n", cr_pos);
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, 收到ACK消息处理:前端设备ID=%s, IP地址=%s, 逻辑设备ID=%s, IP地址=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Real-time video requests from front-end devices, receive ack message processing:User ID=%s, User IP=%s,Logic Device ID=%s, IP Address=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);
    /* 2、如果是实时视频业务，服务器需要将ack消息转发给被叫方 */
    /*if (pCrData->callee_ua_index >= 0) //收到前端响应的时候直接回复了ACK,所以这个地方收到客户端的ACK不需要再转发给前端
    {
        i = SIP_SendAck(pCrData->callee_ua_index);
    }*/


    return i;
}

/*****************************************************************************
 函 数 名  : device_bye_msg_proc
 功能描述  : 设备回应Bye消息的处理
 输入参数  : int cr_pos
             int ua_dialog_index
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年8月15日 星期四
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_bye_msg_proc(int cr_pos, int ua_dialog_index)
{
    int i = 0;
    cr_t* pCrData = NULL;
    GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo = NULL;

    if (cr_pos < 0)
    {
        SIP_AnswerToBye(ua_dialog_index, 481, NULL);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_msg_proc() exit---: Param Error \r\n");
        return -1;
    }

    pCrData = call_record_get(cr_pos);

    if (NULL == pCrData)
    {
        SIP_AnswerToBye(ua_dialog_index, 481, NULL);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_msg_proc() exit---: Get Call Record Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频, 收到BYE关闭消息处理:前端设备ID=%s, IP地址=%s, 逻辑设备ID=%s, IP地址=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Real-time video requests from front-end devices, receive bye message processing:User ID=%s, User IP=%s,Logic Device ID=%s, IP Address=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);

    /* 查找逻辑设备信息 */
    pCalleeGBLogicDeviceInfo = GBLogicDevice_info_find(pCrData->callee_id);

    if (NULL == pCalleeGBLogicDeviceInfo)
    {
        SIP_AnswerToBye(ua_dialog_index, 503, NULL);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_msg_proc() exit---: Get Callee GBLogic Device Info Error \r\n");
        return -1;
    }

    if (CALL_TYPE_AUDIO == pCrData->call_type)
    {
        i = device_bye_audio_msg_proc(cr_pos, ua_dialog_index, pCrData, pCalleeGBLogicDeviceInfo);
    }
    else
    {
        i = device_bye_video_msg_proc(cr_pos, ua_dialog_index, pCrData, pCalleeGBLogicDeviceInfo);
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_bye_video_msg_proc
 功能描述  : 设备回应Bye消息的处理
 输入参数  : int cr_pos
             int ua_dialog_index
             cr_t* pCrData
             GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年8月15日 星期四
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_bye_video_msg_proc(int cr_pos, int ua_dialog_index, cr_t* pCrData, GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo)
{
    int i = 0;

    /* 根据逻辑设备所属域进行判断，决定消息走向 */
    if (1 == pCalleeGBLogicDeviceInfo->other_realm)
    {
        i = device_bye_route_video_msg_proc(cr_pos, ua_dialog_index, pCrData, pCalleeGBLogicDeviceInfo);
    }
    else
    {
        i = device_bye_sub_video_msg_proc(cr_pos, ua_dialog_index, pCrData, pCalleeGBLogicDeviceInfo);
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_bye_sub_video_msg_proc
 功能描述  : 设备回应Bye消息的处理
 输入参数  : int cr_pos
             int ua_dialog_index
             cr_t* pCrData
             GBDevice_info_t* pCalleeGBDeviceInfo
             GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年8月15日 星期四
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_bye_sub_video_msg_proc(int cr_pos, int ua_dialog_index, cr_t* pCrData, GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo)
{
    int i = 0;
    int other_cr_pos = -1;
    cr_t* pOtherCrData = NULL;
    GBDevice_info_t* pCalleeGBDeviceInfo = NULL;
    GBDevice_info_t* pCalleeCmsGBDeviceInfo = NULL;

    if (NULL == pCrData)
    {
        SIP_AnswerToBye(ua_dialog_index, 481, NULL);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_sub_video_msg_proc() exit---: Get Call Record Error \r\n");
        return -1;
    }

    if (NULL == pCalleeGBLogicDeviceInfo)
    {
        SIP_AnswerToBye(ua_dialog_index, 503, NULL);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_sub_video_msg_proc() exit---: Get Callee GBLogic Device Info Error:callee_id=%s \r\n", pCrData->callee_id);
        return -1;
    }

    /* 查找对应的物理设备 */
    pCalleeGBDeviceInfo = GBDevice_info_get_by_stream_type(pCalleeGBLogicDeviceInfo, pCrData->callee_stream_type);

    if (NULL == pCalleeGBDeviceInfo)
    {
        /* 如果是智能分析流，可能是下级平台的点位，这个时候需要再查找一下主流设备 */
        if (EV9000_STREAM_TYPE_INTELLIGENCE == pCrData->callee_stream_type)
        {
            pCalleeCmsGBDeviceInfo = GBDevice_info_get_by_stream_type(pCalleeGBLogicDeviceInfo, EV9000_STREAM_TYPE_MASTER);

            if (NULL != pCalleeCmsGBDeviceInfo
                && EV9000_DEVICETYPE_SIPSERVER == pCalleeCmsGBDeviceInfo->device_type)
            {
                pCalleeGBDeviceInfo = pCalleeCmsGBDeviceInfo;
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_bye_sub_video_msg_proc() CalleeCmsGBDevice: id=%s, ip=%s \r\n", pCalleeCmsGBDeviceInfo->device_id, pCalleeCmsGBDeviceInfo->login_ip);
            }
        }
    }

    if (NULL == pCalleeGBDeviceInfo)
    {
        SIP_AnswerToBye(ua_dialog_index, 503, NULL);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_sub_video_msg_proc() exit---: Get Callee GBDevice Info Error \r\n");
        return -1;
    }

    /* Bye 消息可能是前端DC 发送的也可能是源发送的*/
    if (pCrData->callee_ua_index == ua_dialog_index)    /* 源端发送的Bye */
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, 收到前端BYE消息处理, 实时视频关闭:前端设备ID=%s, IP地址=%s, 逻辑设备ID=%s, IP地址=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Real-time video requests from front-end devices, receive front-end bye message processing, close real-time video:front-end device ID=%s, IP=%s, logic device ID=%s, IP=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);

        /* 直接发送200 响应消息给被叫侧 */
        SIP_AnswerToBye(ua_dialog_index, 200, NULL);

        /* 通知TSU停止接收码流*/
        if ((CALL_TYPE_RECORD_PLAY == pCrData->call_type)
            || (CALL_TYPE_DOWNLOAD == pCrData->call_type))
        {
            /* 可能TSU中的缓存还没有放完，这个时候不能发送Bye 给客户端 */
            i = notify_tsu_delete_replay_task(pCrData->tsu_ip, pCrData->task_id);

            if (i < 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_bye_sub_video_msg_proc() notify_tsu_delete_replay_task Error:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_sub_video_msg_proc() notify_tsu_delete_replay_task OK:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }

            /* 如果是下级录像查看或者前端录像的情况下，需要转发Bye上级或者客户端 */
            if (pCalleeGBDeviceInfo->device_type == EV9000_DEVICETYPE_SIPSERVER) /* 下级CMS 的录像 */
            {
                /* 发送Bye 给主叫侧 */
                i = SIP_SendBye(pCrData->caller_ua_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_sub_video_msg_proc() SIP_SendBye To Caller:caller_ua_index=%d, i=%d \r\n", pCrData->caller_ua_index, i);
            }
            else if (pCalleeGBLogicDeviceInfo->record_type == 1) /* 调看前端录像 */
            {
                /* 发送Bye 给主叫侧 */
                i = SIP_SendBye(pCrData->caller_ua_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_sub_video_msg_proc() SIP_SendBye To Caller:caller_ua_index=%d, i=%d \r\n", pCrData->caller_ua_index, i);
            }
        }
        else
        {
            i = notify_tsu_delete_transfer_task(pCrData->tsu_ip, pCrData->task_id);

            if (i < 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_bye_sub_video_msg_proc() notify_tsu_delete_transfer_task Error:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_sub_video_msg_proc() notify_tsu_delete_transfer_task OK:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }

            /* 发送Bye 给所有其他业务主叫侧用户*/
            i = send_bye_to_all_other_caller_by_callee_id_and_streamtype(pCrData->callee_id, pCrData->callee_stream_type, cr_pos);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_sub_video_msg_proc() send_bye_to_all_other_caller_by_callee_id_and_streamtype:callee_id=%s, callee_stream_type=%d, cr_pos=%d, i=%d \r\n", pCrData->callee_id, pCrData->callee_stream_type, cr_pos, i);

            /* 发送Bye 给主叫侧 */
            i = SIP_SendBye(pCrData->caller_ua_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_sub_video_msg_proc() SIP_SendBye To Caller:caller_ua_index=%d, i=%d \r\n", pCrData->caller_ua_index, i);
        }

        /* 移除呼叫记录信息 */
        i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
        i = call_record_remove(cr_pos);

        if (0 != i)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_sub_video_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_bye_sub_video_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
        }

        return 0;
    }
    else if (pCrData->caller_ua_index == ua_dialog_index) /* 主叫发送的Bye */
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, 收到请求方BYE消息处理, 实时视频关闭:前端设备ID=%s, IP地址=%s, 逻辑设备ID=%s, IP地址=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Real-time video requests from front-end devices, receive requester bye message processing, close real-time video:front-end device ID=%s, IP=%s, logic device ID=%s, IP=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);

        /* 通知TSU停止接收码流*/
        if ((CALL_TYPE_RECORD_PLAY == pCrData->call_type)
            || (CALL_TYPE_DOWNLOAD == pCrData->call_type))
        {
            i = notify_tsu_delete_replay_task(pCrData->tsu_ip, pCrData->task_id);

            if (i < 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_bye_sub_video_msg_proc() notify_tsu_delete_replay_task Error:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_sub_video_msg_proc() notify_tsu_delete_replay_task OK:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }

            /* 如果是下级录像查看或者前端录像的情况下，需要转发Bye到下级或者前端 */
            if (pCalleeGBDeviceInfo->device_type == EV9000_DEVICETYPE_SIPSERVER) /* 下级CMS 的录像 */
            {
                /*发送Bye 给被叫侧 */
                i = SIP_SendBye(pCrData->callee_ua_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_sub_video_msg_proc() SIP_SendBye To Callee:callee_ua_index=%d, i=%d \r\n", pCrData->callee_ua_index, i);
            }
            else if (pCalleeGBLogicDeviceInfo->record_type == 1) /* 调看前端录像 */
            {
                /*发送Bye 给被叫侧 */
                i = SIP_SendBye(pCrData->callee_ua_index);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_sub_video_msg_proc() SIP_SendBye To Callee:callee_ua_index=%d, i=%d \r\n", pCrData->callee_ua_index, i);
            }
        }
        else
        {
            i = notify_tsu_delete_transfer_task(pCrData->tsu_ip, pCrData->task_id);

            if (i < 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_bye_sub_video_msg_proc() notify_tsu_delete_transfer_task Error:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_sub_video_msg_proc() notify_tsu_delete_transfer_task OK:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }

            /* 看是否有前端连接 */
            if (pCrData->callee_ua_index >= 0)
            {
                /* 查看是否有其他客户端业务 */
                other_cr_pos = is_GBLogic_device_has_other_service(pCrData->callee_id, pCrData->callee_stream_type, cr_pos);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_sub_video_msg_proc() is_GBLogic_device_has_other_service:other_cr_pos=%d \r\n", other_cr_pos);

                if (other_cr_pos < 0) /* 没有其他业务 */
                {
                    /*发送Bye 给被叫侧 */
                    i = SIP_SendBye(pCrData->callee_ua_index);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_sub_video_msg_proc() SIP_SendBye To Callee:callee_ua_index=%d, i=%d \r\n", pCrData->callee_ua_index, i);
                }
                else
                {
                    pOtherCrData = call_record_get(other_cr_pos);

                    if (NULL != pOtherCrData)
                    {
                        pOtherCrData->callee_ua_index = pCrData->callee_ua_index; /* 将前端的会话句柄拷贝到下个业务 */
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_sub_video_msg_proc() callee_ua_index=%d copy from %d to %d \r\n", pOtherCrData->callee_ua_index, cr_pos, other_cr_pos);
                    }
                }
            }
        }

        /* 直接发送200 响应消息主叫侧 */
        SIP_AnswerToBye(ua_dialog_index, 200, NULL);

        /* 移除呼叫记录信息 */
        i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
        i = call_record_remove(cr_pos);

        if (0 != i)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_sub_video_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_bye_sub_video_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
        }

        return 0;
    }

    /* 移除呼叫记录信息 */
    i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
    i = call_record_remove(cr_pos);

    if (0 != i)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_sub_video_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_bye_sub_video_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
    }

    SIP_AnswerToBye(ua_dialog_index, 481, NULL);
    return -1;
}

/*****************************************************************************
 函 数 名  : device_bye_route_video_msg_proc
 功能描述  : 设备回应Bye消息的处理
 输入参数  : int cr_pos
             int ua_dialog_index
             cr_t* pCrData
             GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年8月15日 星期四
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_bye_route_video_msg_proc(int cr_pos, int ua_dialog_index, cr_t* pCrData, GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo)
{
    int i = 0;
    int other_cr_pos = -1;
    cr_t* pOtherCrData = NULL;

    if (NULL == pCrData)
    {
        SIP_AnswerToBye(ua_dialog_index, 481, NULL);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_route_video_msg_proc() exit---: Get Call Record Error \r\n");
        return -1;
    }

    if (NULL == pCalleeGBLogicDeviceInfo)
    {
        SIP_AnswerToBye(ua_dialog_index, 503, NULL);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_route_video_msg_proc() exit---: Get Callee GBLogic Device Info Error:callee_id=%s \r\n", pCrData->callee_id);
        return -1;
    }

    /* Bye 消息可能是前端DC 发送的也可能是源发送的*/
    if (pCrData->callee_ua_index == ua_dialog_index)    /* 源端发送的Bye */
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, 收到前端BYE消息处理, 实时视频关闭:前端设备ID=%s, IP地址=%s, 逻辑设备ID=%s, IP地址=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Real-time video requests from front-end devices, receive requester bye message processing, close real-time video:front-end device ID=%s, IP=%s, logic device ID=%s, IP=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);
        /* 直接发送200 响应消息给被叫侧 */
        SIP_AnswerToBye(ua_dialog_index, 200, NULL);

        /* 通知TSU停止接收码流*/
        if ((CALL_TYPE_RECORD_PLAY == pCrData->call_type)
            || (CALL_TYPE_DOWNLOAD == pCrData->call_type))
        {
            /* 可能TSU中的缓存还没有放完，这个时候不能发送Bye 给客户端 */
            i = notify_tsu_delete_replay_task(pCrData->tsu_ip, pCrData->task_id);

            if (i < 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_bye_route_video_msg_proc() notify_tsu_delete_replay_task Error:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_route_video_msg_proc() notify_tsu_delete_replay_task OK:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }

            /* 发送Bye 给主叫侧 */
            i = SIP_SendBye(pCrData->caller_ua_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_route_video_msg_proc() SIP_SendBye To Caller:caller_ua_index=%d, i=%d \r\n", pCrData->caller_ua_index, i);
        }
        else
        {
            i = notify_tsu_delete_transfer_task(pCrData->tsu_ip, pCrData->task_id);

            if (i < 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_bye_route_video_msg_proc() notify_tsu_delete_transfer_task Error:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_route_video_msg_proc() notify_tsu_delete_transfer_task OK:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }

            /* 发送Bye 给所有其他业务主叫侧用户*/
            i = send_bye_to_all_other_caller_by_callee_id_and_streamtype(pCrData->callee_id, pCrData->callee_stream_type, cr_pos);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_route_video_msg_proc() send_bye_to_all_other_caller_by_callee_id_and_streamtype:callee_id=%s, callee_stream_type=%d, cr_pos=%d, i=%d \r\n", pCrData->callee_id, pCrData->callee_stream_type, cr_pos, i);

            /* 发送Bye 给主叫侧 */
            i = SIP_SendBye(pCrData->caller_ua_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_route_video_msg_proc() SIP_SendBye To Caller:caller_ua_index=%d, i=%d \r\n", pCrData->caller_ua_index, i);
        }

        /* 移除呼叫记录信息 */
        i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
        i = call_record_remove(cr_pos);

        if (0 != i)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_sub_video_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_bye_sub_video_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
        }

        return 0;
    }
    else if (pCrData->caller_ua_index == ua_dialog_index) /* 主叫发送的Bye */
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, 收到请求方BYE消息处理, 实时视频关闭:前端设备ID=%s, IP地址=%s, 逻辑设备ID=%s, IP地址=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Real-time video requests from front-end devices, receive requester bye message processing, close real-time video:front-end device ID=%s, IP=%s, logic device ID=%s, IP=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);

        /* 通知TSU停止接收码流*/
        if ((CALL_TYPE_RECORD_PLAY == pCrData->call_type)
            || (CALL_TYPE_DOWNLOAD == pCrData->call_type))
        {
            i = notify_tsu_delete_replay_task(pCrData->tsu_ip, pCrData->task_id);

            if (i < 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_bye_route_video_msg_proc() notify_tsu_delete_replay_task Error:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_route_video_msg_proc() notify_tsu_delete_replay_task OK:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }

            /*发送Bye 给被叫侧 */
            i = SIP_SendBye(pCrData->callee_ua_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_route_video_msg_proc() SIP_SendBye To Callee:callee_ua_index=%d, i=%d \r\n", pCrData->callee_ua_index, i);
        }
        else
        {
            i = notify_tsu_delete_transfer_task(pCrData->tsu_ip, pCrData->task_id);

            if (i < 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_bye_route_video_msg_proc() notify_tsu_delete_transfer_task Error:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_route_video_msg_proc() notify_tsu_delete_transfer_task OK:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }

            /* 看是否有前端连接 */
            if (pCrData->callee_ua_index >= 0)
            {
                /* 查看是否有其他客户端业务 */
                other_cr_pos = is_GBLogic_device_has_other_service(pCrData->callee_id, pCrData->callee_stream_type, cr_pos);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_route_video_msg_proc() is_GBLogic_device_has_other_service:other_cr_pos=%d \r\n", other_cr_pos);

                if (other_cr_pos < 0) /* 没有其他业务 */
                {
                    /*发送Bye 给被叫侧 */
                    i = SIP_SendBye(pCrData->callee_ua_index);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_route_video_msg_proc() SIP_SendBye To Callee:callee_ua_index=%d, i=%d \r\n", pCrData->callee_ua_index, i);
                }
                else
                {
                    pOtherCrData = call_record_get(other_cr_pos);

                    if (NULL != pOtherCrData)
                    {
                        pOtherCrData->callee_ua_index = pCrData->callee_ua_index; /* 将前端的会话句柄拷贝到下个业务 */
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_route_video_msg_proc() callee_ua_index=%d copy from %d to %d \r\n", pOtherCrData->callee_ua_index, cr_pos, other_cr_pos);
                    }
                }
            }
        }

        /* 直接发送200 响应消息主叫侧 */
        SIP_AnswerToBye(ua_dialog_index, 200, NULL);

        /* 移除呼叫记录信息 */
        i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
        i = call_record_remove(cr_pos);

        if (0 != i)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_route_video_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_bye_route_video_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
        }

        return 0;
    }

    /* 移除呼叫记录信息 */
    i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
    i = call_record_remove(cr_pos);

    if (0 != i)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_route_video_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_bye_route_video_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
    }

    SIP_AnswerToBye(ua_dialog_index, 481, NULL);
    return -1;
}

/*****************************************************************************
 函 数 名  : device_bye_audio_msg_proc
 功能描述  : 设备回应Bye消息的处理
 输入参数  : int cr_pos
             int ua_dialog_index
             cr_t* pCrData
             GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年8月15日 星期四
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_bye_audio_msg_proc(int cr_pos, int ua_dialog_index, cr_t* pCrData, GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo)
{
    int i = 0;

    if (NULL == pCrData)
    {
        SIP_AnswerToBye(ua_dialog_index, 481, NULL);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_audio_msg_proc() exit---: Get Call Record Error \r\n");
        return -1;
    }

    if (NULL == pCalleeGBLogicDeviceInfo)
    {
        SIP_AnswerToBye(ua_dialog_index, 503, NULL);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_audio_msg_proc() exit---: Get Callee GBLogic Device Info Error:callee_id=%s \r\n", pCrData->callee_id);
        return -1;
    }

    /* Bye 消息可能是前端DC 发送的也可能是源发送的*/
    if (pCrData->callee_ua_index == ua_dialog_index)    /* 源端发送的Bye */
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时音频对讲请求, 收到前端BYE消息处理, 实时视频关闭:前端设备ID=%s, IP地址=%s, 逻辑设备ID=%s, IP地址=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Real-time audio requests from front-end devices, receive requester bye message processing, close real-time video:front-end device ID=%s, IP=%s, logic device ID=%s, IP=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);

        /* 直接发送200 响应消息给被叫侧 */
        SIP_AnswerToBye(ua_dialog_index, 200, NULL);

        /* 通知TSU停止转发音频流*/
        i = notify_tsu_delete_audio_transfer_task(pCrData->tsu_ip, pCrData->caller_sdp_ip, pCrData->caller_sdp_port);

        if (i < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_bye_audio_msg_proc() notify_tsu_delete_audio_transfer_task Error:tsu_ip=%s, receive_ip=%s, receive_port=%d, i=%d \r\n", pCrData->tsu_ip, pCrData->caller_sdp_ip, pCrData->caller_sdp_port, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_audio_msg_proc() notify_tsu_delete_audio_transfer_task OK:tsu_ip=%s, receive_ip=%s, receive_port=%d, i=%d \r\n", pCrData->tsu_ip, pCrData->caller_sdp_ip, pCrData->caller_sdp_port, i);
        }

        /* 发送Bye 给主叫侧 */
        i = SIP_SendBye(pCrData->caller_ua_index);
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_audio_msg_proc() SIP_SendBye To Caller:caller_ua_index=%d, i=%d \r\n", pCrData->caller_ua_index, i);

        /* 移除呼叫记录信息 */
        i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
        i = call_record_remove(cr_pos);

        if (0 != i)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_audio_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_bye_audio_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
        }

        return 0;
    }
    else if (pCrData->caller_ua_index == ua_dialog_index) /* 主叫发送的Bye */
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时音频对讲请求, 收到请求方BYE消息处理, 实时视频关闭:前端设备ID=%s, IP地址=%s, 逻辑设备ID=%s, IP地址=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Real-time audio requests from front-end devices, receive requester bye message processing, close real-time video:front-end device ID=%s, IP=%s, logic device ID=%s, IP=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);

        /* 直接发送200 响应消息主叫侧 */
        SIP_AnswerToBye(ua_dialog_index, 200, NULL);

        /* 通知TSU停止转发音频流*/
        i = notify_tsu_delete_audio_transfer_task(pCrData->tsu_ip, pCrData->caller_sdp_ip, pCrData->caller_sdp_port);

        if (i < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_bye_audio_msg_proc() notify_tsu_delete_audio_transfer_task Error:tsu_ip=%s, receive_ip=%s, receive_port=%d, i=%d \r\n", pCrData->tsu_ip, pCrData->caller_sdp_ip, pCrData->caller_sdp_port, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_audio_msg_proc() notify_tsu_delete_audio_transfer_task OK:tsu_ip=%s, receive_ip=%s, receive_port=%d, i=%d \r\n", pCrData->tsu_ip, pCrData->caller_sdp_ip, pCrData->caller_sdp_port, i);
        }

        /*发送Bye 给被叫侧 */
        i = SIP_SendBye(pCrData->callee_ua_index);
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_bye_audio_msg_proc() SIP_SendBye To Callee:callee_ua_index=%d, i=%d \r\n", pCrData->callee_ua_index, i);

        /* 移除呼叫记录信息 */
        i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
        i = call_record_remove(cr_pos);

        if (0 != i)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_audio_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_bye_audio_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
        }

        return 0;
    }

    /* 移除呼叫记录信息 */
    i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
    i = call_record_remove(cr_pos);

    if (0 != i)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_audio_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_bye_audio_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
    }

    SIP_AnswerToBye(ua_dialog_index, 481, NULL);
    return -1;
}

/*****************************************************************************
 函 数 名  : device_bye_response_msg_proc
 功能描述  : 设备回应Bye响应的处理
 输入参数  : int cr_pos
             int ua_dialog_index
             int response_code
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年8月15日 星期四
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_bye_response_msg_proc(int cr_pos, int ua_dialog_index, int response_code)
{
    int i = 0;
    cr_t* pCrData = NULL;

    if (cr_pos < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_response_msg_proc() exit---: Param Error \r\n");
        return -1;
    }

    pCrData = call_record_get(cr_pos);

    if (NULL == pCrData)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_response_msg_proc() exit---: Get Call Record Error:cr_pos=%d \r\n", cr_pos);
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, 收到BYE响应消息处理:前端设备ID=%s, IP地址=%s, 逻辑设备ID=%s, IP地址=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Real-time video requests from front-end devices, receive requester bye message processing:front-end device ID=%s, IP=%s, logic device ID=%s, IP=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);

    /* Bye 响应消息可能是前端DC 发送的也可能是源发送的*/
    if (pCrData->callee_ua_index == ua_dialog_index)    /* 主叫发送的Bye */
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, 收到请求方BYE响应消息处理, 实时视频关闭:前端设备ID=%s, IP地址=%s, 逻辑设备ID=%s, 逻辑设备IP=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Real-time video requests from front-end devices, receive requester bye message processing, close real-time video:front-end device ID=%s, IP=%s, logic device ID=%s, IP=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);

        /* 如果是实时视频业务，服务器需要将Bye响应消息转给主叫侧 */
        if (pCrData->caller_ua_index >= 0)
        {
            SIP_AnswerToBye(pCrData->caller_ua_index, response_code, NULL);
        }
    }
    else if (pCrData->caller_ua_index == ua_dialog_index) /* 被叫端发送的Bye */
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的实时视频请求, 收到源端BYE响应消息处理, 实时视频关闭:前端设备ID=%s, IP地址=%s, 逻辑设备ID=%s, 逻辑设备IP=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Real-time video requests from front-end devices, receive requester bye message processing, close real-time video:front-end device ID=%s, IP=%s, logic device ID=%s, IP=%s", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);

        /* 如果是实时视频业务，服务器需要将Bye响应消息转给被叫侧 */
        if (pCrData->callee_ua_index >= 0)
        {
            SIP_AnswerToBye(pCrData->callee_ua_index, response_code, NULL);
        }
    }

    /* 移除呼叫记录信息 */
    i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
    i = call_record_remove(cr_pos);

    if (0 != i)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_bye_response_msg_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_bye_response_msg_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
    }

    return -1;
}

#if 1
/*****************************************************************************
 函 数 名  : device_info_msg_proc
 功能描述  : 设备Info 消息处理
 输入参数  : char* caller_id
             char* callee_id
             int dialog_index
             char* msg_body
             int msg_body_len
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月22日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_info_msg_proc(char* caller_id, char* callee_id, int dialog_index, char* msg_body, int msg_body_len)
{
    int i = 0;
    int cr_pos = -1;
    mansrtsp_t* rtsp = NULL;
    cr_t* pCrData = NULL;
    GBDevice_info_t* pCalleeGBDeviceInfo = NULL;
    GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo = NULL;
    float iScale = 0.0;
    int iLen = 0;
    int iNtp = 0;
    char tmpNtp[32] = {0};

    int iCalleeRoutePos = 0;
    route_info_t* pCalleeRouteInfo = NULL;

    if ((NULL == caller_id) || (NULL == callee_id) || (NULL == msg_body) || dialog_index < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_info_msg_proc() exit---: Param Error \r\n");
        return -1;
    }

    //处理过程

    /* 获取呼叫记录 */
    cr_pos = call_record_find_by_caller_index(dialog_index);

    if (cr_pos < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() exit---: Find Call Record Error:dialog_index=%d \r\n", dialog_index);
        return -1;
    }

    pCrData = call_record_get(cr_pos);

    if (NULL == pCrData)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() exit---: Get Call Record Error:cr_pos=%d \r\n", cr_pos);
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备历史视频回放控制处理:请求方ID=%s, IP地址=%s, 逻辑设备ID=%s, cr_pos=%d", caller_id, pCrData->caller_ip, callee_id, cr_pos);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end equipment history video playback control processing:Requster ID=%s, IP=%s, Logic Device ID=%s, cr_pos=%d", caller_id, pCrData->caller_ip, callee_id, cr_pos);

    /* 查找逻辑设备信息 */
    pCalleeGBLogicDeviceInfo = GBLogicDevice_info_find(callee_id);

    if (NULL == pCalleeGBLogicDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_info_msg_proc() exit---: Get Callee GBlogicDevice Info Error \r\n");
        return -1;
    }

    /* 根据逻辑设备所属域进行判断，决定消息走向 */
    if (1 == pCalleeGBLogicDeviceInfo->other_realm)
    {
        /* 查找上级路由信息 */
        iCalleeRoutePos = route_info_find(pCalleeGBLogicDeviceInfo->cms_id);

        if (iCalleeRoutePos >= 0)
        {
            pCalleeRouteInfo = route_info_get(iCalleeRoutePos);

            if (NULL != pCalleeRouteInfo)
            {
                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备历史视频回放控制处理, 转发到上级CMS:请求方ID=%s, IP地址=%s, 逻辑设备ID=%s, cr_pos=%d, 转发上级CMS ID=%s, IP地址=%s, 端口号=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, cr_pos, pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment history video playback control processing, forwarded to the superior CMS:requester ID=%s, IP=%s, logic device ID=%s, cr_pos=%d, superior CMS ID=%s, IP=%s, port=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, cr_pos, pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
                /* 转发消息出去 */
                i = SIP_SendInfoWithinDialog(pCrData->callee_ua_index, msg_body, msg_body_len);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() SIP_SendInfoWithinDialog Error:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() SIP_SendInfoWithinDialog OK:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                }
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() route_info_get Error:CalleeRoutePos=%d \r\n", iCalleeRoutePos);
            }
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() route_info_get Error:cms_id=%s \r\n", pCalleeGBLogicDeviceInfo->cms_id);
        }
    }
    else
    {
        /* 查找对应的物理设备 */
        pCalleeGBDeviceInfo = GBDevice_info_get_by_stream_type(pCalleeGBLogicDeviceInfo, pCrData->callee_stream_type);

        if (NULL != pCalleeGBDeviceInfo)
        {
            if (pCalleeGBDeviceInfo->device_type == EV9000_DEVICETYPE_SIPSERVER
                || pCalleeGBLogicDeviceInfo->record_type == 1) /* 下级CMS 获取前端录像*/
            {
                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备历史视频回放控制处理, 转发到前端设备:请求方ID=%s, IP地址=%s, 逻辑设备ID=%s, cr_pos=%d, 转发前端设备ID=%s, IP地址=%s, 端口号=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, cr_pos, pCalleeGBDeviceInfo->device_id, pCalleeGBDeviceInfo->login_ip, pCalleeGBDeviceInfo->login_port);
                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment history video playback control processing, forwarded to the superior CMS:requester ID=%s, IP=%s, logic device ID=%s, cr_pos=%d, superior CMS ID=%s, IP=%s, port=%d", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, cr_pos, pCalleeGBDeviceInfo->device_id, pCalleeGBDeviceInfo->login_ip, pCalleeGBDeviceInfo->login_port);

                /* 转发消息出去 */
                i = SIP_SendInfoWithinDialog(pCrData->callee_ua_index, msg_body, msg_body_len);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() SIP_SendInfoWithinDialog Error:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() SIP_SendInfoWithinDialog OK:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                }
            }
            else
            {
                //根据RTSP中的信息，传输给TSU
                if (0 == strncmp(msg_body, "PLAY", 4))
                {
                    i = notify_tsu_start_replay(pCrData->tsu_ip, pCrData->task_id);

                    if (0 != i)
                    {
                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_tsu_start_replay Error:tsu_ip=%s, task_id=%s, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
                    }
                    else
                    {
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_tsu_start_replay OK:tsu_ip=%s, task_id=%s, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
                    }

                    /* 解析MANSRTSP 消息 */
                    i = mansrtsp_init(&rtsp);

                    if (i != 0)
                    {
                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() exit---: Mansrtsp Init Error \r\n");
                        return -1;
                    }

                    i = mansrtsp_parse(rtsp, msg_body);

                    if (i != 0)
                    {
                        mansrtsp_free(rtsp);
                        osip_free(rtsp);
                        rtsp = NULL;

                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() exit---: Mansrtsp Parse Error \r\n");
                        return -1;
                    }

                    /* 快放慢放 */
                    if (NULL != rtsp->scale && NULL != rtsp->scale->number)
                    {
                        iScale = atof(rtsp->scale->number);

                        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_info_msg_proc() Scale Number=%f \r\n", iScale);
                    }
                    else
                    {
                        DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_info_msg_proc() No Scale Value \r\n");
                    }

                    /* 拖放 */
                    if (NULL != rtsp->range && NULL != rtsp->range->start)
                    {
                        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_info_msg_proc() NPT Start=%s \r\n", rtsp->range->start);

                        if (0 != sstrcmp(rtsp->range->start, "now")
                            && 0 != sstrcmp(rtsp->range->start, "196")
                            && 0 != sstrcmp(rtsp->range->start, "196-")
                            && 0 != sstrcmp(rtsp->range->start, "0-")) /* 老版本客户端里面暂停后的继续命令里面携带的是196，防止从头开始播放 */
                        {
                            iLen = strlen(rtsp->range->start);

                            if (iLen > 0)
                            {
                                osip_strncpy(tmpNtp, rtsp->range->start, iLen - 1); /* 去掉最后的"-" */
                                iNtp = osip_atoi(tmpNtp);
                            }
                            else
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() Get NPT Error \r\n");
                            }
                        }
                        else
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() Range Start Now \r\n");
                        }
                    }
                    else
                    {
                        DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_info_msg_proc() No NPT Value \r\n");
                    }

                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备历史视频回放控制处理, PLAY命令处理:请求方ID=%s, IP地址=%s, 逻辑设备ID=%s, cr_pos=%d, Scale=%f, NPT=%d", caller_id, pCrData->caller_ip, callee_id, cr_pos, iScale, iNtp);
                    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment history video playback control processing, PLAY command processing:requester ID=%s, IP=%s, logic device ID=%s, cr_pos=%d, Scale=%f, NPT=%d", caller_id, pCrData->caller_ip, callee_id, cr_pos, iScale, iNtp);

                    if (iScale > 0 || iNtp > 0)
                    {
                        if (iScale > 0 && iScale != 1.0)
                        {
                            pCrData->iScale = iScale;
                        }

                        if (iScale > 0)
                        {
                            i = notify_set_replay_speed(pCrData->tsu_ip, pCrData->task_id, iScale);

                            if (0 != i)
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_set_replay_speed Error:tsu_ip=%s, task_id=%s, Scale=%f, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iScale, i);
                            }
                            else
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_set_replay_speed OK:tsu_ip=%s, task_id=%s, Scale=%f, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iScale, i);
                            }
                        }

                        if (iNtp > 0)
                        {
                            i = notify_tsu_seek_replay(pCrData->tsu_ip, pCrData->task_id, iNtp);

                            if (0 != i)
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_tsu_seek_replay Error:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iNtp, i);
                            }
                            else
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_tsu_seek_replay OK:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iNtp, i);
                            }
                        }
                    }

                    mansrtsp_free(rtsp);
                    osip_free(rtsp);
                    rtsp = NULL;

                    return i;
                }
                else if (0 == strncmp(msg_body, "PAUSE", 5))
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备历史视频回放控制处理, PAUSE命令处理:请求方ID=%s, IP地址=%s, 逻辑设备ID=%s, cr_pos=%d", caller_id, pCrData->caller_ip, callee_id, cr_pos);
                    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment history video playback control processing, PAUSE command processing:requester ID=%s, IP=%s, logic device ID=%s, cr_pos=%d, Scale=%f, NPT=%d", caller_id, pCrData->caller_ip, callee_id, cr_pos, iScale, iNtp);

                    i = notify_tsu_pause_replay(pCrData->tsu_ip, pCrData->task_id);

                    if (0 != i)
                    {
                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_tsu_pause_replay Error:tsu_ip=%s, task_id=%s, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
                    }
                    else
                    {
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_tsu_pause_replay OK:tsu_ip=%s, task_id=%s, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
                    }

                    return i;
                }
                else if (0 == strncmp(msg_body, "TEARDOWN", 8))
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备历史视频回放控制处理, TEARDOWN命令处理:请求方ID=%s, IP地址=%s, 逻辑设备ID=%s, cr_pos=%d", caller_id, pCrData->caller_ip, callee_id, cr_pos);
                    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment history video playback control processing, TEARDOWN command processing:requester ID=%s, IP=%s, logic device ID=%s, cr_pos=%d, Scale=%f, NPT=%d", caller_id, pCrData->caller_ip, callee_id, cr_pos, iScale, iNtp);

                    i = notify_tsu_stop_replay(pCrData->tsu_ip, pCrData->task_id);

                    if (0 != i)
                    {
                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_tsu_stop_replay Error:tsu_ip=%s, task_id=%s, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
                    }
                    else
                    {
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_tsu_stop_replay OK:tsu_ip=%s, task_id=%s, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
                    }

                    return i;
                }
                else if (0 == strncmp(msg_body, "SEEK", 4))
                {
                    /* 解析MANSRTSP 消息 */
                    i = mansrtsp_init(&rtsp);

                    if (i != 0)
                    {
                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() exit---: Mansrtsp Init Error \r\n");
                        return -1;
                    }

                    i = mansrtsp_parse(rtsp, msg_body);

                    if (i != 0)
                    {
                        mansrtsp_free(rtsp);
                        osip_free(rtsp);
                        rtsp = NULL;

                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() exit---: Mansrtsp Parse Error \r\n");
                        return -1;
                    }

                    if (NULL != rtsp->range && NULL != rtsp->range->start)
                    {
                        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_info_msg_proc() NPT Start=%s \r\n", rtsp->range->start);

                        if (0 != sstrcmp(rtsp->range->start, "now"))
                        {
                            iLen = strlen(rtsp->range->start);

                            if (iLen > 0)
                            {
                                osip_strncpy(tmpNtp, rtsp->range->start, iLen - 1); /* 去掉最后的"-" */
                                iNtp = osip_atoi(tmpNtp);
                            }
                            else
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() Get NPT Error \r\n");
                            }

                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备历史视频回放控制处理, SEEK命令处理:请求方ID=%s, IP地址=%s, 逻辑设备ID=%s, cr_pos=%d, NPT=%d", caller_id, pCrData->caller_ip, callee_id, cr_pos, iNtp);
                            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment history video playback control processing, SEEK command processing:requester ID=%s, IP=%s, logic device ID=%s, cr_pos=%d, Scale=%f, NPT=%d", caller_id, pCrData->caller_ip, callee_id, cr_pos, iScale, iNtp);

                            if (iNtp > 0)
                            {
                                i = notify_tsu_seek_replay(pCrData->tsu_ip, pCrData->task_id, iNtp);

                                if (0 != i)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_tsu_seek_replay Error:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, osip_atoi(rtsp->range->start), i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_tsu_seek_replay OK:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, osip_atoi(rtsp->range->start), i);
                                }
                            }
                            else
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() NPT Value Error \r\n");
                            }
                        }
                        else
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() Range Start Now \r\n");
                        }
                    }

                    mansrtsp_free(rtsp);
                    osip_free(rtsp);
                    rtsp = NULL;

                    return i;
                }
            }
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() GBDevice_info_get_by_stream_type Error:device_id=%s, callee_stream_type=%d \r\n", pCalleeGBLogicDeviceInfo->device_id, pCrData->callee_stream_type);
        }
    }

    return -1;
}
#endif

#if 0
/*****************************************************************************
 函 数 名  : device_info_msg_proc
 功能描述  : 设备Info 消息处理
 输入参数  : char* caller_id
             char* callee_id
             int dialog_index
             char* msg_body
             int msg_body_len
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月22日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_info_msg_proc(char* caller_id, char* callee_id, int dialog_index, char* msg_body, int msg_body_len)
{
    int i = 0;
    int cr_pos = -1;
    mansrtsp_t* rtsp = NULL;
    cr_t* pCrData = NULL;
    GBDevice_info_t* pCalleeGBDeviceInfo = NULL;
    GBLogicDevice_info_t* pCalleeGBLogicDeviceInfo = NULL;
    float iScale = 0.0;
    int iLen = 0;
    int iNtp = 0;
    char tmpBuf[128] = {0};
    char tmpNtp[32] = {0};

    int iCalleeRoutePos = 0;
    route_info_t* pCalleeRouteInfo = NULL;

    if ((NULL == caller_id) || (NULL == callee_id) || (NULL == msg_body) || dialog_index < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_info_msg_proc() exit---: Param Error \r\n");
        return -1;
    }

    //处理过程

    /* 获取呼叫记录 */
    cr_pos = call_record_find_by_caller_index(dialog_index);

    //DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "route_info_msg_proc() call_record_find_by_caller_index:cr_pos=%d \r\n", cr_pos);

    if (cr_pos < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() exit---: Find Call Record Error:dialog_index=%d \r\n", dialog_index);
        return -1;
    }

    pCrData = call_record_get(cr_pos);

    if (NULL == pCrData)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() exit---: Get Call Record Error:cr_pos=%d \r\n", cr_pos);
        return -1;
    }

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_info_msg_proc():caller_id=%s, caller_ip=%s, callee_id=%s, callee_ip=%s \r\n", pCrData->caller_id, pCrData->caller_ip, pCrData->callee_id, pCrData->callee_ip);

#if 0

    /* 查找逻辑设备信息 */
    pCalleeGBLogicDeviceInfo = GBLogicDevice_info_find(callee_id);

    if (NULL == pCalleeGBLogicDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_info_msg_proc() exit---: Get Callee GBlogicDevice Info Error \r\n");
        return -1;
    }

    /* 查找对应的物理设备 */
    pCalleeGBDeviceInfo = pCalleeGBLogicDeviceInfo->ptGBDeviceInfo;

    if (NULL == pCalleeGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_info_msg_proc() exit---: Get Callee GBDevice Info Error \r\n");
        return -1;
    }

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_info_msg_proc() CalleeGBDeviceInfo device_type=%d \r\n", pCalleeGBDeviceInfo->device_type);

    if (pCalleeGBDeviceInfo->device_type == EV9000_DEVICETYPE_SIPSERVER || pCalleeGBLogicDeviceInfo->record_type == 1) /* 下级CMS 获取前端录像*/
    {
        /* 转发消息出去 */
        SIP_SendInfoWithinDialog(pCrData->callee_ua_index, msg_body, msg_body_len);

        return 0;
    }
    else
#endif
    {
        // TODO:根据RTSP中的信息，传输给TSU
        if (0 == strncmp(msg_body, "PLAY", 4))
        {
            i = notify_tsu_start_replay(pCrData->tsu_ip, pCrData->task_id);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_tsu_start_replay Error:tsu_ip=%s, task_id=%s, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_tsu_start_replay OK:tsu_ip=%s, task_id=%s, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }

            /* 解析MANSRTSP 消息 */
            i = mansrtsp_init(&rtsp);

            if (i != 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() exit---: Mansrtsp Init Error \r\n");
                return -1;
            }

            i = mansrtsp_parse(rtsp, msg_body);

            if (i != 0)
            {
                mansrtsp_free(rtsp);
                osip_free(rtsp);
                rtsp = NULL;

                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() exit---: Mansrtsp Parse Error \r\n");
                return -1;
            }

            /* 快放慢放 */
            if (NULL != rtsp->scale && NULL != rtsp->scale->number)
            {
                iScale = atof(rtsp->scale->number);

                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_info_msg_proc() Scale Number=%f \r\n", iScale);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_info_msg_proc() No Scale Value \r\n");
            }

            /* 拖放 */
            if (NULL != rtsp->range && NULL != rtsp->range->start)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_info_msg_proc() NPT Start=%s \r\n", rtsp->range->start);

                if (0 != sstrcmp(rtsp->range->start, "now")
                    && 0 != sstrcmp(rtsp->range->start, "196")
                    && 0 != sstrcmp(rtsp->range->start, "196-")
                    && 0 != sstrcmp(rtsp->range->start, "0-")) /* 老版本客户端里面暂停后的继续命令里面携带的是196，防止从头开始播放 */
                {
                    iLen = strlen(rtsp->range->start);

                    if (iLen > 0)
                    {
                        osip_strncpy(tmpNtp, rtsp->range->start, iLen - 1); /* 去掉最后的"-" */
                        iNtp = osip_atoi(tmpNtp);
                    }
                    else
                    {
                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() Get NPT Error \r\n");
                    }
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() Range Start Now \r\n");
                }
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_info_msg_proc() No NPT Value \r\n");
            }

            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_info_msg_proc() Scale=%f, NPT=%d \r\n", iScale, iNtp);

            if (iScale > 0 || iNtp > 0)
            {
                if (iScale > 0 && iScale != 1.0)
                {
                    pCrData->iScale = iScale;
                }

                /* 查找逻辑设备信息 */
                pCalleeGBLogicDeviceInfo = GBLogicDevice_info_find(callee_id);

                if (NULL != pCalleeGBLogicDeviceInfo)
                {
                    /* 根据逻辑设备所属域进行判断，决定消息走向 */
                    if (1 == pCalleeGBLogicDeviceInfo->other_realm)
                    {
                        /* 查找上级路由信息 */
                        iCalleeRoutePos = route_info_find(pCalleeGBLogicDeviceInfo->cms_id);

                        if (iCalleeRoutePos >= 0)
                        {
                            pCalleeRouteInfo = route_info_get(iCalleeRoutePos);

                            if (NULL != pCalleeRouteInfo)
                            {
                                if (iNtp > 0)
                                {
                                    i = notify_tsu_seek_replay(pCrData->tsu_ip, pCrData->task_id, iNtp);

                                    if (0 != i)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_tsu_seek_replay Error:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iNtp, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_tsu_seek_replay OK:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iNtp, i);
                                    }

                                    /* 拖放之前先发送一下恢复命令，大华NVR在暂停状态下，不响应拖放命令 */
                                    if (iScale > 0 && iScale != 1.0)
                                    {
                                        snprintf(tmpBuf, 128, (char*)"PLAY RTSP/1.0\r\nCSeq: %s\r\nScale: %f\r\nRange: npt=now-\r\n", rtsp->cseq->number, pCrData->iScale);
                                    }
                                    else
                                    {
                                        snprintf(tmpBuf, 128, (char*)"PLAY RTSP/1.0\r\nCSeq: %s\r\nRange: npt=now-\r\n", rtsp->cseq->number);
                                    }

                                    i = SIP_SendInfoWithinDialog(pCrData->callee_ua_index, tmpBuf, strlen(tmpBuf));

                                    if (0 != i)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() SIP_SendInfoWithinDialog:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() SIP_SendInfoWithinDialog:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                                    }

                                    /* 修改拖放时间 */
                                    if (pCrData->iPlaybackTimeGap > 0)
                                    {
                                        if (iScale > 0 && iScale != 1.0)
                                        {
                                            snprintf(tmpBuf, 128, (char*)"PLAY RTSP/1.0\r\nCSeq: %s\r\nScale: %f\r\nRange: npt=%d-\r\n", rtsp->cseq->number, pCrData->iScale, iNtp - pCrData->iPlaybackTimeGap);
                                        }
                                        else
                                        {
                                            snprintf(tmpBuf, 128, (char*)"PLAY RTSP/1.0\r\nCSeq: %s\r\nRange: npt=%d-\r\n", rtsp->cseq->number, iNtp - pCrData->iPlaybackTimeGap);
                                        }

                                        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_info_msg_proc() SIP_SendInfoWithinDialog:Scale=%f, NPT=%d \r\n", iScale, iNtp - pCrData->iPlaybackTimeGap);

                                        i = SIP_SendInfoWithinDialog(pCrData->callee_ua_index, tmpBuf, strlen(tmpBuf));

                                        if (0 != i)
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() SIP_SendInfoWithinDialog:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                                        }
                                        else
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() SIP_SendInfoWithinDialog:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                                        }
                                    }
                                    else
                                    {
                                        /* 转发消息出去 */
                                        i = SIP_SendInfoWithinDialog(pCrData->callee_ua_index, msg_body, msg_body_len);

                                        if (0 != i)
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() SIP_SendInfoWithinDialog Error:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                                        }
                                        else
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() SIP_SendInfoWithinDialog OK:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                                        }
                                    }
                                }
                                else
                                {
                                    /* 转发消息出去 */
                                    i = SIP_SendInfoWithinDialog(pCrData->callee_ua_index, msg_body, msg_body_len);

                                    if (0 != i)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() SIP_SendInfoWithinDialog Error:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() SIP_SendInfoWithinDialog OK:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                                    }
                                }
                            }
                            else
                            {
                                if (iScale > 0)
                                {
                                    i = notify_set_replay_speed(pCrData->tsu_ip, pCrData->task_id, iScale);

                                    if (0 != i)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_set_replay_speed Error:tsu_ip=%s, task_id=%s, Scale=%f, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iScale, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_set_replay_speed OK:tsu_ip=%s, task_id=%s, Scale=%f, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iScale, i);
                                    }
                                }

                                if (iNtp > 0)
                                {
                                    i = notify_tsu_seek_replay(pCrData->tsu_ip, pCrData->task_id, iNtp);

                                    if (0 != i)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_tsu_seek_replay Error:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iNtp, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_tsu_seek_replay OK:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iNtp, i);
                                    }
                                }
                            }
                        }
                        else
                        {
                            if (iScale > 0)
                            {
                                i = notify_set_replay_speed(pCrData->tsu_ip, pCrData->task_id, iScale);

                                if (0 != i)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_set_replay_speed Error:tsu_ip=%s, task_id=%s, Scale=%f, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iScale, i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_set_replay_speed OK:tsu_ip=%s, task_id=%s, Scale=%f, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iScale, i);
                                }
                            }

                            if (iNtp > 0)
                            {
                                i = notify_tsu_seek_replay(pCrData->tsu_ip, pCrData->task_id, iNtp);

                                if (0 != i)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_tsu_seek_replay Error:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iNtp, i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_tsu_seek_replay OK:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iNtp, i);
                                }
                            }
                        }
                    }
                    else
                    {
                        /* 查找对应的物理设备 */
                        pCalleeGBDeviceInfo = GBDevice_info_get_by_stream_type(pCalleeGBLogicDeviceInfo, pCrData->callee_stream_type);

                        if (NULL != pCalleeGBDeviceInfo)
                        {
                            if (pCalleeGBDeviceInfo->device_type == EV9000_DEVICETYPE_SIPSERVER || pCalleeGBLogicDeviceInfo->record_type == 1) /* 下级CMS或者前端录像*/
                            {
                                if (iNtp > 0)
                                {
                                    i = notify_tsu_seek_replay(pCrData->tsu_ip, pCrData->task_id, iNtp);

                                    if (0 != i)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_tsu_seek_replay Error:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iNtp, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_tsu_seek_replay OK:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iNtp, i);
                                    }

                                    /* 拖放之前先发送一下恢复命令，大华NVR在暂停状态下，不响应拖放命令 */
                                    if (iScale > 0 && iScale != 1.0)
                                    {
                                        snprintf(tmpBuf, 128, (char*)"PLAY RTSP/1.0\r\nCSeq: %s\r\nScale: %f\r\nRange: npt=now-\r\n", rtsp->cseq->number, pCrData->iScale);
                                    }
                                    else
                                    {
                                        snprintf(tmpBuf, 128, (char*)"PLAY RTSP/1.0\r\nCSeq: %s\r\nRange: npt=now-\r\n", rtsp->cseq->number);
                                    }

                                    i = SIP_SendInfoWithinDialog(pCrData->callee_ua_index, tmpBuf, strlen(tmpBuf));

                                    if (0 != i)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() SIP_SendInfoWithinDialog:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() SIP_SendInfoWithinDialog:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                                    }

                                    /* 修改拖放时间 */
                                    if (pCrData->iPlaybackTimeGap > 0)
                                    {
                                        if (iScale > 0 && iScale != 1.0)
                                        {
                                            snprintf(tmpBuf, 128, (char*)"PLAY RTSP/1.0\r\nCSeq: %s\r\nScale: %f\r\nRange: npt=%d-\r\n", rtsp->cseq->number, pCrData->iScale, iNtp - pCrData->iPlaybackTimeGap);
                                        }
                                        else
                                        {
                                            snprintf(tmpBuf, 128, (char*)"PLAY RTSP/1.0\r\nCSeq: %s\r\nRange: npt=%d-\r\n", rtsp->cseq->number, iNtp - pCrData->iPlaybackTimeGap);
                                        }

                                        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_info_msg_proc() SIP_SendInfoWithinDialog:Scale=%f, NPT=%d \r\n", iScale, iNtp - pCrData->iPlaybackTimeGap);

                                        i = SIP_SendInfoWithinDialog(pCrData->callee_ua_index, tmpBuf, strlen(tmpBuf));

                                        if (0 != i)
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() SIP_SendInfoWithinDialog:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                                        }
                                        else
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() SIP_SendInfoWithinDialog:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                                        }
                                    }
                                    else
                                    {
                                        /* 转发消息出去 */
                                        i = SIP_SendInfoWithinDialog(pCrData->callee_ua_index, msg_body, msg_body_len);

                                        if (0 != i)
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() SIP_SendInfoWithinDialog Error:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                                        }
                                        else
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() SIP_SendInfoWithinDialog OK:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                                        }
                                    }
                                }
                                else
                                {
                                    /* 转发消息出去 */
                                    i = SIP_SendInfoWithinDialog(pCrData->callee_ua_index, msg_body, msg_body_len);

                                    if (0 != i)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() SIP_SendInfoWithinDialog Error:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() SIP_SendInfoWithinDialog OK:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                                    }
                                }
                            }
                            else
                            {
                                if (iScale > 0)
                                {
                                    i = notify_set_replay_speed(pCrData->tsu_ip, pCrData->task_id, iScale);

                                    if (0 != i)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_set_replay_speed Error:tsu_ip=%s, task_id=%s, Scale=%f, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iScale, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_set_replay_speed OK:tsu_ip=%s, task_id=%s, Scale=%f, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iScale, i);
                                    }
                                }

                                if (iNtp > 0)
                                {
                                    i = notify_tsu_seek_replay(pCrData->tsu_ip, pCrData->task_id, iNtp);

                                    if (0 != i)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_tsu_seek_replay Error:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iNtp, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_tsu_seek_replay OK:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iNtp, i);
                                    }
                                }
                            }
                        }
                        else
                        {
                            if (iScale > 0)
                            {
                                i = notify_set_replay_speed(pCrData->tsu_ip, pCrData->task_id, iScale);

                                if (0 != i)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_set_replay_speed Error:tsu_ip=%s, task_id=%s, Scale=%f, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iScale, i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_set_replay_speed OK:tsu_ip=%s, task_id=%s, Scale=%f, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iScale, i);
                                }
                            }

                            if (iNtp > 0)
                            {
                                i = notify_tsu_seek_replay(pCrData->tsu_ip, pCrData->task_id, iNtp);

                                if (0 != i)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_tsu_seek_replay Error:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iNtp, i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_tsu_seek_replay OK:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iNtp, i);
                                }
                            }
                        }
                    }
                }
                else
                {
                    if (iScale > 0)
                    {
                        i = notify_set_replay_speed(pCrData->tsu_ip, pCrData->task_id, iScale);

                        if (0 != i)
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_set_replay_speed Error:tsu_ip=%s, task_id=%s, Scale=%f, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iScale, i);
                        }
                        else
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_set_replay_speed OK:tsu_ip=%s, task_id=%s, Scale=%f, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iScale, i);
                        }
                    }

                    if (iNtp > 0)
                    {
                        i = notify_tsu_seek_replay(pCrData->tsu_ip, pCrData->task_id, iNtp);

                        if (0 != i)
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_tsu_seek_replay Error:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iNtp, i);
                        }
                        else
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_tsu_seek_replay OK:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, iNtp, i);
                        }
                    }
                }
            }

            return i;
        }
        else if (0 == strncmp(msg_body, "PAUSE", 5))
        {
            i = notify_tsu_pause_replay(pCrData->tsu_ip, pCrData->task_id);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_tsu_pause_replay Error:tsu_ip=%s, task_id=%s, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_tsu_pause_replay OK:tsu_ip=%s, task_id=%s, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }

            return i;
        }
        else if (0 == strncmp(msg_body, "TEARDOWN", 8))
        {
            i = notify_tsu_stop_replay(pCrData->tsu_ip, pCrData->task_id);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_tsu_stop_replay Error:tsu_ip=%s, task_id=%s, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_tsu_stop_replay OK:tsu_ip=%s, task_id=%s, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
            }

            return i;
        }
        else if (0 == strncmp(msg_body, "SEEK", 4))
        {
            /* Seek 命令需要同时发送给前端 */
            /* 查找逻辑设备信息 */
            pCalleeGBLogicDeviceInfo = GBLogicDevice_info_find(callee_id);

            if (NULL != pCalleeGBLogicDeviceInfo)
            {
                /* 根据逻辑设备所属域进行判断，决定消息走向 */
                if (1 == pCalleeGBLogicDeviceInfo->other_realm)
                {
                    /* 查找上级路由信息 */
                    iCalleeRoutePos = route_info_find(pCalleeGBLogicDeviceInfo->cms_id);

                    if (iCalleeRoutePos >= 0)
                    {
                        pCalleeRouteInfo = route_info_get(iCalleeRoutePos);

                        if (NULL != pCalleeRouteInfo)
                        {
                            /* 转发消息出去 */
                            i = SIP_SendInfoWithinDialog(pCrData->callee_ua_index, msg_body, msg_body_len);

                            if (0 != i)
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() SIP_SendInfoWithinDialog Error:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                            }
                            else
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() SIP_SendInfoWithinDialog OK:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                            }
                        }
                    }
                }
                else
                {
                    /* 查找对应的物理设备 */
                    pCalleeGBDeviceInfo = GBDevice_info_get_by_stream_type(pCalleeGBLogicDeviceInfo, pCrData->callee_stream_type);

                    if (NULL != pCalleeGBDeviceInfo)
                    {
                        if (pCalleeGBDeviceInfo->device_type == EV9000_DEVICETYPE_SIPSERVER || pCalleeGBLogicDeviceInfo->record_type == 1) /* 下级CMS 获取前端录像*/
                        {
                            /* 转发消息出去 */
                            i = SIP_SendInfoWithinDialog(pCrData->callee_ua_index, msg_body, msg_body_len);

                            if (0 != i)
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() SIP_SendInfoWithinDialog Error:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                            }
                            else
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() SIP_SendInfoWithinDialog OK:callee_ua_index=%d, callee_id=%s, callip=%s, iRet=%d \r\n", pCrData->callee_ua_index, pCrData->callee_id, pCrData->callee_ip, i);
                            }
                        }
                    }
                }
            }

            /* 解析MANSRTSP 消息 */
            i = mansrtsp_init(&rtsp);

            if (i != 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() exit---: Mansrtsp Init Error \r\n");
                return -1;
            }

            i = mansrtsp_parse(rtsp, msg_body);

            if (i != 0)
            {
                mansrtsp_free(rtsp);
                osip_free(rtsp);
                rtsp = NULL;

                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() exit---: Mansrtsp Parse Error \r\n");
                return -1;
            }

            if (NULL != rtsp->range && NULL != rtsp->range->start)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_info_msg_proc() NPT Start=%s \r\n", rtsp->range->start);

                if (0 != sstrcmp(rtsp->range->start, "now"))
                {
                    iLen = strlen(rtsp->range->start);

                    if (iLen > 0)
                    {
                        osip_strncpy(tmpNtp, rtsp->range->start, iLen - 1); /* 去掉最后的"-" */
                        iNtp = osip_atoi(tmpNtp);
                    }
                    else
                    {
                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() Get NPT Error \r\n");
                    }

                    if (iNtp > 0)
                    {
                        i = notify_tsu_seek_replay(pCrData->tsu_ip, pCrData->task_id, iNtp);

                        if (0 != i)
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() notify_tsu_seek_replay Error:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, osip_atoi(rtsp->range->start), i);
                        }
                        else
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_info_msg_proc() notify_tsu_seek_replay OK:tsu_ip=%s, task_id=%s, start=%d, iRet=%d \r\n", pCrData->tsu_ip, pCrData->task_id, osip_atoi(rtsp->range->start), i);
                        }
                    }
                    else
                    {
                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() NPT Value Error \r\n");
                    }
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_info_msg_proc() Range Start Now \r\n");
                }
            }

            mansrtsp_free(rtsp);
            osip_free(rtsp);
            rtsp = NULL;

            return i;
        }
    }

    return -1;
}
#endif

/*****************************************************************************
 函 数 名  : device_message_msg_proc
 功能描述  : 设备Message消息处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             int ua_dialog_index
             char* msg_body
             int msg_body_len
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月22日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_message_msg_proc(GBDevice_info_t* pGBDeviceInfo, char* caller_id, char* callee_id, int ua_dialog_index, char* msg_body, int msg_body_len, DBOper* pDevice_Srv_dboper)
{
    int i = 0;
    int iRet = 0;
    xml_type_t xml_type = XML_TYPE_NULL;
    CPacket inPacket;
    vector<string> NodeName_Vector;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_message_msg_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if ((NULL == caller_id) || (NULL == callee_id) || (NULL == msg_body))
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG,  "device_message_msg_proc() exit---: Param Error \r\n");
        return -1;
    }

    if (NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG,  "device_message_msg_proc() exit---: Device Srv DB Oper Error \r\n");
        return -1;
    }

    //解析XML
    iRet = inPacket.BuiltTree(msg_body, msg_body_len);//生成DOM树结构.

    if (iRet < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_message_msg_proc() exit---: XML Build Tree Error \r\nmsg=%s \r\n", msg_body);
        return iRet;
    }

    NodeName_Vector.clear();
    DOMDocument* pDOMDocument = inPacket.GetDOMDocument();
    DOMElement* pDOMElement = pDOMDocument->get_root();
    pDOMElement->ClearNodeNumber();

    if (pDOMElement->GetNodeName(NodeName_Vector) <= 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_message_msg_proc() exit---: Get XML Node Name Error \r\n");
        return -1;
    }

    /* 解析出xml的消息类型 */
    xml_type = get_xml_type_from_xml_body(NodeName_Vector, inPacket);
    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_message_msg_proc() get_xml_type_from_xml_body:xml_type=%d \r\n", xml_type);

    switch (xml_type)
    {
        case XML_CONTROL_DEVICECONTROL :
            i = device_device_control_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_QUERY_CATALOG :
            i = device_query_catalog_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_QUERY_DEVICEGROUP :   /* 逻辑设备分组信息 */
            i = device_query_device_group_config_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_QUERY_DEVICEMAPGROUP: /* 逻辑设备分组映射关系 */
            i = device_query_device_map_group_config_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_QUERY_DEVICEINFO :
            i = device_query_device_info_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_QUERY_DEVICESTATUS :
            i = device_query_device_status_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_QUERY_RECORDINFO :
            i = device_query_record_info_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_QUERY_GETPRESET :                    /* 获取预置位 */
            i = device_query_preset_info_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_QUERY_TSUINFO :
            i = device_query_tsu_ip_and_port_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_NOTIFY_ALARM :
            i = device_notify_alarm_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_NOTIFY_KEEPLIVE :
            i = device_notify_keep_alive_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_NOTIFY_MEDIA_STATUS :
            i = device_notify_media_status_proc(pGBDeviceInfo, caller_id, callee_id, ua_dialog_index, inPacket, pDevice_Srv_dboper);
            break;

        case XML_NOTIFY_CATALOG:
            i = device_notify_catalog_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_NOTIFY_REOPEN :    /* DEC通知CMS重新连接 */
            i = device_notify_reopen_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_NOTIFY_STATUS :
            i = device_notify_status_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;
#if 1 /*add for RCU 2016.10.12*/

        case XML_NOTIFY_RCU_DEVICE_STATUS:
            i = device_notify_RCU_status_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;
#endif /*add for RCU 2016.10.12*/

        case XML_NOTIFY_CMS_RESTART :
            i = device_notify_cms_restart_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_NOTIFY_DIAGNOSIS_NOTICE :
            i = device_notify_diagnosis_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_NOTIFY_TARGET_COUNT :
            i = device_notify_target_tount_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_NOTIFY_TOPOLOGYPHYDEVICE : /* 拓扑结构表变更通知 */
            i = device_notify_topology_phydevice_config_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_NOTIFY_DATA_VALUE : /* 前端设备通知数据值 */
            i = device_notify_data_value_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_NOTIFY_DEVICEGROUP : /* 通知逻辑设备分组信息变化 */
            i = device_notify_device_group_config_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_NOTIFY_DEVICEMAPGROUP : /* 通知逻辑设备分组映射关系变化 */
            i = device_notify_device_group_map_config_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_RESPONSE_DEVICECONTROL :
            i = device_device_control_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_RESPONSE_ALARM :
            i = device_notify_alarm_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_RESPONSE_CATALOG:  /* 查询设备目录应答 */
            i = device_query_catalog_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_RESPONSE_DEVICEINFO :
            i = device_device_info_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_RESPONSE_QUERY_DEVICECONFIG :    /* 查询设备配置应答 */
            i = device_query_device_config_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_RESPONSE_CONTROL_DEVICECONFIG :  /* 设备配置应答 */
            i = device_device_config_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_RESPONSE_DEVICESTATUS:
            i = device_device_status_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_RESPONSE_RECORDINFO:
            i = device_record_info_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_RESPONSE_SETDEVICEVIDEOPARAM:     /* 设置前端图像参数回应  */
            i = device_set_device_video_param_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_RESPONSE_GETDEVICEVIDEOPARAM:     /* 获取前端图像参数回应  */
            i = device_get_device_video_param_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_RESPONSE_QUERY_GETPRESET:
        case XML_RESPONSE_GETDEVICEPRESET:         /* 获取前端预置位回应  */
            i = device_preset_info_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_RESPONSE_GETDBIP:          /* 获取下级CMS 数据库IP 地址回应  */
            i = device_get_dbip_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_RESPONSE_TV_STATUS:               /* 电视墙状态回应  */
            i = device_notify_tv_status_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_RESPONSE_QUERY_DEVICEGROUP:       /* 逻辑设备分组信息响应  */
            i = device_query_device_group_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_RESPONSE_QUERY_DEVICEMAPGROUP:    /* 逻辑设备分组映射关系响应  */
            i = device_query_device_map_group_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_RESPONSE_TOPOLOGYPHYDEVICE:       /* 拓扑物理设备配置信息响应  */
            i = device_query_topology_phydevice_config_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_RESPONSE_QUERY_CHANNELSTATUS :    /*获取解码器通道状态响应*/
            i = device_channel_status_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_RESPONSE_QUERY_DATA_VALUE :       /*获取前端点位数据值响应*/
            i = device_data_value_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_RESPONSE_QUERY_DEC_MEDIA_PORT :   /* 查询解码器媒体端口响应 */
            i = device_query_dec_media_port_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_NOTIFY_TVWALL_STATUS :
            i = device_notify_channel_status_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        default:
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_message_msg_proc() exit---: Not Support Message Type:%d \r\n", xml_type);
            return -1;
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_notify_msg_proc
 功能描述  : 设备Notify消息处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             char* msg_body
             int msg_body_len
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年4月22日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_msg_proc(GBDevice_info_t* pGBDeviceInfo, char* caller_id, char* callee_id, char* msg_body, int msg_body_len, DBOper* pDevice_Srv_dboper)
{
    int i = 0;
    int iRet = 0;
    xml_type_t xml_type = XML_TYPE_NULL;
    CPacket inPacket;
    vector<string> NodeName_Vector;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_msg_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if ((NULL == caller_id) || (NULL == callee_id) || (NULL == msg_body))
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG,  "device_notify_msg_proc() exit---: Param Error \r\n");
        return -1;
    }

    if (NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG,  "device_notify_msg_proc() exit---: Device Srv DB Oper Error \r\n");
        return -1;
    }

    //解析XML
    iRet = inPacket.BuiltTree(msg_body, msg_body_len);//生成DOM树结构.

    if (iRet < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_msg_proc() exit---: XML Build Tree Error \r\nmsg=%s \r\n", msg_body);
        return iRet;
    }

    NodeName_Vector.clear();
    DOMDocument* pDOMDocument = inPacket.GetDOMDocument();
    DOMElement* pDOMElement = pDOMDocument->get_root();
    pDOMElement->ClearNodeNumber();

    if (pDOMElement->GetNodeName(NodeName_Vector) <= 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_msg_proc() exit---: Get XML Node Name Error \r\n");
        return -1;
    }

    /* 解析出xml的消息类型 */
    xml_type = get_xml_type_from_xml_body(NodeName_Vector, inPacket);
    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_notify_msg_proc() get_xml_type_from_xml_body:xml_type=%d \r\n", xml_type);

    switch (xml_type)
    {
        case XML_QUERY_CATALOG :
            i = device_query_catalog_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_QUERY_DEVICEINFO :
            i = device_query_device_info_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_QUERY_DEVICESTATUS :
            i = device_query_device_status_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_NOTIFY_ALARM :
            i = device_notify_alarm_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_NOTIFY_KEEPLIVE :
            i = device_notify_keep_alive_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_NOTIFY_CATALOG:
            i = device_notify_catalog_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_NOTIFY_REOPEN :
            i = device_notify_reopen_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_NOTIFY_STATUS :
            i = device_notify_status_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_NOTIFY_CMS_RESTART :
            i = device_notify_cms_restart_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_NOTIFY_DIAGNOSIS_NOTICE :
            i = device_notify_diagnosis_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_NOTIFY_TARGET_COUNT :
            i = device_notify_target_tount_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_NOTIFY_TOPOLOGYPHYDEVICE : /* 拓扑结构表变更通知 */
            i = device_notify_topology_phydevice_config_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_RESPONSE_DEVICECONTROL :
            i = device_device_control_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_RESPONSE_ALARM :
            i = device_notify_alarm_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_RESPONSE_CATALOG:
            i = device_notify_catalog_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_RESPONSE_DEVICEINFO :
            i = device_device_info_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_RESPONSE_QUERY_DEVICECONFIG :    /* 查询设备配置应答 */
            i = device_query_device_config_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_RESPONSE_CONTROL_DEVICECONFIG :  /* 设备配置应答 */
            i = device_device_config_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_RESPONSE_DEVICESTATUS:
            i = device_device_status_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_RESPONSE_RECORDINFO:
            i = device_record_info_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_RESPONSE_SETDEVICEVIDEOPARAM:     /* 设置前端图像参数回应  */
            i = device_set_device_video_param_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_RESPONSE_GETDEVICEVIDEOPARAM:     /* 获取前端图像参数回应  */
            i = device_get_device_video_param_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_RESPONSE_GETDBIP:          /* 获取下级CMS 数据库IP 地址回应  */
            i = device_get_dbip_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_RESPONSE_TV_STATUS:               /* 电视墙状态回应  */
            i = device_notify_tv_status_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket);
            break;

        case XML_RESPONSE_QUERY_DEVICEGROUP:       /* 逻辑设备分组信息响应  */
            i = device_query_device_group_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_RESPONSE_QUERY_DEVICEMAPGROUP:    /* 逻辑设备分组映射关系响应  */
            i = device_query_device_map_group_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        case XML_RESPONSE_TOPOLOGYPHYDEVICE:       /* 拓扑物理设备配置信息响应  */
            i = device_query_topology_phydevice_config_response_proc(pGBDeviceInfo, caller_id, callee_id, inPacket, pDevice_Srv_dboper);
            break;

        default:
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_msg_proc() exit---: Not Support Message Type:%d \r\n", xml_type);
            return -1;
    }

    return i;
}

/*****************************************************************************
 函 数 名  : user_device_control_proc
 功能描述  : 用户设备控制处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月13日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_device_control_proc(GBDevice_info_t* pCallerGBDeviceInfo, char* caller_id, char* callee_id, CPacket& inPacket, DBOper* pDevice_Srv_dboper)
{
    int i = 0;
    int iLen = 0;
    GBDevice_info_t* pGBDeviceInfo = NULL;
    GBLogicDevice_info_t* pGBLogicDeviceInfo = NULL;

    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strPTZCmd[64] = {0};      /* 球机/云台控制命令 */
    char strRecordCmd[32] = {0};   /* 录像控制命令 */
    char strGuardCmd[32] = {0};    /* 报警布防/撤防命令 */
    char strTeleBootCmd[32] = {0}; /* 远程启动控制命令 */
    char strAlarmCmd[32] = {0};    /* 报警复位命令 */

    CPacket outPacket;
    DOMElement* AccNode = NULL;

    int iCalleeRoutePos = 0;
    route_info_t* pCalleeRouteInfo = NULL;

    char strTransferSN[32] = {0};
    DOMElement* AccSnNode = NULL;
    unsigned int old_xml_sn = 0;
    unsigned int transfer_xml_sn = 0;

    unsigned char szPtzCmd[PTZCMD_28181_LEN + 1] = {0};

    if (NULL == pCallerGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_device_control_proc() exit---: Caller GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_device_control_proc() exit---: Param Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的设备控制命令处理:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 命令:PTZCmd=%s, RecordCmd=%s, GuardCmd=%s, TeleBoot=%s, AlarmCmd=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, strDeviceID, strPTZCmd, strRecordCmd, strGuardCmd, strTeleBootCmd, strAlarmCmd);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end equipment control command processing:front-end equipment ID=%s, IP=%s, port=%d, logic device ID=%s, command:PTZCmd=%s, RecordCmd=%s, GuardCmd=%s, TeleBoot=%s, AlarmCmd=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, strDeviceID, strPTZCmd, strRecordCmd, strGuardCmd, strTeleBootCmd, strAlarmCmd);

    /* 设备控制的命令直接转发给前段设备，不做处理
          控制流程见9.3.2

          命令包括如下字段:
          <!-- 命令类型：设备控制（必选） -->
          <element name="CmdType" fixed ="DeviceControl" />
          <!-- 命令序列号（必选） -->
          <element name="SN" type="integer" minInclusive value = "1" />
          <!-- 目标设备编码（必选） -->
          <element name="DeviceID" type="tg:deviceIDType" />
          <!-- 球机/云台控制命令（可选，控制码应符合附录L中的规定) -->
          <element name=" PTZCmd " type="tg:PTZType" />
          <!-- 远程启动控制命令（可选） -->
          <element name="TeleBoot" minOccurs= "0">
          <restriction base="string">
          <enumeration value="Boot"/>
          </restriction>
          </element>
          <!-- 录像控制命令（可选） -->
          <element name=" RecordCmd " type="tg:recordType" minOccurs= "0"/>
          <!-- 报警布防/撤防命令（可选） -->
          <element name=" GuardCmd " type="tg:guardType" minOccurs= "0"/>
          <!-- 报警复位命令（可选） -->
          <element name="AlarmCmd" minOccurs= "0">
          <restriction base="string">
          <enumeration value="ResetAlarm"/>
          </restriction>
          </element>
          <!-- 扩展信息，可多项 -->
          <element name= "Info" minOccurs= "0" maxOccurs="unbounded">
          <restriction base= "string">
          <maxLength value= "1024" />
          </restriction>
          </element>
      */

    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);
    inPacket.GetElementValue((char*)"PTZCmd", strPTZCmd);
    inPacket.GetElementValue((char*)"RecordCmd", strRecordCmd);
    inPacket.GetElementValue((char*)"GuardCmd", strGuardCmd);
    inPacket.GetElementValue((char*)"TeleBoot", strTeleBootCmd);
    inPacket.GetElementValue((char*)"AlarmCmd", strAlarmCmd);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_device_control_proc() \
    \r\n XML Para: \
    \r\n SN=%s, DeviceID=%s, PTZCmd=%s, RecordCmd=%s, GuardCmd=%s, TeleBoot=%s, AlarmCmd=%s \r\n", strSN, strDeviceID, strPTZCmd, strRecordCmd, strGuardCmd, strTeleBootCmd, strAlarmCmd);

    /* 重新启动 */
    if (strTeleBootCmd[0] != '\0')
    {
        if (0 == sstrcmp(strTeleBootCmd, (char*)"Boot"))
        {
            if (0 == sstrcmp(strDeviceID, local_cms_id_get()))
            {
                /* 发送去注册 */
                i = SendUnRegisterToAllRouteCMS();

                if (i < 0)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() SendUnRegisterToAllRouteCMS Error: iRet=%d \r\n", i);
                }
                else if (i > 0)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() SendUnRegisterToAllRouteCMS OK: iRet=%d \r\n", i);
                }

                osip_usleep(5000000);

                BoardReboot();

                return i;
            }
        }
    }

    /* 手动录像 */
    if (strRecordCmd[0] != '\0')
    {
        pGBLogicDeviceInfo = GBLogicDevice_info_find(strDeviceID);

        if (NULL != pGBLogicDeviceInfo)
        {
            pGBDeviceInfo = GBDevice_info_get_by_stream_type(pGBLogicDeviceInfo, EV9000_STREAM_TYPE_MASTER);

            if (EV9000_DEVICETYPE_SIPSERVER != pGBDeviceInfo->device_type)
            {
                if (0 == sstrcmp(strRecordCmd, (char*)"Record")) /* 开始手动录像 */
                {
                    if (0 == pGBLogicDeviceInfo->record_type) /* 本地录像 */
                    {
                        /* 启动录像 */
                        i = add_record_info_by_message_cmd(pGBLogicDeviceInfo->id, pDevice_Srv_dboper);

                        if (i != 0)
                        {
                            SystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的设备控制命令处理, 手动启动录像失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"添加录像任务失败");
                            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "The front-end equipment control command processing, Manually start the record failed:front-end equipment ID=%s, IP=%s, port=%d, logic device ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"Add video failed");
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() add_record_info_by_message_cmd Error \r\n");
                        }
                        else
                        {
                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的设备控制命令处理, 手动启动录像成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id);
                            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end equipment control command processing, Manually start the record successfully:front-end equipment ID=%s, IP=%s, port=%d, logic device ID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id);
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() add_record_info_by_message_cmd OK \r\n");
                        }

                        /* 组建XML信息 */
                        outPacket.SetRootTag("Response");
                        AccNode = outPacket.CreateElement((char*)"CmdType");
                        outPacket.SetElementValue(AccNode, (char*)"DeviceControl");

                        AccNode = outPacket.CreateElement((char*)"SN");
                        outPacket.SetElementValue(AccNode, strSN);

                        AccNode = outPacket.CreateElement((char*)"DeviceID");
                        outPacket.SetElementValue(AccNode, (char*)strDeviceID);

                        AccNode = outPacket.CreateElement((char*)"Result");
                        outPacket.SetElementValue(AccNode, (char*)"OK");

                        /* 发送响应消息给上级CMS */
                        i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

                        if (i != 0)
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() SIP_SendMessage Error:server_id=%s, server_ip=%s, server_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                        }
                        else
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() SIP_SendMessage OK:server_id=%s, server_ip=%s, server_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                        }

                        return i;
                    }
                }
                else if (0 == sstrcmp(strRecordCmd, (char*)"StopRecord")) /* 停止手动录像 */
                {
                    if (0 == pGBLogicDeviceInfo->record_type) /* 本地录像 */
                    {
                        /* 停止录像 */
                        i = del_record_info_by_message_cmd(pGBLogicDeviceInfo->id, pDevice_Srv_dboper);

                        if (i != 0)
                        {
                            SystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的设备控制命令处理, 手动停止录像失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"删除录像任务失败");
                            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "The front-end equipment control command processing, Manually stop the record failed:front-end equipment ID=%s, IP=%s, port=%d, logic device ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"delete record failed");
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() del_record_info_by_message_cmd Error \r\n");
                        }
                        else
                        {
                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的设备控制命令处理, 手动停止录像成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id);
                            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end equipment control command processing, Manually stop the record successfully:front-end equipment ID=%s, IP=%s, port=%d, logic device ID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id);
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() del_record_info_by_message_cmd OK \r\n");
                        }

                        /* 组建XML信息 */
                        outPacket.SetRootTag("Response");
                        AccNode = outPacket.CreateElement((char*)"CmdType");
                        outPacket.SetElementValue(AccNode, (char*)"DeviceControl");

                        AccNode = outPacket.CreateElement((char*)"SN");
                        outPacket.SetElementValue(AccNode, strSN);

                        AccNode = outPacket.CreateElement((char*)"DeviceID");
                        outPacket.SetElementValue(AccNode, (char*)strDeviceID);

                        AccNode = outPacket.CreateElement((char*)"Result");
                        outPacket.SetElementValue(AccNode, (char*)"OK");

                        /* 发送响应消息给上级CMS */
                        i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

                        if (i != 0)
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() SIP_SendMessage Error:server_id=%s, server_ip=%s, server_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                        }
                        else
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() SIP_SendMessage OK:server_id=%s, server_ip=%s, server_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                        }

                        return i;
                    }
                }
                else
                {
                    SystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的设备控制命令处理, 手动录像失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=不支持的录像命令:RecordCmd=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, strRecordCmd);
                    EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "Device control command process from front-end device, Manual recording failed:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, cause=do not support video command:RecordCmd=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, strRecordCmd);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() Record Cmd Error: RecordCmd=%s \r\n", strRecordCmd);
                }
            }
        }
        else
        {
            SystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的设备控制命令处理, 手动录像失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=查找逻辑设备失败:DeviceID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, strDeviceID);
            EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "Device control command process from front-end device, Manual recording failed:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, cause= search for logic device failed:DeviceID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, strDeviceID);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() exit---: Find GB LogicDevice Info Error: DeviceID=%s \r\n", strDeviceID);
        }
    }

    /* 布防、撤防 */
    if (strGuardCmd[0] != '\0')
    {
        pGBLogicDeviceInfo = GBLogicDevice_info_find(strDeviceID);

        if (NULL != pGBLogicDeviceInfo)
        {
            if (0 == sstrcmp(strGuardCmd, (char*)"SetGuard")) /* 布防*/
            {
                pGBLogicDeviceInfo->guard_type = 1;
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_device_control_proc() GBLogicDevice=%s, GuardStatus=%d \r\n", pGBLogicDeviceInfo->device_id, pGBLogicDeviceInfo->guard_type);
            }
            else if (0 == sstrcmp(strGuardCmd, (char*)"ResetGuard")) /*  撤防 */
            {
                pGBLogicDeviceInfo->guard_type = 0;
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_device_control_proc() GBLogicDevice=%s, GuardStatus=%d \r\n", pGBLogicDeviceInfo->device_id, pGBLogicDeviceInfo->guard_type);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_device_control_proc() Guard Cmd Error: GuardCmd=%s \r\n", strGuardCmd);
            }
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_device_control_proc() exit---: Find GB LogicDevice Info Error: DeviceID=%s \r\n", strDeviceID);
        }

        /* 组建XML信息 */
        outPacket.SetRootTag("Response");
        AccNode = outPacket.CreateElement((char*)"CmdType");
        outPacket.SetElementValue(AccNode, (char*)"DeviceControl");

        AccNode = outPacket.CreateElement((char*)"SN");
        outPacket.SetElementValue(AccNode, strSN);

        AccNode = outPacket.CreateElement((char*)"DeviceID");
        outPacket.SetElementValue(AccNode, (char*)strDeviceID);

        AccNode = outPacket.CreateElement((char*)"Result");
        outPacket.SetElementValue(AccNode, (char*)"OK");

        /* 发送响应消息给上级CMS */
        i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

        if (i != 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() SIP_SendMessage Error:server_id=%s, server_ip=%s, server_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() SIP_SendMessage OK:server_id=%s, server_ip=%s, server_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
        }
    }

    /* 报警复位 */
    if (strAlarmCmd[0] != '\0')
    {
        pGBLogicDeviceInfo = GBLogicDevice_info_find(strDeviceID);

        if (NULL != pGBLogicDeviceInfo)
        {
            if (0 == sstrcmp(strAlarmCmd, (char*)"ResetAlarm")) /* 复位告警 */
            {
                pGBLogicDeviceInfo->guard_type = 0;
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_device_control_proc() GBLogicDevice=%s, GuardStatus=%d \r\n", pGBLogicDeviceInfo->device_id, pGBLogicDeviceInfo->guard_type);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_device_control_proc() Alarm Cmd Error: AlarmCmd=%s \r\n", strAlarmCmd);
            }
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_device_control_proc() exit---: Find GB LogicDevice Info Error: DeviceID=%s \r\n", strDeviceID);
        }

        /* 组建XML信息 */
        outPacket.SetRootTag("Response");
        AccNode = outPacket.CreateElement((char*)"CmdType");
        outPacket.SetElementValue(AccNode, (char*)"DeviceControl");

        AccNode = outPacket.CreateElement((char*)"SN");
        outPacket.SetElementValue(AccNode, strSN);

        AccNode = outPacket.CreateElement((char*)"DeviceID");
        outPacket.SetElementValue(AccNode, (char*)strDeviceID);

        AccNode = outPacket.CreateElement((char*)"Result");
        outPacket.SetElementValue(AccNode, (char*)"OK");

        /* 发送响应消息给上级CMS */
        i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

        if (i != 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() SIP_SendMessage Error:server_id=%s, server_ip=%s, server_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() SIP_SendMessage OK:server_id=%s, server_ip=%s, server_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
        }
    }

    /* PTZ云台控制命令 */
    if (strPTZCmd[0] != '\0')
    {
        /* 如果是控球命令，检查逻辑点位是否被锁定，这里只要判断是否被锁定，用户锁定级别最高，锁定之后，前端设备不能控制 */
        pGBLogicDeviceInfo = GBLogicDevice_info_find(strDeviceID);

        if (NULL != pGBLogicDeviceInfo)
        {
            if (LOCK_STATUS_USER_LOCK == pGBLogicDeviceInfo->lock_status
                || LOCK_STATUS_ROUTE_LOCK == pGBLogicDeviceInfo->lock_status)
            {
                SystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备控制命令处理失败:前端设备ID=%s, 前端设备IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=逻辑设备已经被锁定", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID);
                EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device control command processing failed:Device ID=%s, Device IP=%s, Port=%d, Logic Device ID=%s,  reason=Logical device has been locked", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() Record Cmd Error: GBLogicDevice Locked: ID=%s \r\n", strDeviceID);
                return -1;
            }
        }
    }

    /* 转发消息到前端 */
    pGBLogicDeviceInfo = GBLogicDevice_info_find(strDeviceID);

    if (NULL != pGBLogicDeviceInfo)
    {
        /* 其他域的点位 */
        if (1 == pGBLogicDeviceInfo->other_realm)
        {
            /* 查找上级路由信息 */
            iCalleeRoutePos = route_info_find(pGBLogicDeviceInfo->cms_id);

            if (iCalleeRoutePos < 0)
            {
                SystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的设备控制命令处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=没有找到对应的上级路由信息:DeviceID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, callee_id);
                EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "Device control command process from front-end device failed:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, cause= corresponding route info not found:DeviceID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, callee_id);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() exit---: Get LogicDevice's Route Info Error: DeviceID=%s \r\n", callee_id);
                return -1;
            }

            pCalleeRouteInfo = route_info_get(iCalleeRoutePos);

            if (NULL == pCalleeRouteInfo)
            {
                SystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的设备控制命令处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=没有找到对应的上级路由信息:DeviceID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, callee_id);
                EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "Device control command process from front-end device failed:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, cause= corresponding route info not found:DeviceID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, callee_id);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() exit---: Get LogicDevice's Route Info Error: DeviceID=%s \r\n", callee_id);
                return -1;
            }

            if (strPTZCmd[0] != '\0') /* 可能是设置预置位操作的，前端有返回 */
            {
                iLen = String2Bytes((unsigned char*)strPTZCmd, szPtzCmd, PTZCMD_28181_LEN);

                if (szPtzCmd[3] == 0x81 || szPtzCmd[3] == 0x83)
                {
                    /* 获取老的SN节点 */
                    AccSnNode = inPacket.SearchElement((char*)"SN");

                    if (NULL != AccSnNode)
                    {
                        g_transfer_xml_sn++;
                        snprintf(strTransferSN, 32, "%u", g_transfer_xml_sn);
                        inPacket.SetElementValue(AccSnNode, strTransferSN);
                    }

                    i = SIP_SendMessage(NULL, local_cms_id_get(), callee_id, pCalleeRouteInfo->strRegLocalIP, pCalleeRouteInfo->iRegLocalPort, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port, (char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length());

                    if (i != 0)
                    {
                        SystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的设备控制命令处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, 前端物理设备ID=%s, IP=%s, 端口=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"转发消息到上级CMS失败", pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
                        EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "Device control command process from front-end device failed:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, cause=%s, front-end physical device ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"forward message to superior CMS failed", pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() SIP_SendMessage Error:server_id=%s, server_ip=%s, server_port=%d \r\n", pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
                    }
                    else
                    {
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的设备控制命令处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 前端物理设备ID=%s, IP=%s, 端口=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
                        EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_NORMAL, "Device control command process from front-end device successfully:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, front-end physical device ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() SIP_SendMessage OK:server_id=%s, server_ip=%s, server_port=%d \r\n", pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);

                        old_xml_sn = strtoul(strSN, NULL, 10);
                        transfer_xml_sn = strtoul(strTransferSN, NULL, 10);
                        i = transfer_xml_msg_add(XML_CONTROL_DEVICECONTROL, old_xml_sn, transfer_xml_sn, pCallerGBDeviceInfo->device_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, strDeviceID);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_device_control_proc() transfer_xml_msg_add: Type=%d, old_xml_sn=%u, transfer_xml_sn=%u, DeviceID=%s, pos=%d \r\n", XML_QUERY_RECORDINFO, old_xml_sn, transfer_xml_sn, strDeviceID, i);
                    }
                }
                else
                {
                    i = SIP_SendMessage(NULL, local_cms_id_get(), callee_id, pCalleeRouteInfo->strRegLocalIP, pCalleeRouteInfo->iRegLocalPort, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port, (char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length());

                    if (i != 0)
                    {
                        SystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的设备控制命令处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, 前端物理设备ID=%s, IP=%s, 端口=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"转发消息到上级CMS失败", pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
                        EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "Device control command process from front-end device failed:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, cause=%s, front-end physical device ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"forward message to superior CMS failed", pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() SIP_SendMessage Error:server_id=%s, server_ip=%s, server_port=%d \r\n", pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
                    }
                    else
                    {
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的设备控制命令处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 前端物理设备ID=%s, IP=%s, 端口=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
                        EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_NORMAL, "Device control command process from front-end device successfully:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, front-end physical device ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() SIP_SendMessage OK:server_id=%s, server_ip=%s, server_port=%d \r\n", pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
                    }
                }
            }
            else
            {
                i = SIP_SendMessage(NULL, local_cms_id_get(), callee_id, pCalleeRouteInfo->strRegLocalIP, pCalleeRouteInfo->iRegLocalPort, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port, (char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length());

                if (i != 0)
                {
                    SystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的设备控制命令处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, 前端物理设备ID=%s, IP=%s, 端口=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"转发消息到上级CMS失败", pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
                    EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "Device control command process from front-end device failed:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, cause=%s, front-end physical device ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"forward message to superior CMS failed", pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() SIP_SendMessage Error:server_id=%s, server_ip=%s, server_port=%d \r\n", pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
                }
                else
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的设备控制命令处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 前端物理设备ID=%s, IP=%s, 端口=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
                    EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_NORMAL, "Device control command process from front-end device successfully:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, front-end physical device ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() SIP_SendMessage OK:server_id=%s, server_ip=%s, server_port=%d \r\n", pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
                }
            }
        }
        else
        {
            pGBDeviceInfo = GBDevice_info_get_by_stream_type(pGBLogicDeviceInfo, EV9000_STREAM_TYPE_MASTER);

            if (NULL != pGBDeviceInfo)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() GBDeviceInfo device_type=%d\r\n", pGBDeviceInfo->device_type);

                if (strPTZCmd[0] != '\0')
                {
                    //如果是预置位命令，判断是否需要更新数据库,下级cms情况下不需要判断
                    if (EV9000_DEVICETYPE_SIPSERVER != pGBDeviceInfo->device_type)
                    {
                        i = preset_record(inPacket, pGBLogicDeviceInfo->id, pDevice_Srv_dboper);

                        if (i < 0)
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() Preset Record Error:device_id=%s \r\n", pGBDeviceInfo->device_id);

                            /* 组建XML信息 */
                            outPacket.SetRootTag("Response");
                            AccNode = outPacket.CreateElement((char*)"CmdType");
                            outPacket.SetElementValue(AccNode, (char*)"DeviceControl");

                            AccNode = outPacket.CreateElement((char*)"SN");
                            outPacket.SetElementValue(AccNode, strSN);

                            AccNode = outPacket.CreateElement((char*)"DeviceID");
                            outPacket.SetElementValue(AccNode, (char*)strDeviceID);

                            AccNode = outPacket.CreateElement((char*)"Result");
                            outPacket.SetElementValue(AccNode, (char*)"ERROR");

                            /* 发送响应消息给前端设备 */
                            i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

                            if (i != 0)
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() SIP_SendMessage Error:device_id=%s, login_ip=%s, login_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            }
                            else
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() SIP_SendMessage OK:device_id=%s, login_ip=%s, login_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            }

                            return -1;
                        }
                        else
                        {
                            /* 组建XML信息 */
                            outPacket.SetRootTag("Response");
                            AccNode = outPacket.CreateElement((char*)"CmdType");
                            outPacket.SetElementValue(AccNode, (char*)"DeviceControl");

                            AccNode = outPacket.CreateElement((char*)"SN");
                            outPacket.SetElementValue(AccNode, strSN);

                            AccNode = outPacket.CreateElement((char*)"DeviceID");
                            outPacket.SetElementValue(AccNode, (char*)strDeviceID);

                            AccNode = outPacket.CreateElement((char*)"Result");
                            outPacket.SetElementValue(AccNode, (char*)"OK");

                            /* 发送响应消息给前端设备 */
                            i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

                            if (i != 0)
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() SIP_SendMessage Error:device_id=%s, login_ip=%s, login_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            }
                            else
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() SIP_SendMessage OK:device_id=%s, login_ip=%s, login_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            }
                        }
                    }
                    else if (EV9000_DEVICETYPE_SIPSERVER == pGBDeviceInfo->device_type
                             && 1 == pGBDeviceInfo->three_party_flag) /* 第三方平台的下级点位 */
                    {
                        i = preset_record(inPacket, pGBLogicDeviceInfo->id, pDevice_Srv_dboper);

                        if (i < 0)
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() Preset Record Error:device_id=%s \r\n", pGBDeviceInfo->device_id);

                            /* 组建XML信息 */
                            outPacket.SetRootTag("Response");
                            AccNode = outPacket.CreateElement((char*)"CmdType");
                            outPacket.SetElementValue(AccNode, (char*)"DeviceControl");

                            AccNode = outPacket.CreateElement((char*)"SN");
                            outPacket.SetElementValue(AccNode, strSN);

                            AccNode = outPacket.CreateElement((char*)"DeviceID");
                            outPacket.SetElementValue(AccNode, (char*)strDeviceID);

                            AccNode = outPacket.CreateElement((char*)"Result");
                            outPacket.SetElementValue(AccNode, (char*)"ERROR");

                            /* 发送响应消息给前端设备 */
                            i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

                            if (i != 0)
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() SIP_SendMessage Error:device_id=%s, login_ip=%s, login_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            }
                            else
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() SIP_SendMessage OK:device_id=%s, login_ip=%s, login_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            }

                            return -1;
                        }
                        else
                        {
                            /* 组建XML信息 */
                            outPacket.SetRootTag("Response");
                            AccNode = outPacket.CreateElement((char*)"CmdType");
                            outPacket.SetElementValue(AccNode, (char*)"DeviceControl");

                            AccNode = outPacket.CreateElement((char*)"SN");
                            outPacket.SetElementValue(AccNode, strSN);

                            AccNode = outPacket.CreateElement((char*)"DeviceID");
                            outPacket.SetElementValue(AccNode, (char*)strDeviceID);

                            AccNode = outPacket.CreateElement((char*)"Result");
                            outPacket.SetElementValue(AccNode, (char*)"OK");

                            /* 发送响应消息给前端设备 */
                            i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

                            if (i != 0)
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() SIP_SendMessage Error:device_id=%s, login_ip=%s, login_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            }
                            else
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() SIP_SendMessage OK:device_id=%s, login_ip=%s, login_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            }
                        }
                    }
                }

                if (strPTZCmd[0] != '\0') /* 可能是设置预置位操作的，前端有返回 */
                {
                    if (EV9000_DEVICETYPE_SIPSERVER == pGBDeviceInfo->device_type
                        && 0 == pGBDeviceInfo->three_party_flag) /* 下级点位 */
                    {
                        iLen = String2Bytes((unsigned char*)strPTZCmd, szPtzCmd, PTZCMD_28181_LEN);

                        if (szPtzCmd[3] == 0x81 || szPtzCmd[3] == 0x83)
                        {
                            /* 获取老的SN节点 */
                            AccSnNode = inPacket.SearchElement((char*)"SN");

                            if (NULL != AccSnNode)
                            {
                                g_transfer_xml_sn++;
                                snprintf(strTransferSN, 32, "%u", g_transfer_xml_sn);
                                inPacket.SetElementValue(AccSnNode, strTransferSN);
                            }

                            i = SIP_SendMessage(NULL, local_cms_id_get(), callee_id, pGBDeviceInfo->strRegServerIP, pGBDeviceInfo->iRegServerPort, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length());

                            if (i != 0)
                            {
                                SystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的设备控制命令处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, 前端物理设备ID=%s, IP=%s, 端口=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"转发消息到前端物理设备失败", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                                EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "Device control command process from front-end device failed:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, cause=%s, front-end physical device ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"forward message to frond-end physical device failed", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() SIP_SendMessage Error:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                            }
                            else
                            {
                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的设备控制命令处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 前端物理设备ID=%s, IP=%s, 端口=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                                EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_NORMAL, "Device control command process from front-end device successfully:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, front-end physical device ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() SIP_SendMessage OK:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

                                old_xml_sn = strtoul(strSN, NULL, 10);
                                transfer_xml_sn = strtoul(strTransferSN, NULL, 10);
                                i = transfer_xml_msg_add(XML_CONTROL_DEVICECONTROL, old_xml_sn, transfer_xml_sn, pCallerGBDeviceInfo->device_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, strDeviceID);
                                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_device_control_proc() transfer_xml_msg_add: Type=%d, old_xml_sn=%u, transfer_xml_sn=%u, DeviceID=%s, pos=%d \r\n", XML_QUERY_RECORDINFO, old_xml_sn, transfer_xml_sn, strDeviceID, i);
                            }
                        }
                        else
                        {
                            i = SIP_SendMessage(NULL, local_cms_id_get(), callee_id, pGBDeviceInfo->strRegServerIP, pGBDeviceInfo->iRegServerPort, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length());

                            if (i != 0)
                            {
                                SystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的设备控制命令处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, 前端物理设备ID=%s, IP=%s, 端口=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"转发消息到前端物理设备失败", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                                EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "Device control command process from front-end device failed:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, cause=%s, front-end physical device ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"forward message to frond-end physical device failed", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() SIP_SendMessage Error:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                            }
                            else
                            {
                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的设备控制命令处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 前端物理设备ID=%s, IP=%s, 端口=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                                EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_NORMAL, "Device control command process from front-end device successfully:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, front-end physical device ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() SIP_SendMessage OK:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                            }
                        }
                    }
                    else
                    {
                        i = SIP_SendMessage(NULL, local_cms_id_get(), callee_id, pGBDeviceInfo->strRegServerIP, pGBDeviceInfo->iRegServerPort, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length());

                        if (i != 0)
                        {
                            SystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的设备控制命令处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, 前端物理设备ID=%s, IP=%s, 端口=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"转发消息到前端物理设备失败", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                            EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "Device control command process from front-end device failed:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, cause=%s, front-end physical device ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"forward message to frond-end physical device failed", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() SIP_SendMessage Error:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        }
                        else
                        {
                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的设备控制命令处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 前端物理设备ID=%s, IP=%s, 端口=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                            EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_NORMAL, "Device control command process from front-end device successfully:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, front-end physical device ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() SIP_SendMessage OK:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        }
                    }
                }
                else
                {
                    i = SIP_SendMessage(NULL, local_cms_id_get(), callee_id, pGBDeviceInfo->strRegServerIP, pGBDeviceInfo->iRegServerPort, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length());

                    if (i != 0)
                    {
                        SystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的设备控制命令处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, 前端物理设备ID=%s, IP=%s, 端口=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"转发消息到前端物理设备失败", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "Device control command process from front-end device failed:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, cause=%s, front-end physical device ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"forward message to frond-end physical device failed", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() SIP_SendMessage Error:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    }
                    else
                    {
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的设备控制命令处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 前端物理设备ID=%s, IP=%s, 端口=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_NORMAL, "Device control command process from front-end device successfully:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, front-end physical device ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() SIP_SendMessage OK:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    }
                }
            }
            else
            {
                SystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的设备控制命令处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=没有找到对应的物理设备信息:DeviceID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, callee_id);
                EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "Device control command process from front-end device failed:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, cause= corresponding physical device info not found:DeviceID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, callee_id);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() exit---: Get LogicDevice's GBDevice Info Error: DeviceID=%s \r\n", callee_id);
                return -1;
            }
        }
    }
    else
    {
        pGBDeviceInfo = GBDevice_info_find(strDeviceID);

        if (NULL != pGBDeviceInfo)
        {
            i = SIP_SendMessage(NULL, local_cms_id_get(), callee_id, pGBDeviceInfo->strRegServerIP, pGBDeviceInfo->iRegServerPort, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length());

            if (i != 0)
            {
                SystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的设备控制命令处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=%s, 前端物理设备ID=%s, IP=%s, 端口=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"转发消息到前端物理设备失败", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "Device control command process from front-end device failed:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, cause=%s, front-end physical device ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, (char*)"forward message to frond-end physical device failed", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() SIP_SendMessage Error:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            }
            else
            {
                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的设备控制命令处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 前端物理设备ID=%s, IP=%s, 端口=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_NORMAL, "Device control command process from front-end device successfully:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, front-end physical device ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_proc() SIP_SendMessage OK:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            }
        }
        else
        {
            SystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的设备控制命令处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 原因=没有找到对应的物理设备信息:DeviceID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, callee_id);
            EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "Device control command process from front-end device failed:Requester ID=%s, IP address=%s, port number=%d, logic device ID=%s, cause=corresponding physical device info not found:DeviceID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, callee_id, callee_id);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_proc() exit---: Find GBDevice Info Error: DeviceID=%s \r\n", callee_id);
            return -1;
        }
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_query_catalog_proc
 功能描述  : 用户查询设备目录
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月21日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_query_catalog_proc(GBDevice_info_t* pGBDeviceInfo, char* caller_id, char* callee_id, CPacket& inPacket, DBOper* pDevice_Srv_dboper)
{
    int i = 0;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_catalog_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_catalog_proc() exit---: Route Srv DB Oper Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的获取逻辑设备信息:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end device query logical device information:front-end device ID=%s, IP=%s, port=%d, Logic Device ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);

    /* 网络设备信息查询
          控制流程见9.5.2
          设备目录查询的命令直接转发给前段设备，不做处理

          命令包括如下字段:
          <!-- 命令类型：设备目录查询（必选） -->
          <element name="CmdType" fixed ="Catalog" />
          <!-- 命令序列号（必选） -->
          <element name="SN" type="integer" minInclusive value = "1" />
          <!-- 目标设备的设备编码（必选） -->
          <element name="DeviceID" type="tg:deviceIDType" />
      */
    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_catalog_proc() \
            \r\n XML Para: \
            \r\n SN=%s, DeviceID=%s \r\n", strSN, strDeviceID);


    /* 查看被叫是否是本CMS ID */
    if (0 == strncmp(callee_id, local_cms_id_get(), 20))
    {
        if (0 == sstrcmp(callee_id, strDeviceID)) /* 如果查询的设备ID为本CMS ID，表示获取本设备列表*/
        {
            i = GetGBDeviceListAndSendCataLogToDeviceClient(pGBDeviceInfo, caller_id, strDeviceID, strSN, pDevice_Srv_dboper);
        }
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的获取逻辑设备信息成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end device query logical device information succeed:front-end device ID=%s, IP=%s, port=%d, Logic Device ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_catalog_proc() Exit---\r\n");

    return i;
}

/*****************************************************************************
 函 数 名  : user_query_device_info_proc
 功能描述  : 用户查询设备信息处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月13日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_query_device_info_proc(GBDevice_info_t* pGBDeviceInfo, char* caller_id, char* callee_id, CPacket& inPacket)
{

    /* 网络设备信息查询
          控制流程见9.5.2
          该命令由客户端发出，设备端暂时没有此类消息处理

          命令包括如下字段:
          <!-- 命令类型：设备信息查询（必选） -->
          <element name="CmdType" fixed ="DeviceInfo" />
          <!-- 命令序列号（必选） -->
          <element name="SN" type="integer" minInclusive value = "1" />
          <!-- 目标设备的设备编码（必选） -->
          <element name="DeviceID" type="tg:deviceIDType" />
      */
    return 0;
}

/*****************************************************************************
 函 数 名  : user_query_device_status_proc
 功能描述  : 用户查询设备状态处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月13日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_query_device_status_proc(GBDevice_info_t* pGBDeviceInfo, char* caller_id, char* callee_id, CPacket& inPacket)
{

    /* 网络设备信息查询
          控制流程见9.5.2
          该命令由客户端发出，设备端暂时没有此类消息处理

          命令包括如下字段:
          <!-- 命令类型：设备状态查询（必选） -->
          <element name="CmdType" fixed ="DeviceStatus" />
          <!-- 命令序列号（必选） -->
          <element name="SN" type="integer" minInclusive value = "1" />
          <!-- 目标设备的设备编码（必选） -->
          <element name="DeviceID" type="tg:deviceIDType" />
      */

    return 0;
}

/*****************************************************************************
 函 数 名  : device_query_record_info_proc
 功能描述  : 前端设备过来的查询设备视频文件处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月13日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_query_record_info_proc(GBDevice_info_t* pCallerGBDeviceInfo, char* caller_id, char* callee_id, CPacket& inPacket, DBOper* pDevice_Srv_dboper)
{
    /* 设备视音频文件检索
          控制流程见9.7.2
      */
    int i = 0;
    int iRet = 0;
    int index = 0;
    int tsu_index = -1;
    int record_count = 0;
    int query_count = 0;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strRecordType[32] = {0};
    char strStartTime[32] = {0};
    char strEndTime[32] = {0};
    char strFilePath[32] = {0};
    char strAddress[32] = {0};
    char strSecrecy[32] = {0};
    char str3PartFlag[16] = {0};
    char strRecorderID[32] = {0};
    char strErrorCode[32] = {0};

    GBDevice_info_t* pGBDeviceInfo = NULL;
    GBLogicDevice_info_t* pGBLogicDeviceInfo = NULL;
    tsu_resource_info_t* pTsuResourceInfo = NULL;
    VideoRecordList stVideoRecordList;
    unsigned int iStartTime = 0;
    unsigned int iEndTime = 0;
    int record_type = 0;

    DOMElement* RecordListAccNode = NULL;
    //DOMElement* AccSnNode = NULL;
    char strTransferSN[32] = {0};
    unsigned int old_xml_sn = 0;
    unsigned int transfer_xml_sn = 0;

    int iCalleeRoutePos = 0;
    route_info_t* pCalleeRouteInfo = NULL;

    int record_info_pos = -1;
    record_info_t* pRecordInfo = NULL;

    int iRecordCRPos = -1;
    cr_t* pRecordCrData = NULL;

    if (NULL == pCallerGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_record_info_proc() exit---: Device Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_record_info_proc() exit---: Device Srv DB Oper Error \r\n");
        return -1;
    }

    /* 取得查询条件数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);
    inPacket.GetElementValue((char*)"StartTime", strStartTime);
    inPacket.GetElementValue((char*)"EndTime", strEndTime);
    inPacket.GetElementValue((char*)"FilePath", strFilePath);
    inPacket.GetElementValue((char*)"Address", strAddress);
    inPacket.GetElementValue((char*)"Secrecy", strSecrecy);
    inPacket.GetElementValue((char*)"Type", strRecordType);
    inPacket.GetElementValue((char*)"ThreeParty", str3PartFlag);
    inPacket.GetElementValue((char*)"RecorderID", strRecorderID);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_record_info_proc() \
        \r\n XML Param: \
        \r\n SN=%s \
        \r\n DeviceID=%s \
        \r\n RecordType=%s \
        \r\n StartTime=%s \
        \r\n EndTime=%s \
        \r\n", strSN, strDeviceID, strRecordType, strStartTime, strEndTime);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询录像记录信息:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Search for video record info from Front-end device:Device ID=%s, IP address=%s, port number=%d, logic deviceID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID);

    /* 1、获取录像点位信息 */
    pGBLogicDeviceInfo = GBLogicDevice_info_find(strDeviceID);

    if (NULL == pGBLogicDeviceInfo)
    {
        /* 回复响应,组建消息 */
        CPacket outPacket;
        DOMElement* AccNode = NULL;

        outPacket.SetRootTag("Response");

        AccNode = outPacket.CreateElement((char*)"CmdType");
        outPacket.SetElementValue(AccNode, (char*)"RecordInfo");

        AccNode = outPacket.CreateElement((char*)"SN");
        outPacket.SetElementValue(AccNode, strSN);

        AccNode = outPacket.CreateElement((char*)"DeviceID");
        outPacket.SetElementValue(AccNode, strDeviceID);

        AccNode = outPacket.CreateElement((char*)"Name");
        outPacket.SetElementValue(AccNode, (char*)" ");

        AccNode = outPacket.CreateElement((char*)"SumNum");
        outPacket.SetElementValue(AccNode, (char*)"-1");

        AccNode = outPacket.CreateElement((char*)"ErrCode");
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_DEVICE_FIND_LOGIC_DEVICE_INFO_ERROR);
        outPacket.SetElementValue(AccNode, strErrorCode);

        AccNode = outPacket.CreateElement((char*)"Reason");
        outPacket.SetElementValue(AccNode, (char*)"获取逻辑设备信息失败");

        RecordListAccNode = outPacket.CreateElement((char*)"RecordList");
        outPacket.SetElementAttr(RecordListAccNode, (char*)"Num", (char*)"-1");

        /* 发送响应消息 给上级CMS */
        i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

        if (i != 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() SIP_SendMessage Error:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_record_info_proc() SIP_SendMessage OK:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
        }

        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() exit---: Get GBLogic Device Info Error \r\n");
        SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"获取逻辑设备信息失败");
        EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for video record info from Front-end device failed:Device ID=%s, IP address=%s, port number=%d, cause=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"Access logical device information failed");
        return -1;
    }

    /* 看是否是其他域的点位 */
    if (1 == pGBLogicDeviceInfo->other_realm)
    {
        /* 查找上级路由信息 */
        iCalleeRoutePos = route_info_find(pGBLogicDeviceInfo->cms_id);

        if (iCalleeRoutePos < 0)
        {
            /* 回复响应,组建消息 */
            CPacket outPacket;
            DOMElement* AccNode = NULL;

            outPacket.SetRootTag("Response");

            AccNode = outPacket.CreateElement((char*)"CmdType");
            outPacket.SetElementValue(AccNode, (char*)"RecordInfo");

            AccNode = outPacket.CreateElement((char*)"SN");
            outPacket.SetElementValue(AccNode, strSN);

            AccNode = outPacket.CreateElement((char*)"DeviceID");
            outPacket.SetElementValue(AccNode, strDeviceID);

            AccNode = outPacket.CreateElement((char*)"Name");
            outPacket.SetElementValue(AccNode, (char*)" ");

            AccNode = outPacket.CreateElement((char*)"SumNum");
            outPacket.SetElementValue(AccNode, (char*)"-1");

            AccNode = outPacket.CreateElement((char*)"ErrCode");
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_ROUTE_FIND_ROUTE_INFO_ERROR);
            outPacket.SetElementValue(AccNode, strErrorCode);

            AccNode = outPacket.CreateElement((char*)"Reason");
            outPacket.SetElementValue(AccNode, (char*)"获取路由信息失败");

            RecordListAccNode = outPacket.CreateElement((char*)"RecordList");
            outPacket.SetElementAttr(RecordListAccNode, (char*)"Num", (char*)"-1");

            /* 发送响应消息 给上级CMS */
            i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

            if (i != 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() SIP_SendMessage Error:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_record_info_proc() SIP_SendMessage OK:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            }

            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() exit---: Get GBLogic Device Info Error \r\n");
            SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"获取路由信息失败");
            EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for video record info from Front-end device failed:Device ID=%s, IP address=%s, port number=%d, cause=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"Get route information failed");
            return -1;
        }

        pCalleeRouteInfo = route_info_get(iCalleeRoutePos);

        if (NULL == pCalleeRouteInfo)
        {
            /* 回复响应,组建消息 */
            CPacket outPacket;
            DOMElement* AccNode = NULL;

            outPacket.SetRootTag("Response");

            AccNode = outPacket.CreateElement((char*)"CmdType");
            outPacket.SetElementValue(AccNode, (char*)"RecordInfo");

            AccNode = outPacket.CreateElement((char*)"SN");
            outPacket.SetElementValue(AccNode, strSN);

            AccNode = outPacket.CreateElement((char*)"DeviceID");
            outPacket.SetElementValue(AccNode, strDeviceID);

            AccNode = outPacket.CreateElement((char*)"Name");
            outPacket.SetElementValue(AccNode, (char*)" ");

            AccNode = outPacket.CreateElement((char*)"SumNum");
            outPacket.SetElementValue(AccNode, (char*)"-1");

            AccNode = outPacket.CreateElement((char*)"ErrCode");
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_ROUTE_GET_ROUTE_INFO_ERROR);
            outPacket.SetElementValue(AccNode, strErrorCode);

            AccNode = outPacket.CreateElement((char*)"Reason");
            outPacket.SetElementValue(AccNode, (char*)"获取路由信息失败");

            RecordListAccNode = outPacket.CreateElement((char*)"RecordList");
            outPacket.SetElementAttr(RecordListAccNode, (char*)"Num", (char*)"-1");

            /* 发送响应消息 给上级CMS */
            i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

            if (i != 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() SIP_SendMessage Error:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_record_info_proc() SIP_SendMessage OK:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            }

            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() exit---: Get GBLogic Device Info Error \r\n");
            SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"获取路由信息失败");
            EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for video record info from Front-end device failed:Device ID=%s, IP address=%s, port number=%d, cause=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"Get route information failed");
            return -1;
        }

        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询录像记录信息是上级CMS中的点位:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 所在的上级CMS ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Searching for video record info from Front-end device that belongs to route CMS:Front-end device ID=%s, IP=%s, port=%d, logic device ID=%s, route CMS ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);

        /* 从新组建消息 */
        CPacket outPacket;
        DOMElement* AccNode = NULL;

        outPacket.SetRootTag("Query");

        AccNode = outPacket.CreateElement((char*)"CmdType");
        outPacket.SetElementValue(AccNode, (char*)"RecordInfo");

        AccNode = outPacket.CreateElement((char*)"SN");
        g_transfer_xml_sn++;
        snprintf(strTransferSN, 32, "%u", g_transfer_xml_sn);
        outPacket.SetElementValue(AccNode, strTransferSN);

        AccNode = outPacket.CreateElement((char*)"DeviceID");
        outPacket.SetElementValue(AccNode, strDeviceID);

        AccNode = outPacket.CreateElement((char*)"StartTime");
        outPacket.SetElementValue(AccNode, strStartTime);

        AccNode = outPacket.CreateElement((char*)"EndTime");
        outPacket.SetElementValue(AccNode, strEndTime);

        AccNode = outPacket.CreateElement((char*)"Type");

        if (strRecordType[0] != 0)
        {
            outPacket.SetElementValue(AccNode, strRecordType);
        }
        else
        {
            outPacket.SetElementValue(AccNode, (char*)"all");
        }

        /* 第三方设备查询录像的命令，如果转到上级去，上级平台是自己的话，需要加上第三方标识 */
        if (1 == pCallerGBDeviceInfo->three_party_flag && 0 == pCalleeRouteInfo->three_party_flag)
        {
            AccNode = outPacket.CreateElement((char*)"ThreeParty");
            outPacket.SetElementValue(AccNode, (char*)"YES");
        }

        AccNode = outPacket.CreateElement((char*)"RecorderID");
        outPacket.SetElementValue(AccNode, pCalleeRouteInfo->server_id);

        /* 将查询录像任务的消息转发出去 */
        i = SIP_SendMessage(NULL, local_cms_id_get(), pCalleeRouteInfo->server_id, pCalleeRouteInfo->strRegLocalIP, pCalleeRouteInfo->iRegLocalPort, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

        if (i != 0)
        {
            SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s, 转发上级CMS ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"转发查询消息到上级CMS失败", pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
            EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for video record info from Front-end device , forward search info to superior CMS failed:Front-end device ID=%s, IP address=%s, port number=%d, superior CMS ID=%s, IPaddress =%s, port number=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() SIP_SendMessage Error:device_id=%s, device_ip=%s, device_port=%d \r\n", pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
        }
        else
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询录像记录信息成功,转发查询消息到上级CMS:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 转发上级CMS ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Search for video record info from Front-end device , forward search info to superior CMS successfully:Front-end device ID=%s, IP address=%s, port number=%d, superior CMS ID=%s, IPaddress =%s, port number=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_record_info_proc() SIP_SendMessage OK:device_id=%s, device_ip=%s, device_port=%d \r\n", pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);

            old_xml_sn = strtoul(strSN, NULL, 10);
            transfer_xml_sn = strtoul(strTransferSN, NULL, 10);
            i = transfer_xml_msg_add(XML_QUERY_RECORDINFO, old_xml_sn, transfer_xml_sn, pCallerGBDeviceInfo->device_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, strDeviceID);
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_query_record_info_proc() transfer_xml_msg_add: Type=%d, old_xml_sn=%u, transfer_xml_sn=%u, DeviceID=%s, pos=%d \r\n", XML_QUERY_RECORDINFO, old_xml_sn, transfer_xml_sn, strDeviceID, i);
        }

        return i;
    }

    /* 确定录像类型 */
    if (strRecordType[0] != 0)
    {
        record_type = osip_atoi(strRecordType);
    }
    else
    {
        record_type = EV9000_RECORD_TYPE_NORMAL;
    }

    if (record_type <= 0)
    {
        record_type = EV9000_RECORD_TYPE_NORMAL;
    }

    /* 获取逻辑设备所属的物理设备 */
    if (EV9000_RECORD_TYPE_NORMAL == record_type
        || EV9000_RECORD_TYPE_BACKUP == record_type
        || EV9000_RECORD_TYPE_ALARM == record_type)
    {
        pGBDeviceInfo = GBDevice_info_get_by_stream_type(pGBLogicDeviceInfo, EV9000_STREAM_TYPE_MASTER);
    }
    else
    {
        pGBDeviceInfo = GBDevice_info_get_by_stream_type(pGBLogicDeviceInfo, EV9000_STREAM_TYPE_INTELLIGENCE);
    }

    if (NULL == pGBDeviceInfo)
    {
        /* 回复响应,组建消息 */
        CPacket outPacket;
        DOMElement* AccNode = NULL;

        outPacket.SetRootTag("Response");

        AccNode = outPacket.CreateElement((char*)"CmdType");
        outPacket.SetElementValue(AccNode, (char*)"RecordInfo");

        AccNode = outPacket.CreateElement((char*)"SN");
        outPacket.SetElementValue(AccNode, strSN);

        AccNode = outPacket.CreateElement((char*)"DeviceID");
        outPacket.SetElementValue(AccNode, strDeviceID);

        AccNode = outPacket.CreateElement((char*)"Name");
        outPacket.SetElementValue(AccNode, pGBLogicDeviceInfo->device_name);

        AccNode = outPacket.CreateElement((char*)"SumNum");
        outPacket.SetElementValue(AccNode, (char*)"-1");

        AccNode = outPacket.CreateElement((char*)"ErrCode");
        memset(strErrorCode, 0, 32);
        snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_DEVICE_GET_DEVICE_INFO_ERROR);
        outPacket.SetElementValue(AccNode, strErrorCode);

        AccNode = outPacket.CreateElement((char*)"Reason");
        outPacket.SetElementValue(AccNode, (char*)"获取物理设备信息失败");

        RecordListAccNode = outPacket.CreateElement((char*)"RecordList");
        outPacket.SetElementAttr(RecordListAccNode, (char*)"Num", (char*)"-1");

        /* 发送响应消息 给上级CMS */
        i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

        if (i != 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() SIP_SendMessage Error:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_record_info_proc() SIP_SendMessage OK:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
        }

        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() exit---: Get GBLogic Device Info Error \r\n");
        SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"获取物理设备信息失败");
        EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for video record info from Front-end device failed:Device ID=%s, IP address=%s, port number=%d, cause=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"Access physical device info failed");
        return -1;
    }

    /* 查看该点位本地是否配置了录像，如果配置了，则在本地查找录像记录 */
    if (EV9000_RECORD_TYPE_NORMAL == record_type
        || EV9000_RECORD_TYPE_ALARM == record_type)
    {
        record_info_pos = record_info_find_by_stream_type(pGBLogicDeviceInfo->id, EV9000_STREAM_TYPE_MASTER);
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_query_record_info_proc() record_info_find_by_stream_type:device_id=%s, stream_type=%d, record_info_pos=%d \r\n", pGBLogicDeviceInfo->device_id, EV9000_STREAM_TYPE_MASTER, record_info_pos);
    }
    else if (EV9000_RECORD_TYPE_BACKUP == record_type)
    {
        record_info_pos = record_info_find_by_stream_type(pGBLogicDeviceInfo->id, EV9000_STREAM_TYPE_SLAVE);
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_query_record_info_proc() record_info_find_by_stream_type:device_id=%s, stream_type=%d, record_info_pos=%d \r\n", pGBLogicDeviceInfo->device_id, EV9000_STREAM_TYPE_SLAVE, record_info_pos);
    }
    else if (EV9000_RECORD_TYPE_INTELLIGENCE == record_type)
    {
        record_info_pos = record_info_find_by_stream_type(pGBLogicDeviceInfo->id, EV9000_STREAM_TYPE_INTELLIGENCE);
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_query_record_info_proc() record_info_find_by_stream_type:device_id=%s, stream_type=%d, record_info_pos=%d \r\n", pGBLogicDeviceInfo->device_id, EV9000_STREAM_TYPE_INTELLIGENCE, record_info_pos);
    }
    else
    {
        record_info_pos = record_info_find_by_stream_type(pGBLogicDeviceInfo->id, EV9000_STREAM_TYPE_MASTER);
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_query_record_info_proc() record_info_find_by_stream_type:device_id=%s, stream_type=%d, record_info_pos=%d \r\n", pGBLogicDeviceInfo->device_id, EV9000_STREAM_TYPE_MASTER, record_info_pos);
    }

    if (record_info_pos >= 0)
    {
        pRecordInfo = record_info_get(record_info_pos);

        if (NULL != pRecordInfo)
        {
            if (1 == pRecordInfo->record_enable)
            {
                goto normal_record;
            }
        }
    }

    if (pGBDeviceInfo->device_type == EV9000_DEVICETYPE_SIPSERVER) /* 下级cms 的录像  */
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询录像记录信息是下级CMS中的点位:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 所在的下级CMS ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Searching for video record info from Front-end device that belongs to lower CMS:Front-end device ID=%s, IP=%s, port=%d, logic device ID=%s, route CMS ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        /* 从新组建消息 */
        CPacket outPacket;
        DOMElement* AccNode = NULL;

        outPacket.SetRootTag("Query");

        AccNode = outPacket.CreateElement((char*)"CmdType");
        outPacket.SetElementValue(AccNode, (char*)"RecordInfo");

        AccNode = outPacket.CreateElement((char*)"SN");
        g_transfer_xml_sn++;
        snprintf(strTransferSN, 32, "%u", g_transfer_xml_sn);
        outPacket.SetElementValue(AccNode, strTransferSN);

        AccNode = outPacket.CreateElement((char*)"DeviceID");
        outPacket.SetElementValue(AccNode, strDeviceID);

        AccNode = outPacket.CreateElement((char*)"StartTime");
        outPacket.SetElementValue(AccNode, strStartTime);

        AccNode = outPacket.CreateElement((char*)"EndTime");
        outPacket.SetElementValue(AccNode, strEndTime);

        AccNode = outPacket.CreateElement((char*)"Type");

        if (1 == pGBDeviceInfo->three_party_flag)
        {
            outPacket.SetElementValue(AccNode, (char*)"all");
        }
        else
        {
            if (strRecordType[0] != 0)
            {
                outPacket.SetElementValue(AccNode, strRecordType);
            }
            else
            {
                outPacket.SetElementValue(AccNode, (char*)"all");
            }
        }

        /* 第三方设备查询录像的命令，如果转到下级去，下级平台是自己的话，需要加上第三方标识 */
        if (1 == pCallerGBDeviceInfo->three_party_flag && 0 == pGBDeviceInfo->three_party_flag)
        {
            AccNode = outPacket.CreateElement((char*)"ThreeParty");
            outPacket.SetElementValue(AccNode, (char*)"YES");
        }

        AccNode = outPacket.CreateElement((char*)"RecorderID");
        outPacket.SetElementValue(AccNode, pGBDeviceInfo->device_id);

        /* 将查询录像任务的消息转发出去 */
        i = SIP_SendMessage(NULL, local_cms_id_get(), strDeviceID, pGBDeviceInfo->strRegServerIP, pGBDeviceInfo->iRegServerPort, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

        if (i != 0)
        {
            SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s, 下级CMS ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"转发查询消息到下级CMS失败", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Searching for video record info from Front-end device that belongs to lower CMS:Front-end device ID=%s, IP=%s, port=%d, logic device ID=%s, route CMS ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() SIP_SendMessage Error:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        }
        else
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询录像记录信息成功,转发查询消息到下级CMS:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 下级CMS ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Search for video record info from Front-end device suceessfully, forwarding query message to the CMS at a lower level :front-end device ID=%s, IP=%s, port=%d, logic device ID=%s, lower CMS ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_record_info_proc() SIP_SendMessage OK:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

            old_xml_sn = strtoul(strSN, NULL, 10);
            transfer_xml_sn = strtoul(strTransferSN, NULL, 10);
            i = transfer_xml_msg_add(XML_QUERY_RECORDINFO, old_xml_sn, transfer_xml_sn, pCallerGBDeviceInfo->device_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, strDeviceID);
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_query_record_info_proc() transfer_xml_msg_add: Type=%d, old_xml_sn=%u, transfer_xml_sn=%u, DeviceID=%s, pos=%d \r\n", XML_QUERY_RECORDINFO, old_xml_sn, transfer_xml_sn, strDeviceID, i);
        }

        return i;
    }
    else if (1 == pGBLogicDeviceInfo->record_type) /* 前端录像的情况下，直接转发给前端处理 */
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询录像记录信息的点位是在前端录像, 前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 所在的前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Searching for video record info from Front-end device that belongs to front-end:Front-end device ID=%s, IP=%s, port=%d, logic device ID=%s, front-end ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        /* 从新组建消息 */
        CPacket outPacket;
        DOMElement* AccNode = NULL;

        outPacket.SetRootTag("Query");

        AccNode = outPacket.CreateElement((char*)"CmdType");
        outPacket.SetElementValue(AccNode, (char*)"RecordInfo");

        AccNode = outPacket.CreateElement((char*)"SN");
        g_transfer_xml_sn++;
        snprintf(strTransferSN, 32, "%u", g_transfer_xml_sn);
        outPacket.SetElementValue(AccNode, strTransferSN);

        AccNode = outPacket.CreateElement((char*)"DeviceID");
        outPacket.SetElementValue(AccNode, strDeviceID);

        AccNode = outPacket.CreateElement((char*)"StartTime");
        outPacket.SetElementValue(AccNode, strStartTime);

        AccNode = outPacket.CreateElement((char*)"EndTime");
        outPacket.SetElementValue(AccNode, strEndTime);

        AccNode = outPacket.CreateElement((char*)"Type");

        /* 如果是NVR或者DVR,则要改为all */
        if (EV9000_DEVICETYPE_IPC == pGBDeviceInfo->device_type
            || EV9000_DEVICETYPE_DVR == pGBDeviceInfo->device_type
            || EV9000_DEVICETYPE_NVR == pGBDeviceInfo->device_type)
        {
            outPacket.SetElementValue(AccNode, (char*)"all");
        }
        else
        {
            if (strRecordType[0] != 0)
            {
                outPacket.SetElementValue(AccNode, strRecordType);
            }
            else
            {
                outPacket.SetElementValue(AccNode, (char*)"all");
            }
        }

        /* 第三方设备查询录像的命令，如果转到前端媒体网关去，前端媒体网关是自己的话，需要加上第三方标识 */
        if (EV9000_DEVICETYPE_MGWSERVER == pGBDeviceInfo->device_type)
        {
            if (1 == pCallerGBDeviceInfo->three_party_flag && 0 == pGBDeviceInfo->three_party_flag)
            {
                AccNode = outPacket.CreateElement((char*)"ThreeParty");
                outPacket.SetElementValue(AccNode, (char*)"YES");
            }
        }

        AccNode = outPacket.CreateElement((char*)"RecorderID");
        outPacket.SetElementValue(AccNode, pGBDeviceInfo->device_id);

        /* 将查询录像任务的消息转发出去 */
        i = SIP_SendMessage(NULL, local_cms_id_get(), strDeviceID, pGBDeviceInfo->strRegServerIP, pGBDeviceInfo->iRegServerPort, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

        if (i != 0)
        {
            SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s, 转发前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"转发查询消息到前端设备失败", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for video record info from Front-end device , forward search info to front-end device failed:Front-end device ID=%s, IP address=%s, port number=%d, front-end numberID=%s, IP address=%s, port number=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() SIP_SendMessage Error:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        }
        else
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询录像记录信息成功,转发查询消息到前端设备:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 转发前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Search for video record info from Front-end device successfully, forward search info to front-end device :Front-end device ID=%s, IP address=%s, port number=%d, front-end numberID=%s, IP address=%s, port number=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_record_info_proc() SIP_SendMessage OK:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

            old_xml_sn = strtoul(strSN, NULL, 10);
            transfer_xml_sn = strtoul(strTransferSN, NULL, 10);
            i = transfer_xml_msg_add(XML_QUERY_RECORDINFO, old_xml_sn, transfer_xml_sn, pCallerGBDeviceInfo->device_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, strDeviceID);
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_query_record_info_proc() transfer_xml_msg_add: Type=%d, old_xml_sn=%u, transfer_xml_sn=%u, DeviceID=%s, pos=%d \r\n", XML_QUERY_RECORDINFO, old_xml_sn, transfer_xml_sn, strDeviceID, i);
        }

        return i;
    }

normal_record:
    {
        /* 2、查找录像回放TSU 资源 */
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_record_info_proc() get_idle_tsu_by_resource_balance_for_replay: Begin--- \r\n", tsu_index);
        tsu_index = get_idle_tsu_by_resource_balance_for_replay();
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_record_info_proc() get_idle_tsu_by_resource_balance_for_replay: End--- tsu_index=%d \r\n", tsu_index);

        if (tsu_index < 0)
        {
            /* 回复响应,组建消息 */
            CPacket outPacket;
            DOMElement* AccNode = NULL;

            outPacket.SetRootTag("Response");

            AccNode = outPacket.CreateElement((char*)"CmdType");
            outPacket.SetElementValue(AccNode, (char*)"RecordInfo");

            AccNode = outPacket.CreateElement((char*)"SN");
            outPacket.SetElementValue(AccNode, strSN);

            AccNode = outPacket.CreateElement((char*)"DeviceID");
            outPacket.SetElementValue(AccNode, strDeviceID);

            AccNode = outPacket.CreateElement((char*)"Name");
            outPacket.SetElementValue(AccNode, pGBLogicDeviceInfo->device_name);

            AccNode = outPacket.CreateElement((char*)"SumNum");
            outPacket.SetElementValue(AccNode, (char*)"-1");

            AccNode = outPacket.CreateElement((char*)"ErrCode");
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_TSU_GET_IDLE_TSU_INDEX_ERROR);
            outPacket.SetElementValue(AccNode, strErrorCode);

            AccNode = outPacket.CreateElement((char*)"Reason");
            outPacket.SetElementValue(AccNode, (char*)"获取可用的TSU索引失败");

            RecordListAccNode = outPacket.CreateElement((char*)"RecordList");
            outPacket.SetElementAttr(RecordListAccNode, (char*)"Num", (char*)"-1");

            /* 发送响应消息 给上级CMS */
            i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

            if (i != 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() SIP_SendMessage Error:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_record_info_proc() SIP_SendMessage OK:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            }


            if (-2 == tsu_index)
            {
                SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"查找可用的录像回放TSU索引失败,TSU资源队列为空");
                EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for video record info from Front-end device failed:Device ID=%s, IP address=%s, port number=%d, cause=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"access available TSU index failed");
            }
            else if (-3 == tsu_index)
            {
                SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"查找可用的录像回放TSU索引失败,TSU资源信息错误");
                EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for video record info from Front-end device failed:Device ID=%s, IP address=%s, port number=%d, cause=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"access available TSU index failed");
            }
            else if (-4 == tsu_index)
            {
                SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"查找可用的录像回放TSU索引失败,TSU资源都没有启用");
                EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for video record info from Front-end device failed:Device ID=%s, IP address=%s, port number=%d, cause=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"access available TSU index failed");
            }
            else if (-5 == tsu_index)
            {
                SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"查找可用的录像回放TSU索引失败,TSU资源都不在线");
                EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for video record info from Front-end device failed:Device ID=%s, IP address=%s, port number=%d, cause=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"access available TSU index failed");
            }
            else if (-9 == tsu_index)
            {
                SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"查找可用的录像回放TSU索引失败,通过ICE获取所有的TSU资源状态失败");
                EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for video record info from Front-end device failed:Device ID=%s, IP address=%s, port number=%d, cause=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"access available TSU index failed");
            }
            else
            {
                SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"查找可用的录像回放TSU索引失败");
                EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for video record info from Front-end device failed:Device ID=%s, IP address=%s, port number=%d, cause=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"access available TSU index failed");
            }

            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() exit---: Get Idle TSU Index Error \r\n");
            return -1;
        }

        pTsuResourceInfo = tsu_resource_info_get(tsu_index);

        if (NULL == pTsuResourceInfo)
        {
            /* 回复响应,组建消息 */
            CPacket outPacket;
            DOMElement* AccNode = NULL;

            outPacket.SetRootTag("Response");

            AccNode = outPacket.CreateElement((char*)"CmdType");
            outPacket.SetElementValue(AccNode, (char*)"RecordInfo");

            AccNode = outPacket.CreateElement((char*)"SN");
            outPacket.SetElementValue(AccNode, strSN);

            AccNode = outPacket.CreateElement((char*)"DeviceID");
            outPacket.SetElementValue(AccNode, strDeviceID);

            AccNode = outPacket.CreateElement((char*)"Name");
            outPacket.SetElementValue(AccNode, pGBLogicDeviceInfo->device_name);

            AccNode = outPacket.CreateElement((char*)"SumNum");
            outPacket.SetElementValue(AccNode, (char*)"-1");

            AccNode = outPacket.CreateElement((char*)"ErrCode");
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_TSU_GET_TSU_INFO_ERROR);
            outPacket.SetElementValue(AccNode, strErrorCode);

            AccNode = outPacket.CreateElement((char*)"Reason");
            outPacket.SetElementValue(AccNode, (char*)"获取可用的TSU信息失败");

            RecordListAccNode = outPacket.CreateElement((char*)"RecordList");
            outPacket.SetElementAttr(RecordListAccNode, (char*)"Num", (char*)"-1");

            /* 发送响应消息 给上级CMS */
            i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

            if (i != 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() SIP_SendMessage Error:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_record_info_proc() SIP_SendMessage OK:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            }

            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() exit---: Get TSU Resource Info Error \r\n");
            SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s, tsu_index=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"获取录像回放的TSU信息失败", tsu_index);
            EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for video record info from Front-end device failed:Device ID=%s, IPaddress=%s, port number=%d, cause=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"access available TSU info failed");
            return -1;
        }

        /* 3、通知TSU, 查询录像列表 */
        iStartTime = analysis_time(strStartTime);
        iEndTime = analysis_time(strEndTime);

        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_record_info_proc() iStartTime=%d,iEndTime=%d \r\n", iStartTime, iEndTime);

        if ((iStartTime <= 0) || (iEndTime <= 0))
        {
            /* 回复响应,组建消息 */
            CPacket outPacket;
            DOMElement* AccNode = NULL;

            outPacket.SetRootTag("Response");

            AccNode = outPacket.CreateElement((char*)"CmdType");
            outPacket.SetElementValue(AccNode, (char*)"RecordInfo");

            AccNode = outPacket.CreateElement((char*)"SN");
            outPacket.SetElementValue(AccNode, strSN);

            AccNode = outPacket.CreateElement((char*)"DeviceID");
            outPacket.SetElementValue(AccNode, strDeviceID);

            AccNode = outPacket.CreateElement((char*)"Name");
            outPacket.SetElementValue(AccNode, pGBLogicDeviceInfo->device_name);

            AccNode = outPacket.CreateElement((char*)"SumNum");
            outPacket.SetElementValue(AccNode, (char*)"-1");

            AccNode = outPacket.CreateElement((char*)"ErrCode");
            memset(strErrorCode, 0, 32);
            snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_RECORD_TIME_INFO_ERROR);
            outPacket.SetElementValue(AccNode, strErrorCode);

            AccNode = outPacket.CreateElement((char*)"Reason");
            outPacket.SetElementValue(AccNode, (char*)"录像时间信息不对");

            RecordListAccNode = outPacket.CreateElement((char*)"RecordList");
            outPacket.SetElementAttr(RecordListAccNode, (char*)"Num", (char*)"-1");

            /* 发送响应消息 给上级CMS */
            i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

            if (i != 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() SIP_SendMessage Error:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_record_info_proc() SIP_SendMessage OK:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            }

            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() exit---: Get Time Error \r\n");
            SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s,开始时间=%s, 结束时间=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"录像时间信息不对", strStartTime, strEndTime);
            EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for video record info from Front-end device failed:Device ID=%s, IPaddress=%s, port number=%d, cause=%s,start time=%s, end time=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"record time incorrect", strStartTime, strEndTime);
            return -1;
        }

        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询录像记录信息, 开始通知TSU查询记录:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, TSU ID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, pTsuResourceInfo->tsu_device_id);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Search for video record info from Front-end device , start to notify TSU search record:Device ID=%s, IPaddress=%s, port number=%d, TSU ID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, pTsuResourceInfo->tsu_device_id);

        /* 查找该点位的录像任务，通知TSU更新结束时间 */
        if (EV9000_RECORD_TYPE_NORMAL == record_type
            || EV9000_RECORD_TYPE_ALARM == record_type)
        {
            iRecordCRPos = record_call_record_find_by_calleeid_and_streamtype(strDeviceID, EV9000_STREAM_TYPE_MASTER);
        }
        else if (EV9000_RECORD_TYPE_BACKUP == record_type)
        {
            iRecordCRPos = record_call_record_find_by_calleeid_and_streamtype(strDeviceID, EV9000_STREAM_TYPE_SLAVE);
        }
        else if (EV9000_RECORD_TYPE_INTELLIGENCE == record_type)
        {
            iRecordCRPos = record_call_record_find_by_calleeid_and_streamtype(strDeviceID, EV9000_STREAM_TYPE_INTELLIGENCE);
        }

        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_query_record_info_proc():record_call_record_find_by_calleeid_and_streamtype:callee_id=%s, RecordCRPos=%d\r\n", strDeviceID, iRecordCRPos);

        if (iRecordCRPos >= 0)
        {
            pRecordCrData = call_record_get(iRecordCRPos);

            if (NULL != pRecordCrData)
            {
                i = notify_tsu_update_mysql_record_stoptime(pRecordCrData->tsu_ip, pRecordCrData->task_id);
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_query_record_info_proc():notify_tsu_update_mysql_record_stoptime:tsu_ip=%s, task_id=%s, i=%d \r\n", pRecordCrData->tsu_ip, pRecordCrData->task_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() exit---: call_record_get Error: RecordCRPos=%d \r\n", iRecordCRPos);
            }
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() exit---: record_call_record_find_by_calleeid_and_streamtype Error: callee_id=%s \r\n", strDeviceID);
        }

        /* 通知TSU查询录像 */
        iRet = notify_tsu_query_replay_list(pTsuResourceInfo, strDeviceID, 1, record_type, iStartTime, iEndTime, stVideoRecordList);

        if (iRet < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() notify_tsu_query_replay_list Error:i=%d \r\n", iRet);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_record_info_proc() notify_tsu_query_replay_list OK:i=%d \r\n", iRet);
        }

        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询录像记录信息, TSU查询记录结束:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, TSU ID=%s, i=%d, 记录数=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, pTsuResourceInfo->tsu_device_id, i, stVideoRecordList.size());
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Search for video record info from Front-end device , TSU search record result:Device ID=%s, IPaddress=%s, port number=%d, TSU ID=%s, i=%d, record number=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, pTsuResourceInfo->tsu_device_id, i, stVideoRecordList.size());

        if (iRet < 0)
        {
            /* 回复响应,组建消息 */
            CPacket outPacket;
            DOMElement* AccNode = NULL;

            outPacket.SetRootTag("Response");

            AccNode = outPacket.CreateElement((char*)"CmdType");
            outPacket.SetElementValue(AccNode, (char*)"RecordInfo");

            AccNode = outPacket.CreateElement((char*)"SN");
            outPacket.SetElementValue(AccNode, strSN);

            AccNode = outPacket.CreateElement((char*)"DeviceID");
            outPacket.SetElementValue(AccNode, strDeviceID);

            AccNode = outPacket.CreateElement((char*)"Name");
            outPacket.SetElementValue(AccNode, pGBLogicDeviceInfo->device_name);

            AccNode = outPacket.CreateElement((char*)"SumNum");
            outPacket.SetElementValue(AccNode, (char*)"-1");

            AccNode = outPacket.CreateElement((char*)"ErrCode");
            memset(strErrorCode, 0, 32);

            if (-1 == iRet)
            {
                snprintf(strErrorCode, 32, "%d", EV9000_CMS_ERR_TSU_ICE_ERROR);
            }
            else
            {
                snprintf(strErrorCode, 32, "%d", iRet);
            }

            outPacket.SetElementValue(AccNode, strErrorCode);

            AccNode = outPacket.CreateElement((char*)"Reason");
            outPacket.SetElementValue(AccNode, (char*)"TSU查询录像记录返回失败,ICE异常");

            RecordListAccNode = outPacket.CreateElement((char*)"RecordList");
            outPacket.SetElementAttr(RecordListAccNode, (char*)"Num", (char*)"-1");

            /* 发送响应消息 给上级CMS */
            i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

            if (i != 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() SIP_SendMessage Error:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_record_info_proc() SIP_SendMessage OK:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            }

            if (-1 == iRet)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() exit---: Notify TSU Query Replay List Error \r\n");
                SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"TSU查询录像记录返回失败, ICE异常");
                EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for video record info from Front-end device failed:Device ID=%s, IP address=%s, port number=%d, cause=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"TSU search for video record return failed, ICE abnormal");
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() exit---: Notify TSU Query Replay List Error \r\n");
                SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s, iRet=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"TSU查询录像记录返回失败", iRet);
                EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for video record info from Front-end device failed:Device ID=%s, IP address=%s, port number=%d, cause=%s, iRet=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"TSUTSU search for video record return failed", iRet);
            }

            return -1;
        }

        record_count = stVideoRecordList.size();
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_query_record_info_proc() record_count=%d \r\n", record_count);

        if (record_count == 0)
        {
            /* 回复响应,组建消息 */
            CPacket outPacket;
            DOMElement* AccNode = NULL;

            outPacket.SetRootTag("Response");

            AccNode = outPacket.CreateElement((char*)"CmdType");
            outPacket.SetElementValue(AccNode, (char*)"RecordInfo");

            AccNode = outPacket.CreateElement((char*)"SN");
            outPacket.SetElementValue(AccNode, strSN);

            AccNode = outPacket.CreateElement((char*)"DeviceID");
            outPacket.SetElementValue(AccNode, strDeviceID);

            AccNode = outPacket.CreateElement((char*)"Name");
            outPacket.SetElementValue(AccNode, pGBLogicDeviceInfo->device_name);

            AccNode = outPacket.CreateElement((char*)"SumNum");
            outPacket.SetElementValue(AccNode, (char*)"0");

            RecordListAccNode = outPacket.CreateElement((char*)"RecordList");
            outPacket.SetElementAttr(RecordListAccNode, (char*)"Num", (char*)"0");

            /* 发送响应消息 给前端设备 */
            i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

            if (i != 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() SIP_SendMessage Error:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_record_info_proc() SIP_SendMessage OK:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            }

            SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_WARNING, "前端设备过来的查询录像记录信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"没有查询到录像记录");
            EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_WARNING, "Search for video record info from Front-end device failed:Device ID=%s, IP address=%s, port number=%d, cause=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"Video record not found.");
            DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_query_record_info_proc() exit---: No Record Count \r\n");
            return i;
        }

        /* 4、循环查找容器，读取录像文件列表信息，加入xml中 */
        CPacket* pOutPacket = NULL;

        if ((str3PartFlag[0] != 0 && 0 == sstrcmp(str3PartFlag, (char*)"YES"))
            || (1 == pCallerGBDeviceInfo->three_party_flag)) /* 第三方设备,发送条数有限制 */
        {
            for (index = 0; index < record_count; index++)
            {
                /* 如果记录数大于10，则要分次发送 */
                query_count++;

                /* 创建XML头部 */
                i = CreateRecordInfoQueryResponseXMLHeadForRoute(&pOutPacket, query_count, record_count, strSN, strDeviceID, pGBLogicDeviceInfo->device_name, &RecordListAccNode);

                /* 加入Item 值 */
                i = AddRecordInfoToXMLItemForRoute(pOutPacket, RecordListAccNode, stVideoRecordList[index], strDeviceID, pGBLogicDeviceInfo->device_name);

                if ((query_count % MAX_ROUTE_RECORD_INFO_COUT_SEND == 0) || (query_count == record_count))
                {
                    if (NULL != pOutPacket)
                    {
                        /* 发送响应消息 给前端设备 */
                        i |= SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)pOutPacket->GetXml(NULL).c_str(), pOutPacket->GetXml(NULL).length());

                        if (i != 0)
                        {
                            SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息, 发送Message消息到前端设备失败:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for video record info from Front-end device , message sending to the front-end equipment failure:front-end ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() SIP_SendMessage Error:dest_id=%s, dest_ip=%s, dest_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                        }
                        else
                        {
                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询录像记录信息, 发送Message消息到前端设备成功:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Search for video record info from Front-end device , message sending to the front-end equipment success:front-end ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_record_info_proc() SIP_SendMessage OK:dest_id=%s, dest_ip=%s, dest_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                        }

                        delete pOutPacket;
                        pOutPacket = NULL;
                    }
                }
            }
        }
        else
        {
            for (index = 0; index < record_count; index++)
            {
                /* 如果记录数大于10，则要分次发送 */
                query_count++;

                /* 创建XML头部 */
                i = CreateRecordInfoQueryResponseXMLHead(&pOutPacket, query_count, record_count, strSN, strDeviceID, pGBLogicDeviceInfo->device_name, &RecordListAccNode);

                /* 加入Item 值 */
                i = AddRecordInfoToXMLItem(pOutPacket, RecordListAccNode, stVideoRecordList[index], strDeviceID, pGBLogicDeviceInfo->device_name);

                if ((query_count % MAX_USER_RECORD_INFO_COUT_SEND == 0) || (query_count == record_count))
                {
                    if (NULL != pOutPacket)
                    {
                        /* 发送响应消息 给前端设备 */
                        i |= SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)pOutPacket->GetXml(NULL).c_str(), pOutPacket->GetXml(NULL).length());

                        if (i != 0)
                        {
                            SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息, 发送Message消息到前端设备失败:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for video record info from Front-end device , message sending to the front-end equipment failure:front-end ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_record_info_proc() SIP_SendMessage Error:dest_id=%s, dest_ip=%s, dest_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                        }
                        else
                        {
                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询录像记录信息, 发送Message消息到前端设备成功:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Search for video record info from Front-end device , message sending to the front-end equipment success:front-end ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_record_info_proc() SIP_SendMessage OK:dest_id=%s, dest_ip=%s, dest_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                        }

                        delete pOutPacket;
                        pOutPacket = NULL;
                    }
                }
            }
        }
    }

    if (i == 0)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询录像记录信息成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Search for video record info from Front-end device , message sending to the front-end equipment success:front-end ID=%s, IP=%s, port=%d, logic device ID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID);
    }
    else
    {
        SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询录像记录信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=%s, 查询的逻辑设备ID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"发送SIP响应消息失败");
        EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for video record info from Front-end device , message sending to the front-end equipment failure:front-end ID=%s, IP=%s, port=%d, reson=%s, logic device ID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"SIP response message sent failure");
    }

    return 0;
}

/*****************************************************************************
 函 数 名  : device_query_preset_info_proc
 功能描述  : 下级设备过来的查询设备预置位信息处理
 输入参数  : GBDevice_info_t* pCallerGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2015年11月26日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_query_preset_info_proc(GBDevice_info_t * pCallerGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    int record_count = 0; /* 记录数 */
    int send_count = 0;   /* 发送的次数 */
    int query_count = 0;  /* 查询数据统计 */

    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    GBLogicDevice_info_t* pGBLogicDeviceInfo = NULL;
    GBDevice_info_t* pGBDeviceInfo = NULL;
    int while_count = 0;
    char strTransferSN[32] = {0};
    DOMElement* AccSnNode = NULL;
    unsigned int old_xml_sn = 0;
    unsigned int transfer_xml_sn = 0;

    int iCalleeRoutePos = 0;
    route_info_t* pCalleeRouteInfo = NULL;

    if (NULL == pCallerGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_preset_info_proc() exit---: Route Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_preset_info_proc() exit---: para Error \r\n");
        return -1;
    }

    /* 取得查询条件数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询预置位信息:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Search for preset info from Front-end device :Device ID=%s, IP address=%s, port=%d, logic deviceID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID);

    /* 1、获取录像点位信息 */
    pGBLogicDeviceInfo = GBLogicDevice_info_find(strDeviceID);

    if (NULL == pGBLogicDeviceInfo)
    {
        /* 回复响应,组建消息 */
        CPacket* pOutPacket = NULL;
        DOMElement* AccNode = NULL;
        DOMElement* ListAccNode = NULL;

        //DOMElement* ItemAccNode = NULL;
        if (!pOutPacket)
        {
            pOutPacket = new CPacket();
        }

        pOutPacket->SetRootTag("Response");
        AccNode = pOutPacket->CreateElement((char*)"CmdType");
        pOutPacket->SetElementValue(AccNode, (char*)"PresetConfig");

        AccNode = pOutPacket->CreateElement((char*)"SN");
        pOutPacket->SetElementValue(AccNode, strSN);

        AccNode = pOutPacket->CreateElement((char*)"DeviceID");
        pOutPacket->SetElementValue(AccNode, strDeviceID);

        AccNode = pOutPacket->CreateElement((char*)"SumNum");
        pOutPacket->SetElementValue(AccNode, (char*)"0");

        ListAccNode = pOutPacket->CreateElement((char*)"PresetConfigList");
        pOutPacket->SetElementAttr(ListAccNode, (char*)"Num", (char*)"0");

        /* 发送响应消息 给上级CMS */
        i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)pOutPacket->GetXml(NULL).c_str(), pOutPacket->GetXml(NULL).length());

        if (i != 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_preset_info_proc() SIP_SendMessage Error:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_preset_info_proc() SIP_SendMessage OK:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
        }

        if (pOutPacket)
        {
            delete pOutPacket;
        }

        pOutPacket = NULL;
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_preset_info_proc() exit---: Get GBLogic Device Info Error \r\n");
        SystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询预置位信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"获取逻辑设备信息失败");
        EnSystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for preset info from Front-end device failed:Device ID=%s, IP address=%s, port=%d, cause=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"Access logical device information failed");
        return -1;
    }

    /* 根据逻辑设备所属域进行判断，决定消息走向 */
    if (1 == pGBLogicDeviceInfo->other_realm)
    {
        /* 查找上级路由信息 */
        iCalleeRoutePos = route_info_find(pGBLogicDeviceInfo->cms_id);

        if (iCalleeRoutePos < 0)
        {
            /* 回复响应,组建消息 */
            CPacket* pOutPacket = NULL;
            DOMElement* AccNode = NULL;
            DOMElement* ListAccNode = NULL;

            //DOMElement* ItemAccNode = NULL;
            if (!pOutPacket)
            {
                pOutPacket = new CPacket();
            }

            pOutPacket->SetRootTag("Response");

            AccNode = pOutPacket->CreateElement((char*)"CmdType");
            pOutPacket->SetElementValue(AccNode, (char*)"PresetConfig");

            AccNode = pOutPacket->CreateElement((char*)"SN");
            pOutPacket->SetElementValue(AccNode, strSN);

            AccNode = pOutPacket->CreateElement((char*)"DeviceID");
            pOutPacket->SetElementValue(AccNode, strDeviceID);

            AccNode = pOutPacket->CreateElement((char*)"SumNum");
            pOutPacket->SetElementValue(AccNode, (char*)"0");

            ListAccNode = pOutPacket->CreateElement((char*)"PresetConfigList");
            pOutPacket->SetElementAttr(ListAccNode, (char*)"Num", (char*)"0");

            /* 发送响应消息 */
            i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)pOutPacket->GetXml(NULL).c_str(), pOutPacket->GetXml(NULL).length());

            if (i != 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_preset_info_proc() SIP_SendMessage Error:Device ID=%s, IP address=%s, port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_preset_info_proc() SIP_SendMessage OK:Device ID=%s, IP address=%s, port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            }

            if (pOutPacket)
            {
                delete pOutPacket;
            }

            pOutPacket = NULL;
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_preset_info_proc() exit---: Find Callee Route Info Error \r\n");
            SystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询预置位信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"查找逻辑设备对应的上级路由信息失败");
            EnSystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for preset info from Front-end device failed:Device ID=%s, IP address=%s, port=%d, reason=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"Find the route information which corresponding to logical device failed.");
            return -1;
        }

        pCalleeRouteInfo = route_info_get(iCalleeRoutePos);

        if (NULL == pCalleeRouteInfo)
        {
            /* 回复响应,组建消息 */
            CPacket* pOutPacket = NULL;
            DOMElement* AccNode = NULL;
            DOMElement* ListAccNode = NULL;

            //DOMElement* ItemAccNode = NULL;
            if (!pOutPacket)
            {
                pOutPacket = new CPacket();
            }

            pOutPacket->SetRootTag("Response");

            AccNode = pOutPacket->CreateElement((char*)"CmdType");
            pOutPacket->SetElementValue(AccNode, (char*)"PresetConfig");

            AccNode = pOutPacket->CreateElement((char*)"SN");
            pOutPacket->SetElementValue(AccNode, strSN);

            AccNode = pOutPacket->CreateElement((char*)"DeviceID");
            pOutPacket->SetElementValue(AccNode, strDeviceID);

            AccNode = pOutPacket->CreateElement((char*)"SumNum");
            pOutPacket->SetElementValue(AccNode, (char*)"0");

            ListAccNode = pOutPacket->CreateElement((char*)"PresetConfigList");
            pOutPacket->SetElementAttr(ListAccNode, (char*)"Num", (char*)"0");

            /* 发送响应消息 */
            i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)pOutPacket->GetXml(NULL).c_str(), pOutPacket->GetXml(NULL).length());

            if (i != 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_preset_info_proc() SIP_SendMessage Error:Device ID=%s, IP address=%s, port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_preset_info_proc() SIP_SendMessage OK:Device ID=%s, IP address=%s, port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            }

            if (pOutPacket)
            {
                delete pOutPacket;
            }

            pOutPacket = NULL;
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_preset_info_proc() exit---: Get Callee Route Info Error \r\n");
            SystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询预置位信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"获取逻辑设备对应的上级路由信息失败");
            EnSystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for preset info from Front-end device failed:Device ID=%s, IP address=%s, port=%d, reason=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"Get the route information which corresponding to logical device failed.");
            return -1;
        }

        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询预置位信息是上级CMS中的点位:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 所在的上级CMS ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Searching for preset info from Front-end device belongs to route CMS:front-end ID=%s, IP=%s, port=%d, logic device ID=%s, route CMS ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);

        AccSnNode = inPacket.SearchElement((char*)"SN");

        if (NULL != AccSnNode)
        {
            g_transfer_xml_sn++;
            snprintf(strTransferSN, 32, "%u", g_transfer_xml_sn);
            inPacket.SetElementValue(AccSnNode, strTransferSN);
            //inPacket.SetTextContent();
        }

        /* 将查询录像任务的消息转发出去 */
        i = SIP_SendMessage(NULL, local_cms_id_get(), pCalleeRouteInfo->server_id, pCalleeRouteInfo->strRegLocalIP, pCalleeRouteInfo->iRegLocalPort, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port, (char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length());

        if (i != 0)
        {
            SystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询预置位信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s, 上级CMS ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"转发查询消息到上级CMS失败", pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
            EnSystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for preset info from Front-end device, forwards the query message to the superior CMS failure:Device ID=%s, IP address=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_preset_info_proc() SIP_SendMessage Error:Device ID=%s, IP address=%s, port=%d \r\n", pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
        }
        else
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询预置位信息成功,转发查询消息到上级CMS:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 上级CMS ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Search for preset info from Front-end device, forwards the query message to the superior CMS success:Device ID=%s, IP address=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_preset_info_proc() SIP_SendMessage OK:Device ID=%s, IP address=%s, port=%d \r\n", pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);

            old_xml_sn = strtoul(strSN, NULL, 10);
            transfer_xml_sn = strtoul(strTransferSN, NULL, 10);
            i = transfer_xml_msg_add(XML_QUERY_GETPRESET, old_xml_sn, transfer_xml_sn, pCallerGBDeviceInfo->device_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, strDeviceID);
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_query_preset_info_proc() transfer_xml_msg_add: Type=%d, old_xml_sn=%u, transfer_xml_sn=%u, DeviceID=%s, pos=%d \r\n", XML_QUERY_GETPRESET, old_xml_sn, transfer_xml_sn, strDeviceID, i);
        }
    }
    else
    {
        /* 获取逻辑设备所属的物理设备 */
        pGBDeviceInfo = GBDevice_info_get_by_stream_type(pGBLogicDeviceInfo, EV9000_STREAM_TYPE_MASTER);

        if (NULL != pGBDeviceInfo
            && EV9000_DEVICETYPE_SIPSERVER == pGBDeviceInfo->device_type
            && 0 == pGBDeviceInfo->three_party_flag) /* 非第三方平台的下级cms 的点位 */
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询预置位信息是下级CMS中的点位:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 所在的下级CMS ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Searching for preset info from Front-end device belongs to lower CMS:front-end ID=%s, IP=%s, port=%d, logic device ID=%s, lower CMS ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, pCalleeRouteInfo->server_id, pCalleeRouteInfo->server_ip, pCalleeRouteInfo->server_port);

            AccSnNode = inPacket.SearchElement((char*)"SN");

            if (NULL != AccSnNode)
            {
                g_transfer_xml_sn++;
                snprintf(strTransferSN, 32, "%u", g_transfer_xml_sn);
                inPacket.SetElementValue(AccSnNode, strTransferSN);
                //inPacket.SetTextContent();
            }

            /* 将查询录像任务的消息转发出去 */
            i = SIP_SendMessage(NULL, local_cms_id_get(), pGBDeviceInfo->device_id, pGBDeviceInfo->strRegServerIP, pGBDeviceInfo->iRegServerPort, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length());

            if (i != 0)
            {
                SystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询预置位信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s, 下级CMS ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"转发查询消息到下级CMS失败", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                EnSystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for preset info from Front-end device ,forward search info to subordinate CMS failed:CMS ID=%s, IP address=%s, port number=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_preset_info_proc() SIP_SendMessage Error:Device ID=%s, IP address=%s, port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            }
            else
            {
                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询预置位信息成功,转发查询消息到下级CMS:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 下级CMS ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Search for preset info from Front-end device ,forward search info to subordinate CMS success:CMS ID=%s, IP address=%s, port number=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_preset_info_proc() SIP_SendMessage OK:Device ID=%s, IP address=%s, port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

                old_xml_sn = strtoul(strSN, NULL, 10);
                transfer_xml_sn = strtoul(strTransferSN, NULL, 10);
                i = transfer_xml_msg_add(XML_QUERY_GETPRESET, old_xml_sn, transfer_xml_sn, pCallerGBDeviceInfo->device_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, strDeviceID);
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_query_preset_info_proc() transfer_xml_msg_add: Type=%d, old_xml_sn=%u, transfer_xml_sn=%u, DeviceID=%s, pos=%d \r\n", XML_QUERY_GETPRESET, old_xml_sn, transfer_xml_sn, strDeviceID, i);
            }
        }
        else
        {
            //query
            char szSql[100] = {0};
            char strSumNum[32] = {0};
            snprintf(szSql, 100, "select * from PresetConfig WHERE DeviceIndex = %u order by PresetID asc;", pGBLogicDeviceInfo->id);
            record_count  = pDevice_Srv_dboper->DB_Select(szSql, 1);
            snprintf(strSumNum, 32, "%d", record_count);

            if (record_count < 0)
            {
                /* 回复响应,组建消息 */
                CPacket* pOutPacket = NULL;
                DOMElement* AccNode = NULL;
                DOMElement* ListAccNode = NULL;

                //DOMElement* ItemAccNode = NULL;
                if (!pOutPacket)
                {
                    pOutPacket = new CPacket();
                }

                pOutPacket->SetRootTag("Response");

                AccNode = pOutPacket->CreateElement((char*)"CmdType");
                pOutPacket->SetElementValue(AccNode, (char*)"PresetConfig");

                AccNode = pOutPacket->CreateElement((char*)"SN");
                pOutPacket->SetElementValue(AccNode, strSN);

                AccNode = pOutPacket->CreateElement((char*)"DeviceID");
                pOutPacket->SetElementValue(AccNode, strDeviceID);

                AccNode = pOutPacket->CreateElement((char*)"SumNum");
                pOutPacket->SetElementValue(AccNode, (char*)"0");

                ListAccNode = pOutPacket->CreateElement((char*)"PresetConfigList");
                pOutPacket->SetElementAttr(ListAccNode, (char*)"Num", (char*)"0");

                /* 发送响应消息 给上级CMS */
                i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)pOutPacket->GetXml(NULL).c_str(), pOutPacket->GetXml(NULL).length());

                if (i != 0)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_preset_info_proc() SIP_SendMessage Error:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_preset_info_proc() SIP_SendMessage OK:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                }

                if (pOutPacket)
                {
                    delete pOutPacket;
                }

                pOutPacket = NULL;
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_preset_info_proc() Error DB Oper Error:strSQL=%s, record_count=%d \r\n", szSql, record_count);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_preset_info_proc() ErrorMsg=%s\r\n", pDevice_Srv_dboper->GetLastDbErrorMsg());
                SystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询预置位信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"查询数据库失败");
                EnSystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for preset info from Front-end device failed:Device ID=%s, IP address=%s, port=%d, cause=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"Search in database failed");
                return -1;
            }
            else if (record_count == 0)
            {
                /* 回复响应,组建消息 */
                CPacket* pOutPacket = NULL;
                DOMElement* AccNode = NULL;
                DOMElement* ListAccNode = NULL;

                //DOMElement* ItemAccNode = NULL;
                if (!pOutPacket)
                {
                    pOutPacket = new CPacket();
                }

                pOutPacket->SetRootTag("Response");
                AccNode = pOutPacket->CreateElement((char*)"CmdType");
                pOutPacket->SetElementValue(AccNode, (char*)"PresetConfig");

                AccNode = pOutPacket->CreateElement((char*)"SN");
                pOutPacket->SetElementValue(AccNode, strSN);

                AccNode = pOutPacket->CreateElement((char*)"DeviceID");
                pOutPacket->SetElementValue(AccNode, strDeviceID);

                AccNode = pOutPacket->CreateElement((char*)"SumNum");
                pOutPacket->SetElementValue(AccNode, (char*)"0");

                ListAccNode = pOutPacket->CreateElement((char*)"PresetConfigList");
                pOutPacket->SetElementAttr(ListAccNode, (char*)"Num", (char*)"0");

                /* 发送响应消息 给上级CMS */
                i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)pOutPacket->GetXml(NULL).c_str(), pOutPacket->GetXml(NULL).length());

                if (i != 0)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_preset_info_proc() SIP_SendMessage Error:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_preset_info_proc() SIP_SendMessage OK:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                }

                if (pOutPacket)
                {
                    delete pOutPacket;
                }

                pOutPacket = NULL;
                DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_query_preset_info_proc() exit---: No Record Count \r\n");
                SystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_WARNING, "前端设备过来的查询预置位信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, (char*)"没有查询到数据库记录");
                EnSystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_WARNING, "Search for preset info from Front-end device failed:Device ID=%s, IP address=%s, port=%d, cause=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"Database record not found");
                return i;
            }

            CPacket* pOutPacket = NULL;
            DOMElement* ListAccNode = NULL;

            /* 循环查找数据库，将数据组成XML 发送给客户端 */
            do
            {
                int             nID = 0;                                      //记录编号
                unsigned int    nDeviceIndex = 0;                            //设备ID
                int             nPresetID = 0;                               //预置位编号
                string          strPresetName = "";                          //预置位名称
                int             nResved1 = 0;                                //保留1
                string          strResved2 = "";

                while_count++;

                if (while_count % 10000 == 0)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_query_preset_info_proc() While Count=%d \r\n", while_count);
                }

                query_count++;

                /* 创建XML头部 */
                i = CreatePresetConfigResponseXMLHead(&pOutPacket, query_count, record_count, strSN, strDeviceID, &ListAccNode);

                /* 索引 */
                pDevice_Srv_dboper->GetFieldValue("ID", nID);

                /* 点位索引 */
                pDevice_Srv_dboper->GetFieldValue("DeviceIndex", nDeviceIndex);

                /* 预置位ID */
                pDevice_Srv_dboper->GetFieldValue("PresetID", nPresetID);

                /* 预置位名称 */
                strPresetName.clear();
                pDevice_Srv_dboper->GetFieldValue("PresetName", strPresetName);

                /* 预留1 */
                pDevice_Srv_dboper->GetFieldValue("Resved1", nResved1);

                /* 预留2 */
                strResved2.clear();
                pDevice_Srv_dboper->GetFieldValue("ParentID", strResved2);

                /* 加入Item 值 */
                i = AddPresetConfigToXMLItem(pOutPacket, ListAccNode, nID, nDeviceIndex, nPresetID, strPresetName, nResved1, strResved2);

                if ((query_count % MAX_DEVICE_PRESET_COUT_SEND == 0) || (query_count == record_count))
                {
                    if (NULL != pOutPacket)
                    {
                        send_count++;
                        /* 发送出去 */
                        i |= SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pCallerGBDeviceInfo->strRegServerIP, pCallerGBDeviceInfo->iRegServerPort, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)pOutPacket->GetXml(NULL).c_str(), pOutPacket->GetXml(NULL).length());

                        if (i != 0)
                        {
                            SystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询预置位信息, 发送Message消息到前端设备失败:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            EnSystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for preset info from Front-end device, send messages to the front-end equipment failure:front-end ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_preset_info_proc() SIP_SendMessage Error:dest_id=%s, dest_ip=%s, dest_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                        }
                        else
                        {
                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询预置位信息, 发送Message消息到前端设备成功:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Search for preset info from Front-end device, send messages to the front-end equipment success:front-end ID=%s, IP=%s, port=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_preset_info_proc() SIP_SendMessage OK:dest_id=%s, dest_ip=%s, dest_port=%d \r\n", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port);
                        }

                        delete pOutPacket;
                        pOutPacket = NULL;
                    }
                }
            }
            while (pDevice_Srv_dboper->MoveNext() >= 0);

            if (i == 0)
            {
                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询预置位信息成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 记录数=%d", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, record_count);
                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Search for preset info from Front-end device success:front-end device ID=%s, IP=%s, port=%d, logic device ID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID);
            }
            else
            {
                SystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的查询预置位信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, (char*)"发送SIP响应消息失败");
                EnSystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "Search for preset info from Front-end device failure:front-end device ID=%s, IP=%s, port=%d, cause=%s, logic device ID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID, "SIP response message sent failure");
            }
        }
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的查询预置位信息成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 查询的逻辑设备ID=%s", caller_id, pCallerGBDeviceInfo->login_ip, pCallerGBDeviceInfo->login_port, strDeviceID);
}

/*****************************************************************************
 函 数 名  : device_query_device_group_config_proc
 功能描述  : 设备侧获取逻辑设备分组信息
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2015年3月5日 星期四
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_query_device_group_config_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    /* 用户登录成功之后获取逻辑设备分组配置表
      */
    int i = 0;
    int record_count = 0; /* 记录数 */
    int send_count = 0;   /* 发送的次数 */
    int query_count = 0;  /* 查询数据统计 */

    char strSN[32] = {0};
    char strDeviceID[32] = {0};

    DOMElement* ListAccNode = NULL;

    string strSQL = "";
    int while_count = 0;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_device_group_config_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_device_group_config_proc() exit---: Device Srv DB Oper Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的获取逻辑设备分组信息:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Access logic device group information from the front end device:requesterID=%s, IP=%s, port=%d, logice device ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);

    /* 如果不是获取本CMS，则返回 */
    if (0 != strncmp(callee_id, local_cms_id_get(), 20))
    {
        SystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的获取逻辑设备分组信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=%s:%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"查询的ID不是本CMS的ID", callee_id);
        EnSystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Access logic device group information from the front end device failed:requester ID=%s, IPaddress=%s, port number=%d, cause=%s:%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"Searched ID does not belong to this CMS", callee_id);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_device_group_config_proc() exit---: Device ID Not Belong To Mine CMSID:callee_id=%s \r\n", callee_id);
        return -1;
    }

    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_device_group_config_proc() \
        \r\n XML Para: \
        \r\n SN=%s, DeviceID=%s \r\n", strSN, strDeviceID);

    /* 如果查询的设备ID不是本CMS ID*/
    if (0 != sstrcmp(callee_id, strDeviceID))
    {
        SystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的获取逻辑设备分组信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=%s:%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"查询的ID不是本CMS的ID", strDeviceID);
        EnSystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Access logic device group information from the front end device failed:requester ID=%s, IPaddress=%s, port number=%d, cause=%s:%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"Searched ID does not belong to this CMS", strDeviceID);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_device_group_config_proc() exit---: Device ID Not Belong To Mine CMSID:DeviceID=%s \r\n", strDeviceID);
        return -1;
    }

    /* 根据查询条件，查找数据库，找到相应的逻辑设备分组配置信息 */
    strSQL.clear();
    strSQL = "select * from LogicDeviceGroupConfig order by GroupID asc";
    record_count = pDevice_Srv_dboper->DB_Select(strSQL.c_str(), 1);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_query_device_group_config_proc() record_count=%d \r\n", record_count);

    if (record_count < 0)
    {
        SystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的获取逻辑设备分组信息查询数据库失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=%s:%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"查询数据库失败", pDevice_Srv_dboper->GetLastDbErrorMsg());
        EnSystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Access logic device group information and search database from the front end device failed:requester ID=%s, IPaddress=%s, port number=%d, cause=%s:%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"Search database failed", pDevice_Srv_dboper->GetLastDbErrorMsg());
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_device_group_config_proc() DB Oper Error:strSQL=%s, record_count=%d \r\n", strSQL.c_str(), record_count);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_device_group_config_proc() ErrorMsg=%s\r\n", pDevice_Srv_dboper->GetLastDbErrorMsg());
        return -1;
    }

    if (record_count == 0)
    {
        /* 回复响应,组建消息 */
        CPacket outPacket;
        DOMElement* AccNode = NULL;

        outPacket.SetRootTag("Response");

        AccNode = outPacket.CreateElement((char*)"CmdType");
        outPacket.SetElementValue(AccNode, (char*)"LogicDeviceGroupConfig");

        AccNode = outPacket.CreateElement((char*)"SN");
        outPacket.SetElementValue(AccNode, strSN);

        AccNode = outPacket.CreateElement((char*)"DeviceID");
        outPacket.SetElementValue(AccNode, strDeviceID);

        AccNode = outPacket.CreateElement((char*)"Result");
        outPacket.SetElementValue(AccNode, (char*)"OK");

        AccNode = outPacket.CreateElement((char*)"SumNum");
        outPacket.SetElementValue(AccNode, (char*)"0");

        ListAccNode = outPacket.CreateElement((char*)"LogicDeviceGroupConfigList");
        outPacket.SetElementAttr(ListAccNode, (char*)"Num", (char*)"0");

        i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pGBDeviceInfo->strRegServerIP, pGBDeviceInfo->iRegServerPort, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

        if (i != 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_device_group_config_proc() SIP_SendMessage Error:user_id=%s, user_ip=%s, user_port=%d \r\n", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_device_group_config_proc() SIP_SendMessage OK:user_id=%s, user_ip=%s, user_port=%d \r\n", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        }

        SystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_WARNING, "前端设备过来的获取逻辑设备分组信息查询数据库失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"未查询到数据库记录");
        EnSystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_WARNING, "Access logic device group information and search database from the front end device failed:requester ID=%s, IPaddress=%s, port number=%d, cause=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"Have not found database record.");
        DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_query_device_group_config_proc() exit---: No Record Count \r\n");
        return i;
    }

    CPacket* pOutPacket = NULL;

    /* 循环查找数据库，将数据组成XML 发送给客户端 */
    do
    {
        int id = 0;
        string strName = "";
        string strGroupID = "";
        string strCMSID = "";
        int SortID = 0;
        string strParentID = "";

        while_count++;

        if (while_count % 10000 == 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_query_device_group_config_proc() While Count=%d \r\n", while_count);
        }

        query_count++;

        /* 创建XML头部 */
        i = CreateDeviceGroupConfigResponseXMLHead(&pOutPacket, query_count, record_count, strSN, strDeviceID, &ListAccNode);

        /* 索引 */
        pDevice_Srv_dboper->GetFieldValue("ID", id);

        /* 组编号 */
        strGroupID.clear();
        pDevice_Srv_dboper->GetFieldValue("GroupID", strGroupID);

        /* CMS编号 */
        strCMSID.clear();
        pDevice_Srv_dboper->GetFieldValue("CMSID", strCMSID);

        /* 组名称 */
        strName.clear();
        pDevice_Srv_dboper->GetFieldValue("Name", strName);

        /* 同一父节点下组排序编号 */
        pDevice_Srv_dboper->GetFieldValue("SortID", SortID);

        /* 父节点编号 */
        strParentID.clear();
        pDevice_Srv_dboper->GetFieldValue("ParentID", strParentID);

        /* 加入Item 值 */
        i = AddDeviceGroupConfigToXMLItem(pOutPacket, ListAccNode, id, strGroupID, strCMSID, strName, SortID, strParentID);

        if ((query_count % MAX_DEVICE_GROUP_COUT_SEND == 0) || (query_count == record_count))
        {
            if (NULL != pOutPacket)
            {
                send_count++;
                /* 发送出去 */
                i |= SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pGBDeviceInfo->strRegServerIP, pGBDeviceInfo->iRegServerPort, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)pOutPacket->GetXml(NULL).c_str(), pOutPacket->GetXml(NULL).length());

                if (i != 0)
                {
                    SystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的获取逻辑设备分组信息, 发送Message消息到前端设备失败:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    EnSystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Access logic device group information, send MESSAGE to front device failure:requester ID=%s, IP=%s, port=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_device_group_config_proc() SIP_SendMessage Error:dest_id=%s, dest_ip=%s, dest_port=%d \r\n", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                }
                else
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的获取逻辑设备分组信息, 发送Message消息到前端设备成功:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Access logic device group information, send MESSAGE to front device success:requester ID=%s, IP=%s, port=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_device_group_config_proc() SIP_SendMessage OK:dest_id=%s, dest_ip=%s, dest_port=%d \r\n", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                }

                delete pOutPacket;
                pOutPacket = NULL;
            }
        }
    }
    while (pDevice_Srv_dboper->MoveNext() >= 0);

    if (i == 0)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的获取逻辑设备分组信息成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 记录数=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, record_count);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Access logic device group information success:front-end ID=%s, IP=%s, port=%d, record count=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, record_count);
    }
    else
    {
        SystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的获取逻辑设备分组信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"发送SIP响应消息失败");
        EnSystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Access logic device group information failure:front-end ID=%s, IP=%s, port=%d, cause=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"SIP response message sent failure");
    }

    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_device_group_config_proc() Exit--- \r\n");

    return 0;
}

/*****************************************************************************
 函 数 名  : device_query_device_map_group_config_proc
 功能描述  : 设备侧获取逻辑设备分组关系信息
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2015年3月5日 星期四
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_query_device_map_group_config_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    /* 用户登录成功之后获取逻辑设备分组关系配置表
      */
    int i = 0;
    int record_count = 0; /* 记录数 */
    int send_count = 0;   /* 发送的次数 */
    int query_count = 0;  /* 查询数据统计 */

    char strSN[32] = {0};
    char strDeviceID[32] = {0};

    DOMElement* ListAccNode = NULL;

    string strSQL = "";
    int while_count = 0;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_device_map_group_config_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_device_map_group_config_proc() exit---: User Srv DB Oper Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的获取逻辑设备分组关系信息:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Access logic device group information:front-end device ID=%s, IP=%s, port=%d, logic device ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);

    /* 如果不是获取本CMS，则返回 */
    if (0 != strncmp(callee_id, local_cms_id_get(), 20))
    {
        SystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的获取逻辑设备分组关系信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=%s:%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"查询的ID不是本CMS的ID", callee_id);
        EnSystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "User access group relationship configuration information from default logic device failed:requester ID=%s, IP address=%s, port number=%d, cause=%s:%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"Searched ID does not belong to this CMS", callee_id);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_device_map_group_config_proc() exit---: Device ID Not Belong To Mine CMSID:callee_id=%s \r\n", callee_id);
        return -1;
    }

    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_device_map_group_config_proc() \
            \r\n XML Para: \
            \r\n SN=%s, DeviceID=%s \r\n", strSN, strDeviceID);

    /* 如果查询的设备ID不是本CMS ID*/
    if (0 != sstrcmp(callee_id, strDeviceID))
    {
        SystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR,  "前端设备过来的获取逻辑设备分组关系信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=%s:%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"查询的ID不是本CMS的ID", strDeviceID);
        EnSystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR,  "User access group relationship configuration information from default logic device failed:requester ID=%s, IP address=%s, port number=%d, cause=%s:%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"Searched ID does not belong to this CMS", strDeviceID);
        return -1;
    }

    /* 根据查询条件，查找数据库，找到相应的逻辑设备分组关系配置关系信息 */
    strSQL.clear();
    strSQL = "select * from LogicDeviceMapGroupConfig";
    record_count = pDevice_Srv_dboper->DB_Select(strSQL.c_str(), 1);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_query_device_map_group_config_proc() record_count=%d \r\n", record_count);

    if (record_count < 0)
    {
        SystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR,  "前端设备过来的获取逻辑设备分组关系信息开始查询数据库失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=%s:%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"查询数据库失败", pDevice_Srv_dboper->GetLastDbErrorMsg());
        EnSystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR,  "User access group relationship configuration information from default logic device failed:requester ID=%s, IP address=%s, port number=%d, cause=%s:%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"Searched ID does not belong to this CMS", strDeviceID);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_device_map_group_config_proc() DB Oper Error:strSQL=%s, record_count=%d \r\n", strSQL.c_str(), record_count);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_device_map_group_config_proc() ErrorMsg=%s\r\n", pDevice_Srv_dboper->GetLastDbErrorMsg());
        return -1;
    }

    if (record_count == 0)
    {
        /* 回复响应,组建消息 */
        CPacket outPacket;
        DOMElement* AccNode = NULL;

        outPacket.SetRootTag("Response");

        AccNode = outPacket.CreateElement((char*)"CmdType");
        outPacket.SetElementValue(AccNode, (char*)"LogicDeviceMapGroupConfig");

        AccNode = outPacket.CreateElement((char*)"SN");
        outPacket.SetElementValue(AccNode, strSN);

        AccNode = outPacket.CreateElement((char*)"DeviceID");
        outPacket.SetElementValue(AccNode, strDeviceID);

        AccNode = outPacket.CreateElement((char*)"Result");
        outPacket.SetElementValue(AccNode, (char*)"OK");

        AccNode = outPacket.CreateElement((char*)"SumNum");
        outPacket.SetElementValue(AccNode, (char*)"0");

        ListAccNode = outPacket.CreateElement((char*)"LogicDeviceMapGroupConfigList");
        outPacket.SetElementAttr(ListAccNode, (char*)"Num", (char*)"0");

        i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pGBDeviceInfo->strRegServerIP, pGBDeviceInfo->iRegServerPort, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

        if (i != 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_device_map_group_config_proc() SIP_SendMessage Error:user_id=%s, user_ip=%s, user_port=%d \r\n", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_device_map_group_config_proc() SIP_SendMessage OK:user_id=%s, user_ip=%s, user_port=%d \r\n", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        }

        SystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_WARNING,  "前端设备过来的获取逻辑设备分组关系信息查询数据库失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"未查询到数据库记录");
        EnSystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_WARNING,  "User access group relationship configuration information from default logic device and search in database failed:requester ID=%s, IP address=%s, port number=%d, cause=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"Have not found database record.");
        DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_query_device_map_group_config_proc() exit---: No Record Count \r\n");
        return i;
    }

    CPacket* pOutPacket = NULL;

    do
    {
        int id = 0;
        string strGroupID = "";
        unsigned int DeviceIndex = 0;
        string strCMSID = "";
        int SortID = 0;

        while_count++;

        if (while_count % 10000 == 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_query_device_map_group_config_proc() While Count=%d \r\n", while_count);
        }

        query_count++;

        /* 创建XML头部 */
        i = CreateDeviceMapGroupConfigResponseXMLHead(&pOutPacket, query_count, record_count, strSN, strDeviceID, &ListAccNode);

        /* 索引 */
        pDevice_Srv_dboper->GetFieldValue("ID", id);

        /* 点位组编号 */
        strGroupID.clear();
        pDevice_Srv_dboper->GetFieldValue("GroupID", strGroupID);

        /* 逻辑设备索引 */
        pDevice_Srv_dboper->GetFieldValue("DeviceIndex", DeviceIndex);

        /* CMS 编号 */
        strCMSID.clear();
        pDevice_Srv_dboper->GetFieldValue("CMSID", strCMSID);

        /* 排序编号 */
        pDevice_Srv_dboper->GetFieldValue("SortID", SortID);

        /* 加入Item 值 */
        i = AddDeviceMapGroupConfigToXMLItem(pOutPacket, ListAccNode, id, strGroupID, DeviceIndex, strCMSID, SortID);

        if ((query_count % MAX_DEVICE_MAP_GROUP_COUT_SEND == 0) || (query_count == record_count))
        {
            if (NULL != pOutPacket)
            {
                send_count++;
                /* 发送出去 */
                i |= SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pGBDeviceInfo->strRegServerIP, pGBDeviceInfo->iRegServerPort, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)pOutPacket->GetXml(NULL).c_str(), pOutPacket->GetXml(NULL).length());

                if (i != 0)
                {
                    SystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的获取逻辑设备分组关系信息, 发送Message消息到前端设备失败:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    EnSystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Access logic device group information, send MESSAGE to front device failure:requester ID=%s, IP=%s, port=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_device_group_config_proc() SIP_SendMessage Error:dest_id=%s, dest_ip=%s, dest_port=%d \r\n", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                }
                else
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的获取逻辑设备分组关系信息, 发送Message消息到前端设备成功:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Access logic device group information, send MESSAGE to front device success:requester ID=%s, IP=%s, port=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_device_group_config_proc() SIP_SendMessage OK:dest_id=%s, dest_ip=%s, dest_port=%d \r\n", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                }

                delete pOutPacket;
                pOutPacket = NULL;
            }
        }
    }
    while (pDevice_Srv_dboper->MoveNext() >= 0);

    if (i == 0)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL,  "前端设备过来的获取逻辑设备分组关系信息成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 记录数=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, record_count);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Access logic device group information success:front-end ID=%s, IP=%s, port=%d, record count=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, record_count);
    }
    else
    {
        SystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR,  "前端设备过来的获取逻辑设备分组关系信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"发送SIP响应消息失败");
        EnSystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Access logic device group information failure:front-end ID=%s, IP=%s, port=%d, cause=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"SIP response message sent failure");
    }

    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_device_map_group_config_proc() Exit--- \r\n");

    return 0;
}

/*****************************************************************************
 函 数 名  : device_query_tsu_ip_and_port_proc
 功能描述  : 设备侧获取TCP方式时候的TSU IP和端口号
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2015年6月15日 星期一
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_query_tsu_ip_and_port_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket)
{
    int i = 0;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char* sdp_tsu_ip = NULL;

    int cr_pos = -1;
    cr_t* pCrData = NULL;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_tsu_ip_and_port_proc() exit---: Route Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_tsu_ip_and_port_proc() exit---: Route Srv DB Oper Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的获取TCP方式下的TSU IP地址和端口号:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment to obtain TCP IP address and port number under the way of TSU:front-end ID=%s, IP=%s, port=%d, logic device ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);

    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_tsu_ip_and_port_proc() \
            \r\n XML Para: \
            \r\n SN=%s, DeviceID=%s \r\n", strSN, strDeviceID);

    /* 如果不是获取本CMS，则返回 */
    if (0 != strncmp(callee_id, local_cms_id_get(), 20))
    {
        SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的获取TCP方式下的TSU IP地址和端口号信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=%s:%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"查询的ID不是本CMS的ID", callee_id);
        EnSystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Access TSU IP address and port number from front-end device through TCP failed:requesterID=%s, IPaddress=%s, port number =%d, cause=%s:%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"Searched ID does not belong to this CMS", callee_id);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_tsu_ip_and_port_proc() exit---: Device ID Not Belong To Mine CMSID:callee_id=%s \r\n", callee_id);
        return -1;
    }

    /* 根据通道ID查询对应的业务数据 */
    cr_pos = dc_call_record_find_by_caller_info(strDeviceID, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

    if (cr_pos < 0)
    {
        SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的获取TCP方式下的TSU IP地址和端口号信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=%s:%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"查找对应的呼叫资源信息失败", strDeviceID);
        EnSystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Access TSU IP address and port number from front-end device through TCP failed:requesterID=%s, IPaddress=%s, port number =%d, cause=%s:%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"Search corresponding calling resource information failed", strDeviceID);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_tsu_ip_and_port_proc() exit---: Find CR Data Info Error:DeviceID=%s \r\n", strDeviceID);
        return -1;
    }

    pCrData = call_record_get(cr_pos);

    if (NULL == pCrData)
    {
        SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的获取TCP方式下的TSU IP地址和端口号信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=%s:%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"获取对应的呼叫资源信息失败", cr_pos);
        EnSystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Access TSU IP address and port number from front-end device through TCP failed:requesterID=%s, IPaddress=%s, port number =%d, cause=%s:%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"Access corresponding calling resource information failed", cr_pos);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_tsu_ip_and_port_proc() exit---: Get CR Data Info Error:cr_pos=%d \r\n", cr_pos);
        return -1;
    }

    if (!g_DECMediaTransferFlag
        && EV9000_DEVICETYPE_SIPSERVER == pCrData->callee_gb_device_type && pCrData->caller_sdp_port > 0) /* 下级平台媒体流不经过本级TSU转发 */
    {
        sdp_tsu_ip = pCrData->callee_sdp_ip; /* 直接返回源端的IP地址 */
    }
    else
    {
        sdp_tsu_ip = get_cr_sdp_tsu_ip(pCrData, pCrData->caller_server_ip_ethname);

        if (NULL == sdp_tsu_ip)
        {
            SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的获取TCP方式下的TSU IP地址和端口号信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=%s, caller_server_ip_ethname=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"获取主叫侧的SDP消息中的TSU的IP地址失败", pCrData->caller_server_ip_ethname);
            EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "Access TSU IP address and port number from front-end device through TCP failed:requesterID=%s, IPaddress=%s, port number =%d, cause=%s, caller_server_ip_ethname=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"Access TSU IP address from calling side SDP message failed.", pCrData->caller_server_ip_ethname);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_tsu_ip_and_port_proc() exit---: Get Caller TSU SDP IP Error:caller_server_ip_ethname=%s \r\n", pCrData->caller_server_ip_ethname);
            return -1;
        }

        if (43111 == pCrData->tsu_send_port)
        {
            SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的获取TCP方式下的TSU IP地址和端口号信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=%s, caller_server_ip_ethname=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"呼叫任务没有结束, 端口号还是默认值", pCrData->caller_server_ip_ethname);
            EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "Access TSU IP address and port number from front-end device through TCP failed:requesterID=%s, IP address=%s, port number =%d, cause=%s, caller_server_ip_ethname=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"calling task is not over, port number is default value", pCrData->caller_server_ip_ethname);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_tsu_ip_and_port_proc() exit---: Get Caller TSU SDP IP Error:caller_server_ip_ethname=%s \r\n", pCrData->caller_server_ip_ethname);
            return -1;
        }
    }

    i = SendTSUInfoMessageToDEC(caller_id, pGBDeviceInfo->strRegServerIP, pGBDeviceInfo->iRegServerPort, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strSN, strDeviceID, sdp_tsu_ip, pCrData->tsu_send_port);

    if (i != 0)
    {
        SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备过来的获取TCP方式下的TSU IP地址和端口号信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"发送应答消息失败");
        EnSystemLog(EV9000_CMS_GET_DEVICE_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Access TSU IP address and port number from front-end device through TCP failed:requesterID=%s, IPaddress=%s, port number =%d, cause=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"Send response message failed");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_tsu_ip_and_port_proc() SendTSUInfoMessageToDEC Error\r\n");
    }
    else
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备过来的获取TCP方式下的TSU IP地址和端口号信息成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, tsu_ip=%s, tsu_send_port=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, sdp_tsu_ip, pCrData->tsu_send_port);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Access TSU IP address and port number from front-end device through TCP failed:front-end ID=%s, IP=%s, port=%d, logic device ID=%s, tsu_ip=%s, tsu_send_port=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id, sdp_tsu_ip, pCrData->tsu_send_port);
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_notify_alarm_proc
 功能描述  : 设备报警事件通知信息处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月13日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_alarm_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    int pos = -1;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strAlarmPriority[32] = {0};
    char strAlarmMethod[32] = {0};
    char strAlarmStartTime[32] = {0};
    char strAlarmEndTime[32] = {0};
    char strAlarmStatus[32] = {0};
    char strAlarmDescription[512 + 4] = {0};
    CPacket outPacket;
    DOMElement* AccNode = NULL;
    route_info_t* pRouteInfo = NULL;
    GBLogicDevice_info_t* pGBLogicDeviceInfo = NULL;
    int iAlarmMsgType = 0;
    int iArarmDuration = 0;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_alarm_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_alarm_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 报警事件通知和分发
          控制流程见9.4.2

          命令包括如下字段:
          <!-- 命令类型：报警通知（必选） -->
          <element name="CmdType" fixed = "Alarm" />
          <!-- 命令序列号（必选） -->
          <element name="SN" type="integer" minInclusive value = "1" />
          <!-- 报警设备编码（必选）-->
          <element name="DeviceID" type="tg:deviceIDType" />
          <!-- 报警级别（必选），1为一级警情，2为二级警情，3为三级警情，4为四级警情-->
          <element name="AlarmPriority" type="string" />
          <!-- 报警方式（必选），取值1为电话报警，2为设备报警，3为短信报警，4为GPS报警，5为视频报警，6
          为设备故障报警，7其它报警-->
          <element name= "AlarmMethod" type= "string" />
          <!--报警时间（必选）-->
          <element name= "AlarmTime" type="dateTime" />
          <!-- 经纬度信息可选 -->
          <element name="Longitude" type="double" minOccurs= "0"/>
          <element name="Latitude" type="double" minOccurs= "0"/>
          <!-- 扩展信息，可多项 -->
          <element name= "Info" minOccurs= "0" maxOccurs="unbounded">
          <restriction base= "string">
          <maxLength value= "1024" />
          </restriction>
          </element>
      */

    /* 取得报警数据 */
    inPacket.GetElementValue((char*)"SN", strSN);/* 命令序列号 */
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);/* 报警设备编码 */
    inPacket.GetElementValue((char*)"AlarmPriority", strAlarmPriority);/* 报警级别:1为 一级警情，2为二级警情，3为三级警情，4为四级警情 */
    inPacket.GetElementValue((char*)"AlarmMethod", strAlarmMethod);/* 报警方式: 取值1为电话报警，2为设备报警，3为短信报警，4为GPS报警，5为视频报警，6为设备故障报警，7其它报警 */
    inPacket.GetElementValue((char*)"AlarmTime", strAlarmStartTime);/* 报警开始时间 */
    inPacket.GetElementValue((char*)"StopTime", strAlarmEndTime);/* 报警停止时间 */
    inPacket.GetElementValue((char*)"AlarmStatus", strAlarmStatus);/* 报警状态: 开始或者结束 */
    inPacket.GetElementValue((char*)"AlarmDescription", strAlarmDescription);/* 报警内容描述 */

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_alarm_proc() \
    \r\n XML Para: \
    \r\n SN=%s \
    \r\n DeviceID=%s \
    \r\n AlarmPriority=%s \
    \r\n AlarmMethod=%s \
    \r\n AlarmTime=%s \
    \r\n StopTime=%s \
    \r\n AlarmStatus=%s \
    \r\n AlarmDescription=%s \r\n", strSN, strDeviceID, strAlarmPriority, strAlarmMethod, strAlarmStartTime, strAlarmEndTime, strAlarmStatus, strAlarmDescription);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知报警消息:前端设备ID=%s, 序列号=%s, 报警级别=%s, 报警方式=%s, 报警时间=%s, 结束时间=%s, 报警内容=%s", caller_id, strSN, strAlarmPriority, strAlarmMethod, strAlarmStartTime, strAlarmEndTime, strAlarmDescription);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end device notify the alarm message:front-end device ID=%s, SN=%s, alarm level=%s, alarm type=%s, alarm time=%s, end time=%s, alarm content=%s", caller_id, strSN, strAlarmPriority, strAlarmMethod, strAlarmStartTime, strAlarmEndTime, strAlarmDescription);

    /* 回复响应 */
    outPacket.SetRootTag("Response");
    AccNode = outPacket.CreateElement((char*)"CmdType");
    outPacket.SetElementValue(AccNode, (char*)"Alarm");
    AccNode = outPacket.CreateElement((char*)"SN");
    outPacket.SetElementValue(AccNode, strSN);
    AccNode = outPacket.CreateElement((char*)"DeviceID");
    outPacket.SetElementValue(AccNode, strDeviceID);
    AccNode = outPacket.CreateElement((char*)"Result");
    outPacket.SetElementValue(AccNode, (char*)"OK");

    i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pGBDeviceInfo->strRegServerIP, pGBDeviceInfo->iRegServerPort, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

    if (i != 0)
    {
        SystemLog(EV9000_CMS_NOTIFY_ALARM_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知报警消息处理失败:前端设备ID=%s, 原因=发送响应消息到前端失败, 前端设IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        EnSystemLog(EV9000_CMS_NOTIFY_ALARM_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device notify the alarm message processing failed:front-end device ID=%s, cause=send response message to front-end failed, front-end set IP address=%s, port number=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_alarm_proc() SIP_SendMessage Error:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_alarm_proc() SIP_SendMessage OK:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    }

    /* 查找逻辑设备 */
    pGBLogicDeviceInfo = GBLogicDevice_info_find(strDeviceID);

    if (NULL == pGBLogicDeviceInfo)
    {
        if (EV9000_DEVICETYPE_SIPSERVER == pGBDeviceInfo->device_type) /* 可能是下级CMS的故障告警，没有逻辑点位ID */
        {
            if (g_AlarmMsgSendToUserFlag)
            {
                /* 发送报警数据给客户端用户 */
                i = send_alarm_to_user_proc(inPacket);

                if (i < 0)
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "发送告警消息到在线用户失败");
                    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "TSU alarm messages sent to the online user failed");
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "tsu_alarm_msg_proc() send_alarm_to_user_proc Error\r\n");
                }
                else if (i > 0)
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "发送告警消息到在线用户成功");
                    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "TSU alarm messages sent to the online user successfully");
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "tsu_alarm_msg_proc() send_alarm_to_user_proc OK\r\n");
                }
            }

            /* 转发给上级 */
            if (g_AlarmMsgSendToRouteFlag)
            {
                pos = route_info_find(callee_id);

                if (pos >= 0)
                {
                    pRouteInfo = route_info_get(pos);

                    if (NULL != pRouteInfo)
                    {
                        if (pRouteInfo->reg_status == 1)
                        {
                            /* 转发消息给上级CMS */
                            i = SIP_SendMessage(NULL, local_cms_id_get(), callee_id, pRouteInfo->strRegLocalIP, pRouteInfo->iRegLocalPort, pRouteInfo->server_ip, pRouteInfo->server_port, (char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length());

                            if (i != 0)
                            {
                                SystemLog(EV9000_CMS_NOTIFY_ALARM_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知报警消息处理失败:前端设备ID=%s, 原因=转发到上级CMS失败, 上级CMS ID=%s, IP地址=%s, 端口号=%d", caller_id, callee_id, pRouteInfo->server_ip, pRouteInfo->server_port);
                                EnSystemLog(EV9000_CMS_NOTIFY_ALARM_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device notify the alarm message processing failed:front-end deviceID=%s, cause =forward to superior CMS failed, superior CMS ID=%s, superior CMS IP=%s, port number=%d", caller_id, callee_id, pRouteInfo->server_ip, pRouteInfo->server_port);
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_alarm_proc() SIP_SendMessage Error:dest_id=%s, dest_ip=%s, dest_port=%d \r\n", callee_id, pRouteInfo->server_ip, pRouteInfo->server_port);
                            }
                            else
                            {
                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知报警消息处理成功:前端设备ID=%s, 转发到上级CMS, 上级CMS ID=%s, IP地址=%s, 端口号=%d", caller_id, callee_id, pRouteInfo->server_ip, pRouteInfo->server_port);
                                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end device notify the alarm message processing sucess:front-end deviceID=%s, forward to superior CMS ID=%s, IP=%s, port=%d", caller_id, callee_id, pRouteInfo->server_ip, pRouteInfo->server_port);
                                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_alarm_proc() SIP_SendMessage OK:dest_id=%s, dest_ip=%s, dest_port=%d \r\n", callee_id, pRouteInfo->server_ip, pRouteInfo->server_port);
                            }
                        }
                    }
                    else
                    {
                        SystemLog(EV9000_CMS_NOTIFY_ALARM_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知报警消息处理失败:前端设备ID=%s, 原因=没有找到上级CMS信息, 上级CMS ID=%s", caller_id, callee_id);
                        EnSystemLog(EV9000_CMS_NOTIFY_ALARM_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device notify the alarm message processing failed:front-end device ID=%s, cause = superior CMS information not found, superior CMS ID=%s", caller_id, callee_id);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_alarm_proc() exit---: Get Route Info Error:Route Server ID=%s \r\n", callee_id);
                        return -1;
                    }
                }
                else
                {
                    /* 发送给上级CMS */
                    i = SendMessageToOwnerRouteCMSExceptMMS(NULL, (char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length());

                    if (i < 0)
                    {
                        SystemLog(EV9000_CMS_NOTIFY_ALARM_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知报警消息处理失败:前端设备ID=%s, 原因=转发到上级CMS失败", caller_id);
                        EnSystemLog(EV9000_CMS_NOTIFY_ALARM_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device notify the alarm message processing failed:front-end device ID=%s, cause =forward to superior CMS failed, called side ID=%s", caller_id, callee_id);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_alarm_proc() SendMessageToOwnerRouteCMSExceptMMS Error:callee_id=%s, caller_id=%s \r\n", callee_id, caller_id);
                    }
                    else if (i > 0)
                    {
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知报警消息处理成功:前端设备ID=%s, 转发到上级CMS成功", caller_id);
                        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end device notify the alarm message processing successfully:front-end device ID=%s, called side ID=%s", caller_id, callee_id);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_alarm_proc() SendMessageToOwnerRouteCMSExceptMMS OK:callee_id=%s, caller_id=%s \r\n", callee_id, caller_id);
                    }
                }
            }

            return 0;
        }
        else
        {
            SystemLog(EV9000_CMS_NOTIFY_ALARM_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知报警消息处理失败:前端设备ID=%s, 原因=获取逻辑设备信息错误, 逻辑设备ID=%s", caller_id, strDeviceID);
            EnSystemLog(EV9000_CMS_NOTIFY_ALARM_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device notify the alarm message processing failed: the front end of the device ID=%s, cause = get the logic device information error, logic device ID=%s", caller_id, strDeviceID);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_alarm_proc() Find GBLogicDevice Info Error:DeviceID=%s \r\n", strDeviceID);
            return -1;
        }
    }

    /* 查看逻辑设备是否处于撤防状态 */
    if (!pGBLogicDeviceInfo->guard_type) /* 撤防状态*/
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "前端设备通知报警消息处理成功:前端设备ID=%s, 前端设IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 点位没有布防", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "Front-end device notify the alarm message processing success: the front end of the device ID=%s, the front end of the device IP=%s, port=%d, logic device ID=%s,	GB LogicDevice Not On Guard", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
        DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_notify_alarm_proc() exit---: GB LogicDevice Not On Guard: DeviceID=%s \r\n", strDeviceID);
        return 0;
    }

    /* 添加到报警消息队列 */
    if (strAlarmStatus[0] != '\0')
    {
        if (0 == sstrcmp(strAlarmStatus, (char*)"BEGIN"))
        {
            iAlarmMsgType = 1;
        }
        else if (0 == sstrcmp(strAlarmStatus, (char*)"END"))
        {
            iAlarmMsgType = 2;
        }
        else
        {
            iAlarmMsgType = 0;
        }
    }
    else
    {
        iAlarmMsgType = 0;
    }

    if (pGBLogicDeviceInfo->alarm_duration > 0)
    {
        iArarmDuration = pGBLogicDeviceInfo->alarm_duration;
    }
    else
    {
        iArarmDuration = local_alarm_duration_get();
    }

    i = alarm_msg_add(strSN, pGBLogicDeviceInfo->id, strDeviceID, strAlarmPriority, strAlarmMethod, strAlarmStartTime, strAlarmEndTime, iAlarmMsgType, iArarmDuration, strAlarmDescription, pGBDeviceInfo->device_type);

    if (0 != i)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_alarm_proc() alarm_msg_add Error:DeviceID=%s, AlarmDescription=%s, i=%d \r\n", strDeviceID, strAlarmDescription, i);
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_notify_alarm_proc() alarm_msg_add OK:DeviceID=%s, AlarmDescription=%s, i=%d \r\n", strDeviceID, strAlarmDescription, i);
    }

    /* 转发给上级 */
    if (g_AlarmMsgSendToRouteFlag)
    {
        pos = route_info_find(callee_id);

        if (pos >= 0)
        {
            pRouteInfo = route_info_get(pos);

            if (NULL != pRouteInfo)
            {
                if (pRouteInfo->reg_status == 1)
                {
                    /* 转发消息给上级CMS */
                    i = SIP_SendMessage(NULL, local_cms_id_get(), callee_id, pRouteInfo->strRegLocalIP, pRouteInfo->iRegLocalPort, pRouteInfo->server_ip, pRouteInfo->server_port, (char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length());

                    if (i != 0)
                    {
                        SystemLog(EV9000_CMS_NOTIFY_ALARM_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知报警消息处理失败:前端设备ID=%s, 原因=转发到上级CMS失败, 上级CMS ID=%s, IP地址=%s, 端口号=%d", caller_id, callee_id, pRouteInfo->server_ip, pRouteInfo->server_port);
                        EnSystemLog(EV9000_CMS_NOTIFY_ALARM_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device notify the alarm message processing failed:front-end deviceID=%s, cause =forward to superior CMS failed, superior CMS ID=%s, superior CMS IP=%s, port number=%d", caller_id, callee_id, pRouteInfo->server_ip, pRouteInfo->server_port);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_alarm_proc() SIP_SendMessage Error:dest_id=%s, dest_ip=%s, dest_port=%d \r\n", callee_id, pRouteInfo->server_ip, pRouteInfo->server_port);
                    }
                    else
                    {
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知报警消息处理成功:前端设备ID=%s, 转发到上级CMS, 上级CMS ID=%s, IP地址=%s, 端口号=%d", caller_id, callee_id, pRouteInfo->server_ip, pRouteInfo->server_port);
                        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end device notify the alarm message processing sucess:front-end deviceID=%s, forward to superior CMS ID=%s, IP=%s, port=%d", caller_id, callee_id, pRouteInfo->server_ip, pRouteInfo->server_port);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_alarm_proc() SIP_SendMessage OK:dest_id=%s, dest_ip=%s, dest_port=%d \r\n", callee_id, pRouteInfo->server_ip, pRouteInfo->server_port);
                    }
                }
            }
            else
            {
                SystemLog(EV9000_CMS_NOTIFY_ALARM_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知报警消息处理失败:前端设备ID=%s, 原因=没有找到上级CMS信息, 上级CMS ID=%s", caller_id, callee_id);
                EnSystemLog(EV9000_CMS_NOTIFY_ALARM_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device notify the alarm message processing failed:front-end device ID=%s, cause = superior CMS information not found, superior CMS ID=%s", caller_id, callee_id);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_alarm_proc() exit---: Get Route Info Error:Route Server ID=%s \r\n", callee_id);
                return -1;
            }
        }
        else
        {
            /* 发送给上级CMS */
            i = SendMessageToRouteCMS(pGBLogicDeviceInfo->id, callee_id, (char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length(), pDevice_Srv_dboper);

            if (i < 0)
            {
                SystemLog(EV9000_CMS_NOTIFY_ALARM_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知报警消息处理失败:前端设备ID=%s, 原因=转发到上级CMS失败, 上级CMS ID=%s", caller_id, callee_id);
                EnSystemLog(EV9000_CMS_NOTIFY_ALARM_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device notify the alarm message processing failed:front-end device ID=%s, cause =forward to superior CMS failed, called side ID=%s", caller_id, callee_id);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_alarm_proc() SendMessageToRouteCMS Error:callee_id=%s, caller_id=%s \r\n", callee_id, caller_id);
            }
            else if (i > 0)
            {
                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知报警消息处理成功:前端设备ID=%s, 转发到上级CMS, 上级CMS ID=%s", caller_id, callee_id);
                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end device notify the alarm message processing successfully:front-end device ID=%s, called side ID=%s", caller_id, callee_id);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_alarm_proc() SendMessageToRouteCMS OK:callee_id=%s, caller_id=%s \r\n", callee_id, caller_id);
            }
        }
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_notify_keep_alive_proc
 功能描述  : 设备保活信息处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月13日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_keep_alive_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strStatus[32] = {0};
    int iOldDeviceStatus = 0;
    time_t keepalive_time;
    int tmpKeepAliveTime = 0;
    time_t lastGetCatalogTime = 0;
    struct tm tp = {0};

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_keep_alive_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_keep_alive_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 设备状态信息报送消息
          控制流程见9.6.2.

          命令包括如下字段:
          <!-- 命令类型：设备状态信息报送（必选） -->
          < element name="CmdType" fixed ="Keepalive" />
          <!-- 命令序列号（必选） -->
          <element name="SN" type="integer" minInclusive value = "1" />
          <!-- 源设备的设备编码（必选） -->
          <element name="DeviceID" type="tg:deviceIDType" />
          <!-- 是否正常工作（必选） -->
          <element name="Status" type="tg:resultType" />
     */

    /* 查看被叫是否是本CMS ID */
    if (0 != strncmp(callee_id, local_cms_id_get(), 20))
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_WARN,  "device_notify_keep_alive_proc() exit---: Not Belong To Mine \r\n");
        //return -1;
    }

    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);
    inPacket.GetElementValue((char*)"Status", strStatus);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_keep_alive_proc() \
    \r\n XML Para: \
    \r\n SN=%s, DeviceID=%s, Status=%s \r\n ", strSN, strDeviceID, strStatus);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知保活消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 状态=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID, strStatus);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "device notify keep alive:front-end ID=%s, IP=%s, port=%d, logic device ID=%s, status=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID, strStatus);

    if (0 != sstrcmp(strDeviceID, pGBDeviceInfo->device_id))
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_keep_alive_proc() exit---: DeviceID Error:DeviceID=%s \r\n", strDeviceID);
        return -1;
    }

    iOldDeviceStatus = pGBDeviceInfo->reg_status;

    /* 是否正常工作
        结果类型
    <simpleType name= "resultType">
    <restriction base= "string">
    <enumeration value= "OK" />
    <enumeration value= "ERROR" />
     */


    if (sstrcmp(strStatus, "OK") == 0)
    {
        pGBDeviceInfo->reg_status = 1;

        /* 更新最后保活时间 */
        keepalive_time = time(NULL);

        if (pGBDeviceInfo->last_keep_alive_time <= 0) /* 第一次收到保活消息 */
        {
            /* 更新最后保活时间 */
            pGBDeviceInfo->last_keep_alive_time = keepalive_time;
        }
        else
        {
            tmpKeepAliveTime = keepalive_time - pGBDeviceInfo->last_keep_alive_time;

            /* 更新保活超时时间，取最大的保活时间，海康的保活间隔不固定 */
            if (pGBDeviceInfo->keep_alive_expires < tmpKeepAliveTime)
            {
                pGBDeviceInfo->keep_alive_expires = tmpKeepAliveTime;
            }

            /* 更新最后保活时间 */
            pGBDeviceInfo->last_keep_alive_time = keepalive_time;

            /* 判断一下保活超时时间是否有意义 */
            if (pGBDeviceInfo->keep_alive_expires <= 0)
            {
                pGBDeviceInfo->keep_alive_expires_count = 0;
            }
            else
            {
                pGBDeviceInfo->keep_alive_expires_count = pGBDeviceInfo->keep_alive_expires * 3;
            }
        }

        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_notify_keep_alive_proc() Status OK: device_id=%s, login_ip=%s, Update last_keep_alive_time=%d, keep_alive_expires=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->last_keep_alive_time, pGBDeviceInfo->keep_alive_expires);

        /* 诊断设备不需要获取Catalog */
        if (EV9000_DEVICETYPE_VIDEODIAGNOSIS == pGBDeviceInfo->device_type)
        {

        }
        else
        {
            if (2 == pGBDeviceInfo->iGetCataLogStatus)
            {
                lastGetCatalogTime = time(NULL);

                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "上次检索的下级设备Catalog还没有处理完成:下级设备ID=%s, IP地址=%s, 端口号=%d:最后检索时间=%d, 当前时间=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, pGBDeviceInfo->iLastGetCataLogTime, lastGetCatalogTime);

                if (lastGetCatalogTime > pGBDeviceInfo->iLastGetCataLogTime && lastGetCatalogTime - pGBDeviceInfo->iLastGetCataLogTime >= 600) /* 10分钟超时时间 */
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "上次检索的下级设备Catalog处理超时处理:前端设备ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

                    if (EV9000_DEVICETYPE_DECODER == pGBDeviceInfo->device_type
                        || EV9000_DEVICETYPE_INTELLIGENTANALYSIS  == pGBDeviceInfo->device_type)
                    {
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "上次检索的下级设备Catalog处理超时,自动将已经接收的数据库处理完成:前端设备ID=%s, IP地址=%s, 端口号=%d, 开始根据删除标识删除该物理设备下面的通道", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        pGBDeviceInfo->CataLogNumCount = 0;

                        /* 根据删除标识，设置逻辑设备禁用标识 */
                        i = SetGBLogicDeviceInfoEnableFlagByDelMark(pGBDeviceInfo, pDevice_Srv_dboper);
                    }
                    else if (EV9000_DEVICETYPE_SIPSERVER == pGBDeviceInfo->device_type && 1 == pGBDeviceInfo->three_party_flag) /* 如果是第三方平台，解析分组的情况下 */
                    {
                        if (1 == g_AnalysisSubGroupFlag || 2 == g_AnalysisSubGroupFlag)
                        {
                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "上次检索的下级设备Catalog处理超时,自动将已经接收的数据库处理完成:前端设备ID=%s, IP地址=%s, 端口号=%d, 收到的分组信息数=%d, 根据分组信息删除标识同步掉多余的分组信息以及分组关系信息", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, pGBDeviceInfo->LogicDeviceGroupConfigCount);
                            pGBDeviceInfo->LogicDeviceGroupConfigCount = 0;
                            pGBDeviceInfo->CataLogNumCount = 0;

                            /* 将变化同步到数据库 */
                            i = SynLogicDeviceGroupInfoToDB(pGBDeviceInfo, pDevice_Srv_dboper);
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_notify_keep_alive_proc() SynLogicDeviceGroupInfoToDB:i=%d \r\n", i);

                            /* 删除内存中多余的信息 */
                            i = DelLogicDeviceGroupInfo(pGBDeviceInfo);
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_notify_keep_alive_proc() SynLogicDeviceGroupInfoToDB:i=%d \r\n", i);

                            /* 将变化同步到数据库 */
                            i = SynLogicDeviceMapGroupInfoToDB(pGBDeviceInfo, pDevice_Srv_dboper);
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_notify_keep_alive_proc() SynLogicDeviceMapGroupInfoToDB:i=%d \r\n", i);

                            /* 删除内存中多余的信息 */
                            i = DelLogicDeviceMapGroupInfo(pGBDeviceInfo);
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_notify_keep_alive_proc() DelLogicDeviceMapGroupInfo:i=%d \r\n", i);

                            if (!checkRoutIfHasSendCataProc())
                            {
                                /* 设置逻辑设备分组配置信息数据库更新操作标识 */
                                i = GBLogicDeviceGroupInfoConfig_db_refresh_proc();
                                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_notify_keep_alive_proc() GBLogicDeviceGroupInfoConfig_db_refresh_proc:i=%d \r\n", i);

                                /* 设置逻辑设备分组关系配置信息数据库更新操作标识 */
                                i = GBLogicDeviceGroupMapInfoConfig_db_refresh_proc();
                                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_notify_keep_alive_proc() GBLogicDeviceGroupMapInfoConfig_db_refresh_proc:i=%d \r\n", i);
                            }
                            else
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_WARN,  "device_notify_keep_alive_proc() Has Route Send Catalog Proc \r\n");
                            }
                        }
                    }

                    pGBDeviceInfo->iGetCataLogStatus = 1;
                }
            }
            else
            {
                if (pGBDeviceInfo->device_type == EV9000_DEVICETYPE_SIPSERVER
                    && pGBDeviceInfo->three_party_flag == 1) /* 第三方平台 */
                {
                    /* 如果没有获取到逻辑通道，则重新发送获取信息 */
                    if (0 == pGBDeviceInfo->iGetCataLogStatus)
                    {
                        /* 发送查询设备目录信息的消息 */
                        i = SendQueryDeviceCatalogMessage(pGBDeviceInfo);

                        if (0 != i)
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage Error:i=%d \r\n", i);
                        }
                        else
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage OK:i=%d \r\n", i);
                        }

                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "没有检索到下级第三方平台设备Catalog, 再次发送查询Catalog消息:下级第三方平台设备ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "No Catalog response message from front device, send query catalog message again:front-end device ID=%s, IP address=%s, Port number=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    }
                    else
                    {
                        if (pGBDeviceInfo->iGetLogicDeviceStatusCount <= 2) /* 下级平台注册成功之后，获取1次掉线点位状态，后面进入常规获取Catalog */
                        {
                            pGBDeviceInfo->keep_alive_count++;

                            if (pGBDeviceInfo->keep_alive_count >= 10) /*每保活十次获取一下掉线的点位状态 */
                            {
                                /* 获取掉线点位的状态 */
                                i = SendQueryAllOfflineLogicDeviceStatusMessage(pGBDeviceInfo);

                                if (0 != i)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryAllOfflineLogicDeviceStatusMessage Error:i=%d \r\n", i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryAllOfflineLogicDeviceStatusMessage OK:i=%d \r\n", i);
                                }

                                pGBDeviceInfo->iGetLogicDeviceStatusCount++;
                                pGBDeviceInfo->keep_alive_count = 0;
                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "第三方下级平台保活次数达到10次, 发送第【%d】次查询所有掉线逻辑点位状态信息到前端设备:前端设备ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->iGetLogicDeviceStatusCount, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                            }
                            else
                            {
                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "第三方下级平台设备通知保活: 前端设备ID=%s, IP地址=%s, 端口号=%d, 设备类型=%d, 保活次数=【%d】", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, pGBDeviceInfo->device_type, pGBDeviceInfo->keep_alive_count);
                            }
                        }
                        else
                        {
                            lastGetCatalogTime = time(NULL);
                            localtime_r(&lastGetCatalogTime, &tp);

                            if (tp.tm_hour > 1 && tp.tm_hour <= 2 && lastGetCatalogTime - pGBDeviceInfo->iLastGetCataLogTime > 3600)
                            {
                                /* 发送查询设备目录信息的消息 */
                                i = SendQueryDeviceCatalogMessage(pGBDeviceInfo);

                                if (0 != i)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage Error:i=%d \r\n", i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage OK:i=%d \r\n", i);
                                }

                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "获取下级第三发平台的Catalog的间隔时间超过86400秒, 再次发送查询Catalog消息:下级CMS ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "the time interval of access to the lower platform of the Catalog is more than 1800 seconds, query the Catalog again:lower CMS ID=%s, IP=%s, port=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                            }
                        }
                    }
                }
                else if (pGBDeviceInfo->device_type == EV9000_DEVICETYPE_SIPSERVER
                         && pGBDeviceInfo->three_party_flag == 0) /* 自己的平台 */
                {
                    /* 如果没有获取到逻辑通道，则重新发送获取信息 */
                    if (0 == pGBDeviceInfo->iGetCataLogStatus)
                    {
                        /* 发送查询设备目录信息的消息 */
                        i = SendQueryDeviceCatalogMessage(pGBDeviceInfo);

                        if (0 != i)
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage Error:i=%d \r\n", i);
                        }
                        else
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage OK:i=%d \r\n", i);
                        }

                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "没有检索到下级CMS设备Catalog, 再次发送查询Catalog消息:下级CMS ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "No Catalog response message from front device, send query catalog message again:front-end device ID=%s, IP address=%s, Port number=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    }
                    else
                    {
                        if (pGBDeviceInfo->iGetLogicDeviceStatusCount <= 2) /* 下级平台注册成功之后，获取1次掉线点位状态，后面进入常规获取Catalog */
                        {
                            pGBDeviceInfo->keep_alive_count++;

                            if (pGBDeviceInfo->keep_alive_count >= 10) /*每保活十次获取一下掉线的点位状态 */
                            {
                                /* 获取掉线点位的状态 */
                                i = SendQueryAllOfflineLogicDeviceStatusMessage(pGBDeviceInfo);

                                if (0 != i)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryAllOfflineLogicDeviceStatusMessage Error:i=%d \r\n", i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryAllOfflineLogicDeviceStatusMessage OK:i=%d \r\n", i);
                                }

                                pGBDeviceInfo->iGetLogicDeviceStatusCount++;
                                pGBDeviceInfo->keep_alive_count = 0;
                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "下级平台保活次数达到10次, 发送第【%d】次查询所有掉线逻辑点位状态信息到前端设备:前端设备ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->iGetLogicDeviceStatusCount, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                            }
                            else
                            {
                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "下级平台设备通知保活: 前端设备ID=%s, IP地址=%s, 端口号=%d, 设备类型=%d, 保活次数=【%d】", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, pGBDeviceInfo->device_type, pGBDeviceInfo->keep_alive_count);
                            }
                        }
                        else if (!IsLocalHost(pGBDeviceInfo->login_ip)) /* 不在同一个机器的去获取一下 */
                        {
                            lastGetCatalogTime = time(NULL);
                            localtime_r(&lastGetCatalogTime, &tp);

                            if (tp.tm_hour > 1 && tp.tm_hour <= 2 && lastGetCatalogTime - pGBDeviceInfo->iLastGetCataLogTime > 3600)
                            {
                                /* 发送查询设备目录信息的消息 */
                                i = SendQueryDeviceCatalogMessage(pGBDeviceInfo);

                                if (0 != i)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage Error:i=%d \r\n", i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage OK:i=%d \r\n", i);
                                }

                                /* 获取下级CMS 拓扑物理设备配置表 */
                                i = SendQuerySubCMSTopologyPhyDeviceConfigMessage(pGBDeviceInfo);

                                if (0 != i)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQuerySubCMSTopologyPhyDeviceConfigMessage Error:i=%d \r\n", i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQuerySubCMSTopologyPhyDeviceConfigMessage OK:i=%d \r\n", i);
                                }

                                /*如果不是同级互联，则还需获取逻辑设备分组信息和逻辑设备分组关系信息 */
                                if (pGBDeviceInfo->link_type == 0)
                                {
                                    i = SendQueryDeviceGroupInfoMessage(pGBDeviceInfo);

                                    if (0 != i)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryDeviceGroupInfoMessage Error:DeviceID=%s, i=%d \r\n", pGBDeviceInfo->device_id, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryDeviceGroupInfoMessage OK:DeviceID=%s, i=%d \r\n", pGBDeviceInfo->device_id, i);
                                    }

                                    i = SendQueryDeviceGroupMapInfoMessage(pGBDeviceInfo);

                                    if (0 != i)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryDeviceGroupMapInfoMessage Error:DeviceID=%s, i=%d \r\n", pGBDeviceInfo->device_id, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryDeviceGroupMapInfoMessage OK:DeviceID=%s, i=%d \r\n", pGBDeviceInfo->device_id, i);
                                    }
                                }

                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "获取下级平台的Catalog的间隔时间超过86400秒, 再次发送查询Catalog消息:下级CMS ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "the time interval of access to the lower platform of the Catalog is more than 1800 seconds, query the Catalog again:lower CMS ID=%s, IP=%s, port=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                            }
                        }
                    }
                }
                else if (EV9000_DEVICETYPE_MGWSERVER == pGBDeviceInfo->device_type) /* 接入网关 */
                {
                    /* 如果没有获取到逻辑通道，则重新发送获取信息 */
                    if (0 == pGBDeviceInfo->iGetCataLogStatus)
                    {
                        /* 发送查询设备目录信息的消息 */
                        i = SendQueryDeviceCatalogMessage(pGBDeviceInfo);

                        if (0 != i)
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage Error:i=%d \r\n", i);
                        }
                        else
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage OK:i=%d \r\n", i);
                        }

                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "没有检索到前端媒体网关设备的Catalog, 再次发送查询Catalog消息:前端媒体网关设备ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "No Catalog response message from front device, send query catalog message again:front-end device ID=%s, IP address=%s, Port number=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    }
                    else
                    {
                        if (pGBDeviceInfo->iGetLogicDeviceStatusCount <= 5) /* 接入网关注册成功之后，获取1次Catalog，后面进入常规获取Catalog */
                        {
                            pGBDeviceInfo->keep_alive_count++;

                            if (pGBDeviceInfo->keep_alive_count >= 5) /*每保活五次获取一下CataLog */
                            {
                                /* 获取Catalog */
                                i = SendQueryAllOfflineLogicDeviceStatusMessage(pGBDeviceInfo);

                                if (0 != i)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryAllOfflineLogicDeviceStatusMessage Error:i=%d \r\n", i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryAllOfflineLogicDeviceStatusMessage OK:i=%d \r\n", i);
                                }

                                pGBDeviceInfo->iGetLogicDeviceStatusCount++;
                                pGBDeviceInfo->keep_alive_count = 0;
                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端媒体网关保活次数达到5次, 发送第【%d】次查询Catalog信息到前端设备:前端设备ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->iGetLogicDeviceStatusCount, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end media gateway keep alive at a lower level to reach 3 times, sending the first query [% d] times all dropped logic level status information to the front-end equipment:ID=%s, IP=%s, port=%d", pGBDeviceInfo->iGetLogicDeviceStatusCount, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                            }
                            else
                            {
                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端媒体网关设备通知保活: 前端设备ID=%s, IP地址=%s, 端口号=%d, 设备类型=%d, 保活次数=【%d】", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, pGBDeviceInfo->device_type, pGBDeviceInfo->keep_alive_count);
                                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end media gateway notifications keep alive at a lower level: front-end ID=%s, IP=%s, port=%d, device type=%d, keep alive count=【%d】", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, pGBDeviceInfo->device_type, pGBDeviceInfo->keep_alive_count);
                            }
                        }
                        else
                        {
                            lastGetCatalogTime = time(NULL);
                            localtime_r(&lastGetCatalogTime, &tp);

                            if (lastGetCatalogTime - pGBDeviceInfo->iLastGetCataLogTime > 1800)
                            {
                                /* 发送查询设备目录信息的消息 */
                                i = SendQueryDeviceCatalogMessage(pGBDeviceInfo);

                                if (0 != i)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage Error:i=%d \r\n", i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage OK:i=%d \r\n", i);
                                }

                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "获取前端媒体网关设备的Catalog的间隔时间超过1800秒, 再次发送查询Catalog消息: 前端媒体网关设备ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "The time interval of accessing to the front-end media gateway  of the Catalog is more than 1800 seconds, query the Catalog again:lower CMS ID=%s, IP=%s, port=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                            }
                        }
                    }
                }
                else if (EV9000_DEVICETYPE_DVR == pGBDeviceInfo->device_type
                         || EV9000_DEVICETYPE_NVR == pGBDeviceInfo->device_type) /* NVR */
                {
                    /* 如果没有获取到逻辑通道，则重新发送获取信息 */
                    if (0 == pGBDeviceInfo->iGetCataLogStatus)
                    {
                        /* 发送查询设备目录信息的消息 */
                        i = SendQueryDeviceCatalogMessage(pGBDeviceInfo);

                        if (0 != i)
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage Error:i=%d \r\n", i);
                        }
                        else
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage OK:i=%d \r\n", i);
                        }

                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "没有检索到前端NVR的Catalog, 再次发送查询Catalog消息:前端NVR设备ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "No Catalog response message from front device, send query catalog message again:front-end device ID=%s, IP address=%s, Port number=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    }
                    else
                    {
                        if (pGBDeviceInfo->iGetLogicDeviceStatusCount <= 5) /* 接入网关注册成功之后，获取1次Catalog，后面进入常规获取Catalog */
                        {
                            pGBDeviceInfo->keep_alive_count++;

                            if (pGBDeviceInfo->keep_alive_count >= 5) /*每保活五次获取一下CataLog */
                            {
                                /* 获取Catalog */
                                i = SendQueryAllOfflineLogicDeviceStatusMessage(pGBDeviceInfo);

                                if (0 != i)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryAllOfflineLogicDeviceStatusMessage Error:i=%d \r\n", i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryAllOfflineLogicDeviceStatusMessage OK:i=%d \r\n", i);
                                }

                                pGBDeviceInfo->iGetLogicDeviceStatusCount++;
                                pGBDeviceInfo->keep_alive_count = 0;
                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端NVR保活次数达到5次, 发送第【%d】次查询Catalog信息到前端设备:前端设备ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->iGetLogicDeviceStatusCount, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end media gateway keep alive at a lower level to reach 3 times, sending the first query [% d] times all dropped logic level status information to the front-end equipment:ID=%s, IP=%s, port=%d", pGBDeviceInfo->iGetLogicDeviceStatusCount, pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                            }
                            else
                            {
                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端NVR通知保活: 前端设备ID=%s, IP地址=%s, 端口号=%d, 设备类型=%d, 保活次数=【%d】", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, pGBDeviceInfo->device_type, pGBDeviceInfo->keep_alive_count);
                                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end media gateway notifications keep alive at a lower level: front-end ID=%s, IP=%s, port=%d, device type=%d, keep alive count=【%d】", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, pGBDeviceInfo->device_type, pGBDeviceInfo->keep_alive_count);
                            }
                        }
                        else
                        {
                            lastGetCatalogTime = time(NULL);
                            localtime_r(&lastGetCatalogTime, &tp);

                            if (lastGetCatalogTime - pGBDeviceInfo->iLastGetCataLogTime > 1800)
                            {
                                /* 发送查询设备目录信息的消息 */
                                i = SendQueryDeviceCatalogMessage(pGBDeviceInfo);

                                if (0 != i)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage Error:i=%d \r\n", i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage OK:i=%d \r\n", i);
                                }

                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "获取前端NVR的Catalog的间隔时间超过1800秒, 再次发送查询Catalog消息: 前端媒体网关设备ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "The time interval of accessing to the front-end media gateway  of the Catalog is more than 1800 seconds, query the Catalog again:lower CMS ID=%s, IP=%s, port=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                            }
                        }
                    }
                }
                else if (EV9000_DEVICETYPE_DECODER == pGBDeviceInfo->device_type) /* 解码器 */
                {
                    /* 如果没有获取到逻辑通道，则重新发送获取信息 */
                    if (0 == pGBDeviceInfo->iGetCataLogStatus)
                    {
                        /* 发送查询设备目录信息的消息 */
                        i = SendQueryDeviceCatalogMessage(pGBDeviceInfo);

                        if (0 != i)
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage Error:i=%d \r\n", i);
                        }
                        else
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage OK:i=%d \r\n", i);
                        }

                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "没有检索到前端解码器设备的Catalog, 再次发送查询Catalog消息:前端解码器设备ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "No Catalog response message from front device, send query catalog message again:front-end device ID=%s, IP address=%s, Port number=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    }
                    else
                    {
                        lastGetCatalogTime = time(NULL);
                        localtime_r(&lastGetCatalogTime, &tp);

                        if (lastGetCatalogTime - pGBDeviceInfo->iLastGetCataLogTime > 1800)
                        {
                            /* 发送查询设备目录信息的消息 */
                            i = SendQueryDeviceCatalogMessage(pGBDeviceInfo);

                            if (0 != i)
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage Error:i=%d \r\n", i);
                            }
                            else
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage OK:i=%d \r\n", i);
                            }

                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "获取前端解码器设备的Catalog的间隔时间超过1800秒, 再次发送查询Catalog消息:前端解码器设备ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "The time interval of access to the front end decoder  of the Catalog is more than 1800 seconds, query the Catalog again:lower CMS ID=%s, IP=%s, port=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        }
                    }
                }
                else if (EV9000_DEVICETYPE_ALARMSERVER == pGBDeviceInfo->device_type) /* 报警服务器 */
                {
                    /* 如果没有获取到逻辑通道，则重新发送获取信息 */
                    if (0 == pGBDeviceInfo->iGetCataLogStatus)
                    {
                        /* 发送查询设备目录信息的消息 */
                        i = SendQueryDeviceCatalogMessage(pGBDeviceInfo);

                        if (0 != i)
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage Error:i=%d \r\n", i);
                        }
                        else
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage OK:i=%d \r\n", i);
                        }

                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "没有检索到前端报警服务器的Catalog, 再次发送查询Catalog消息:前端媒体网关设备ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "No Catalog response message from front device, send query catalog message again:front-end device ID=%s, IP address=%s, Port number=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    }
                    else
                    {
                        lastGetCatalogTime = time(NULL);
                        localtime_r(&lastGetCatalogTime, &tp);

                        if (lastGetCatalogTime - pGBDeviceInfo->iLastGetCataLogTime > 1800)
                        {
                            /* 发送查询设备目录信息的消息 */
                            i = SendQueryDeviceCatalogMessage(pGBDeviceInfo);

                            if (0 != i)
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage Error:i=%d \r\n", i);
                            }
                            else
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage OK:i=%d \r\n", i);
                            }

                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "获取前端报警服务器的Catalog的间隔时间超过1800秒, 再次发送查询Catalog消息: 前端报警服务器ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "The time interval of accessing to the alarm server of the Catalog is more than 1800 seconds, query the Catalog again:lower CMS ID=%s, IP=%s, port=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        }
                    }
                }
                else if (EV9000_DEVICETYPE_CAMERA == pGBDeviceInfo->device_type
                         || EV9000_DEVICETYPE_IPC == pGBDeviceInfo->device_type) /* IPC */
                {
                    /* 如果没有获取到逻辑通道，则重新发送获取信息 */
                    if (0 == pGBDeviceInfo->iGetCataLogStatus)
                    {
                        /* 发送查询设备目录信息的消息 */
                        i = SendQueryDeviceCatalogMessage(pGBDeviceInfo);

                        if (0 != i)
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage Error:i=%d \r\n", i);
                        }
                        else
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage OK:i=%d \r\n", i);
                        }

                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "没有检索到前端报警服务器的Catalog, 再次发送查询Catalog消息:前端媒体网关设备ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "No Catalog response message from front device, send query catalog message again:front-end device ID=%s, IP address=%s, Port number=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    }
                    else
                    {
                        lastGetCatalogTime = time(NULL);
                        localtime_r(&lastGetCatalogTime, &tp);

                        if (lastGetCatalogTime - pGBDeviceInfo->iLastGetCataLogTime > 3600)
                        {
                            /* 发送查询设备目录信息的消息 */
                            i = SendQueryDeviceCatalogMessage(pGBDeviceInfo);

                            if (0 != i)
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage Error:i=%d \r\n", i);
                            }
                            else
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage OK:i=%d \r\n", i);
                            }

                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "获取前端IPC的Catalog的间隔时间超过3600秒, 再次发送查询Catalog消息: 前端IPC ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "The time interval of accessing to the alarm server of the Catalog is more than 1800 seconds, query the Catalog again:lower CMS ID=%s, IP=%s, port=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        }
                    }
                }
                else if (EV9000_DEVICETYPE_SIPSERVER != pGBDeviceInfo->device_type
                         && EV9000_DEVICETYPE_VIDEODIAGNOSIS != pGBDeviceInfo->device_type
                         && EV9000_DEVICETYPE_DECODER != pGBDeviceInfo->device_type
                         && EV9000_DEVICETYPE_MGWSERVER != pGBDeviceInfo->device_type
                         && EV9000_DEVICETYPE_ALARMSERVER != pGBDeviceInfo->device_type
                         && EV9000_DEVICETYPE_DVR != pGBDeviceInfo->device_type
                         && EV9000_DEVICETYPE_NVR != pGBDeviceInfo->device_type
                         && EV9000_DEVICETYPE_CAMERA != pGBDeviceInfo->device_type
                         && EV9000_DEVICETYPE_IPC != pGBDeviceInfo->device_type
                        ) /* 其他设备 */
                {
                    /* 如果没有获取到逻辑通道，则重新发送获取信息 */
                    if (0 == pGBDeviceInfo->iGetCataLogStatus)
                    {
                        /* 发送查询设备目录信息的消息 */
                        i = SendQueryDeviceCatalogMessage(pGBDeviceInfo);

                        if (0 != i)
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage Error:i=%d \r\n", i);
                        }
                        else
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage OK:i=%d \r\n", i);
                        }

                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "没有检索到前端设备Catalog, 再次发送查询Catalog消息:前端设备ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "No Catalog response message from front device, send query catalog message again:front-end device ID=%s, IP address=%s, Port number=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    }
                    else
                    {
                        pGBDeviceInfo->keep_alive_count++;

                        if (pGBDeviceInfo->keep_alive_count >= 20) /* 20次保活发送一次查询目录消息 */
                        {
                            /* 发送查询设备目录信息的消息 */
                            i = SendQueryDeviceCatalogMessage(pGBDeviceInfo);

                            if (0 != i)
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage Error:i=%d \r\n", i);
                            }
                            else
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_keep_alive_proc() SendQueryDeviceCatalogMessage OK:i=%d \r\n", i);
                            }

                            pGBDeviceInfo->keep_alive_count = 0;
                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备保活次数达到20次, 发送查询Catalog消息到前端设备:前端设备ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Keep alive message count reached 20, send query catalog message:front-end device ID=%s, IP address=%s, Port number=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        }
                        else
                        {
                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知保活: 前端设备ID=%s, IP地址=%s, 端口号=%d, 设备类型=%d, 保活次数=【%d】", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, pGBDeviceInfo->device_type, pGBDeviceInfo->keep_alive_count);
                            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end device notifications keep alive at a lower level: front-end ID=%s, IP=%s, port=%d, device type=%d, keep alive count=【%d】", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, pGBDeviceInfo->device_type, pGBDeviceInfo->keep_alive_count);
                        }
                    }
                }
            }
        }
    }
    else if (sstrcmp(strStatus, "ERROR") == 0)
    {
        pGBDeviceInfo->reg_status = 0;
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() Status=%s UnKnow \r\n", strStatus);
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备保活消息, 未知状态:前端设备ID=%s, IP地址=%s, 端口号=%d, 状态=%s", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strStatus);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "Front end device keep-alive message, unknow status:front-end device ID=%s, IP address=%s, Port number=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    }

    /* 更新协议栈的状态 */
    if (1 == pGBDeviceInfo->reg_status)
    {
        SIP_UASUpdateRegisterExpires(pGBDeviceInfo->reg_info_index);
    }
    else if (0 == pGBDeviceInfo->reg_status)
    {
        if (iOldDeviceStatus == 1)
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备保活失败, 主动注销登录:前端设备ID=%s, IP地址=%s, 端口号=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "Front end device keep-alive message error, active log off:front-end device ID=%s, IP address=%s, Port number=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

            SIP_UASRemoveRegisterInfo(pGBDeviceInfo->reg_info_index);

            i = GBDevice_reg_msg_add(pGBDeviceInfo->device_id, pGBDeviceInfo->device_type, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, NULL, 0, pGBDeviceInfo->reg_info_index, 0);

            if (i != 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_keep_alive_proc() GBDevice_reg_msg_add Error:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_notify_keep_alive_proc() GBDevice_reg_msg_add OK:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            }
        }
    }

    return 0;
}

/*****************************************************************************
 函 数 名  : device_notify_media_status_proc
 功能描述  : 设备媒体状态消息处理，一般是会话内的，录像回放结束通知消息
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             int ua_dialog_index
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月13日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_media_status_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, int ua_dialog_index, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strNotifyType[32] = {0};
    int cr_pos = -1;
    cr_t* pCrData = NULL;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_media_status_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_media_status_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 查看被叫是否是本CMS ID */
    if (0 != strncmp(callee_id, local_cms_id_get(), 20))
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_WARN,  "device_notify_media_status_proc() exit---: Not Belong To Mine \r\n");
        //return -1;
    }

    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);
    inPacket.GetElementValue((char*)"NotifyType", strNotifyType);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_media_status_proc() \
    \r\n XML Para: \
    \r\n SN=%s, DeviceID=%s, NotifyType=%s \r\n ", strSN, strDeviceID, strNotifyType);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知媒体状态消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 通知类型=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID, strNotifyType);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end equipment notify media status:front-end device ID=%s, IP=%s, port=%d, logic device ID=%s, notify type=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID, strNotifyType);

    if (sstrcmp(strNotifyType, (char*)"121") == 0) /* 录像回放通知结束 */
    {
        /* 1、根据callee index 查找呼叫记录信息 */
        cr_pos = call_record_find_by_callee_index(ua_dialog_index);
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_media_status_proc() call_record_find_by_callee_index:cr_pos=%d \r\n", cr_pos);

        if (cr_pos >= 0)
        {
            pCrData = call_record_get(cr_pos);

            if (NULL == pCrData)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_media_status_proc() exit---: Get Call Record Error \r\n");
                return -1;
            }

            if (0 != sstrcmp(strDeviceID, pCrData->callee_id))
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_media_status_proc() exit---: DeviceID Error:DeviceID=%s, pCrData->callee_id=%s \r\n", strDeviceID, pCrData->callee_id);
                return -1;
            }

            if (CALL_TYPE_RECORD_PLAY != pCrData->call_type && CALL_TYPE_DOWNLOAD != pCrData->call_type)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_media_status_proc() exit---: call_type Error:pCrData->call_type=%d \r\n", pCrData->call_type);
                return -1;
            }

            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端通知录像回放任务结束, 设备ID=%s, IP地址=%s, 端口号=%d, 呼叫任务索引=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, cr_pos);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front device notify playback end:front-end device ID=%s, IP address=%s, Port number=%d, cr pos=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, cr_pos);

            i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);

            /* 停止业务 */
            i = StopCallService(pCrData);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_media_status_proc() StopCallService:cr_pos=%d \r\n", cr_pos);

            /* 移除业务数据 */
            i = call_record_remove(cr_pos);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_media_status_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_notify_media_status_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
            }
        }
        else
        {
            /* 2、根据caller index 查找呼叫记录信息 */
            cr_pos = call_record_find_by_caller_index(ua_dialog_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_media_status_proc() call_record_find_by_caller_index:cr_pos=%d \r\n", cr_pos);

            if (cr_pos >= 0)
            {
                pCrData = call_record_get(cr_pos);

                if (NULL == pCrData)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_media_status_proc() exit---: Get Call Record Error \r\n");
                    return -1;
                }

                if (0 != sstrcmp(strDeviceID, pCrData->callee_id))
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_media_status_proc() exit---: DeviceID Error:DeviceID=%s, pCrData->callee_id=%s \r\n", strDeviceID, pCrData->callee_id);
                    return -1;
                }

                if (CALL_TYPE_RECORD_PLAY != pCrData->call_type && CALL_TYPE_DOWNLOAD != pCrData->call_type)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_media_status_proc() exit---: call_type Error:pCrData->call_type=%d \r\n", pCrData->call_type);
                    return -1;
                }

                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端通知录像回放任务结束, 设备ID=%s, IP地址=%s, 端口号=%d, 呼叫任务索引=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, cr_pos);
                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front device notify playback end:front-end device ID=%s, IP address=%s, Port number=%d, cr pos=%d", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, cr_pos);

                i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);

                /* 停止业务 */
                i = StopCallService(pCrData);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_media_status_proc() StopCallService:cr_pos=%d \r\n", cr_pos);

                /* 移除业务数据 */
                i = call_record_remove(cr_pos);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_media_status_proc() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_notify_media_status_proc() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
                }
            }
        }
    }

    return 0;
}

/*****************************************************************************
 函 数 名  : device_notify_catalog_proc
 功能描述  : 点位变化通知消息处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年9月4日 星期四
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_catalog_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    int logic_device_pos = -1;
    char strSN[32] = {0};
    char strDeviceIndex[64] = {0};
    char strDeviceID[32] = {0};
    char strEvent[32] = {0};
    char strGBLogicDeviceID[32] = {0};
    char strSumNum[16] = {0};
    string strDeviceListNum = "";
    int iSumNum = 0;
    int iDeviceListNum = 0;
    int iItemNumCount = 0;
    char strName[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strEnable[64] = {0};
    char strAlarmDeviceSubType[64] = {0};
    char strCtrlEnable[64] = {0};
    char strMicEnable[64] = {0};
    char strFrameCount[64] = {0};
    char strStreamCount[64] = {0};
    char strAlarmLengthOfTime[64] = {0};
    char strManufacturer[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strModel[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strOwner[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strCivilCode[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strBlock[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strAddress[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strParental[16] = {0};
    char strParentID[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strSafetyWay[16] = {0};
    char strRegisterWay[16] = {0};
    char strCertNum[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strCertifiable[16] = {0};
    char strErrCode[16] = {0};
    char strEndTime[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strSecrecy[16] = {0};
    char strIPAddress[MAX_IP_LEN] = {0};
    char strPort[16] = {0};
    char strPassword[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strStatus[16] = {0};
    char strLongitude[64] = {0};
    char strLatitude[64] = {0};
    char strMapLayer[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strCMSID[MAX_ID_LEN + 4] = {0};
    char strAlarmPriority[32] = {0};/*2016.10.10 add for RCU*/
    char strGuard[32] = {0};/*2016.10.10 add for RCU*/
    char strValue[256] = {0};/*2016.10.10 add for RCU*/
    char strUnit[32] = {0};/*2016.10.10 add for RCU*/
    char strPTZType[64] = {0};
    GBLogicDevice_info_t* pOldGBLogicDeviceInfo = NULL;
    GBLogicDevice_info_t* pNewGBLogicDeviceInfo = NULL;
    GBDevice_info_t* pOldGBDeviceInfo = NULL;
    GBDevice_info_t* pIntelligentGBDeviceInfo = NULL;
    GBDevice_t* pIntelligentGBDevice = NULL;
    DOMElement* ItemAccNode = NULL;
    char strDeviceType[4] = {0};
    int iDeviceType = 0;
    int iDeviceIDLen = 0;
    int iPTZType = 0;
    char* pTmp = NULL;
    //char* tmp_civil_code;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_catalog_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_catalog_proc() exit---: Param Error \r\n");
        return -1;
    }

    //SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备目录通知消息:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    //EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end equipment directory notification message:front-end device ID=%s, IP=%s, port=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

    /* 网络设备信息查询响应消息直接转发，不做处理
          控制流程见9.5.2

          命令包括如下字段:
          <!-- 命令类型：设备目录查询（必选） -->
          <element name="CmdType" fixed ="Catalog" />
          <!-- 命令序列号（必选） -->
          <element name="SN" type="integer" minInclusive value = "1" />
          <!-- 目标设备的设备编码（必选） -->
          <element name="DeviceID" type="tg:deviceIDType" />
          <!-- 设备目录项列表,num表示目录项个数 -->
          <element name="DeviceList">
          <attribute name="Num" type="integer"/>
          <choice minOccurs= "0" maxOccurs= " unbounded " >
          <element name="Item" type="tg:itemType"/>
          </choice>
          </element>
          <!-- 扩展信息，可多项 -->
          <element name= "Info" minOccurs= "0" maxOccurs="unbounded">
          <restriction base= "string">
          <maxLength value= "1024" />
          </restriction>
          </element>
      */

    /* 逻辑设备信息一般是设备注册成功之后CMS主动发起的查询 */
    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);
    inPacket.GetElementValue((char*)"SumNum", strSumNum);
    inPacket.GetElementAttr((char*)"DeviceList", (char*)"Num", strDeviceListNum);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_catalog_proc() \
    \r\n XML Para: \
    \r\n SN=%s \
    \r\n DeviceID=%s \
    \r\n SumNum=%s \
    \r\n DeviceList Num=%s \r\n ", strSN, strDeviceID, strSumNum, (char*)strDeviceListNum.c_str());

    if (strSumNum[0] == '\0')
    {
        SystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备目录通知消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=没有获取到前端上报的逻辑通道目录总数", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        EnSystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device directory notification message processing failed:front-end device ID=%s, cause = Have not get total logic channel directory number from front-end", caller_id);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_catalog_proc() exit---: Get Sun Num Error \r\n");
        return -1;
    }

    /* 可能属于虚拟组织下面,这里的判断暂时去掉
        if (0 != sstrcmp(strDeviceID, pGBDeviceInfo->device_id))
        {
            SystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备目录通知消息处理失败:前端设备ID=%s, 原因=前端设备的XML里面的设备ID错误, XML设备ID=%s", caller_id, strDeviceID);
            EnSystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device directory notification message processing failed: front-end deviceID=%s, cause = device ID from XML of front-end device error, XMLdeviceID=%s", caller_id, strDeviceID);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_catalog_proc() exit---: DeviceID Error:DeviceID=%s \r\n", strDeviceID);
            return -1;
        }
     */

    /* 将设备信息写入标准逻辑设备表 */
    iSumNum = osip_atoi(strSumNum);
    iDeviceListNum = osip_atoi((char*)strDeviceListNum.c_str());
    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_notify_catalog_proc() SumNum=%d, DeviceListNum=%d \r\n", iSumNum, iDeviceListNum);
    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备目录通知消息:前端设备ID=%s, IP地址=%s, 端口号=%d: 上报的逻辑设备总数=%d, 本次上报的逻辑设备个数=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, iSumNum, iDeviceListNum);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end device directory notification message:Report to the total number of logical device=%d,The number of logical device in the report=%d", iSumNum, iDeviceListNum);

    /* 查看被叫是否是本CMS ID */
    if (0 == strncmp(callee_id, local_cms_id_get(), 20))
    {
        if (0 == iSumNum)
        {
            if (EV9000_DEVICETYPE_IPC == pGBDeviceInfo->device_type)
            {
                /* 直接将物理设备信息写入逻辑设备信息 */
                logic_device_pos = AddGBLogicDeviceInfoByGBDeviceInfo(pGBDeviceInfo);

                //DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_catalog_proc() AddGBLogicDeviceInfoByGBDeviceInfo:logic_device_pos=%d \r\n", logic_device_pos);
                i = AddGBLogicDeviceInfo2DB(strDeviceID, pDevice_Srv_dboper);
            }
        }
        else if (iSumNum > 0)
        {
            if (iDeviceListNum <= 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_catalog_proc() exit---: DeviceListNum Error \r\n");
                return -1;
            }

            /* 获取所有的Item 数据 */
            ItemAccNode = inPacket.SearchElement((char*)"Item");

            if (!ItemAccNode)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_catalog_proc() exit---: Get Item Node Error \r\n");
                return -1;
            }

            inPacket.SetCurrentElement(ItemAccNode);

            while (ItemAccNode)
            {
                iItemNumCount++;

                if (iItemNumCount > iDeviceListNum)
                {
                    break;
                }

                memset(strDeviceIndex, 0, 64);
                inPacket.GetElementValue((char*)"ID", strDeviceIndex);

                memset(strGBLogicDeviceID, 0, 32);
                inPacket.GetElementValue((char*)"DeviceID", strGBLogicDeviceID);

                memset(strEvent, 0, 32);
                inPacket.GetElementValue((char*)"Event", strEvent);

                memset(strName, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"Name", strName);

                memset(strEnable, 0, 64);
                inPacket.GetElementValue((char*)"Enable", strEnable);

                memset(strCtrlEnable, 0, 64);
                inPacket.GetElementValue((char*)"CtrlEnable", strCtrlEnable);

                memset(strAlarmDeviceSubType, 0, 64);
                inPacket.GetElementValue((char*)"ChlType", strAlarmDeviceSubType);

                memset(strMicEnable, 0, 64);
                inPacket.GetElementValue((char*)"MicEnable", strMicEnable);

                memset(strFrameCount, 0, 64);
                inPacket.GetElementValue((char*)"FrameCount", strFrameCount);

                memset(strStreamCount, 0, 64);
                inPacket.GetElementValue((char*)"StreamCount", strStreamCount);

                memset(strAlarmLengthOfTime, 0, 64);
                inPacket.GetElementValue((char*)"AlarmLengthOfTime", strAlarmLengthOfTime);

                memset(strManufacturer, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"Manufacturer", strManufacturer);

                memset(strModel, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"Model", strModel);

                memset(strOwner, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"Owner", strOwner);

                memset(strCivilCode, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"CivilCode", strCivilCode);

                memset(strBlock, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"Block", strBlock);

                memset(strAddress, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"Address", strAddress);

                memset(strParental, 0, 16);
                inPacket.GetElementValue((char*)"Parental", strParental);

                memset(strParentID, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"ParentID", strParentID);

                memset(strSafetyWay, 0, 16);
                inPacket.GetElementValue((char*)"SafetyWay", strSafetyWay);

                memset(strRegisterWay, 0, 16);
                inPacket.GetElementValue((char*)"RegisterWay", strRegisterWay);

                memset(strCertNum, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"CertNum", strCertNum);

                memset(strCertifiable, 0, 16);
                inPacket.GetElementValue((char*)"Certifiable", strCertifiable);

                memset(strErrCode, 0, 16);
                inPacket.GetElementValue((char*)"ErrCode", strErrCode);

                memset(strEndTime, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"EndTime", strEndTime);

                memset(strSecrecy, 0, 16);
                inPacket.GetElementValue((char*)"Secrecy", strSecrecy);

                memset(strIPAddress, 0, 16);
                inPacket.GetElementValue((char*)"IPAddress", strIPAddress);

                memset(strPort, 0, 16);
                inPacket.GetElementValue((char*)"Port", strPort);

                memset(strPassword, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"Password", strPassword);

                memset(strStatus, 0, 16);
                inPacket.GetElementValue((char*)"Status", strStatus);

                memset(strLongitude, 0, 64);
                inPacket.GetElementValue((char*)"Longitude", strLongitude);

                memset(strLatitude, 0, 64);
                inPacket.GetElementValue((char*)"Latitude", strLatitude);

                memset(strMapLayer, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"MapLayer", strMapLayer);

                memset(strCMSID, 0, 24);
                inPacket.GetElementValue((char*)"CMSID", strCMSID);

#if 1 /*2016.10.10 add for RCU*/
                memset(strValue, 0, 256);
                inPacket.GetElementValue((char*)"Value", strValue);

                memset(strUnit, 0, 32);
                inPacket.GetElementValue((char*)"Unit", strUnit);

                memset(strGuard, 0, 32);
                inPacket.GetElementValue((char*)"Guard", strGuard);

                memset(strAlarmPriority, 0, 32);
                inPacket.GetElementValue((char*)"AlarmPriority", strAlarmPriority);
#endif/*2016.10.10 add for RCU*/

                /* 确定点位ID长度 */
                iDeviceIDLen = strlen(strGBLogicDeviceID);

                /* 确定逻辑点位设备类型 */
                if ('\0' != strGBLogicDeviceID[0])
                {
                    pTmp = &strGBLogicDeviceID[10];
                    memset(strDeviceType, 0, 4);
                    osip_strncpy(strDeviceType, pTmp, 3);
                    iDeviceType = osip_atoi(strDeviceType);
                }

                if (strGBLogicDeviceID[0] == '\0')
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备目录通知消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=上报的逻辑设备ID为空", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    ItemAccNode = inPacket.SearchNextElement(true);
                    continue;
                }

                if (2 == iDeviceIDLen || 4 == iDeviceIDLen || 6 == iDeviceIDLen || 8 == iDeviceIDLen || 10 == iDeviceIDLen) /* 行政区域编码 */
                {
                    if (1 == g_AnalysisSubGroupFlag || 2 == g_AnalysisSubGroupFlag)
                    {
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备目录通知消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 事件=%s, 逻辑设备ID长度=%d, 逻辑设备类型=%d, 上报的点位为行政区域机构组织编码", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName, strEvent, iDeviceIDLen, iDeviceType);

                        if (EV9000_DEVICETYPE_SIPSERVER == pGBDeviceInfo->device_type && 1 == pGBDeviceInfo->three_party_flag)
                        {
                            if (sstrcmp(strEvent, "ADD") == 0 || sstrcmp(strEvent, "UPDATE") == 0)
                            {
                                i = CivilCodeGBLogicDeviceCatalogInfoProc(pGBDeviceInfo, strGBLogicDeviceID, strName, strParentID, 1, pDevice_Srv_dboper, 1);

                                if (i < 0)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() CivilCodeGBLogicDeviceCatalogInfoProc ERROR:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() CivilCodeGBLogicDeviceCatalogInfoProc OK:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                }
                            }
                            else if (sstrcmp(strEvent, "DEL") == 0)
                            {
                                i = CivilCodeGBLogicDeviceCatalogInfoProc(pGBDeviceInfo, strGBLogicDeviceID, strName, strParentID, 2, pDevice_Srv_dboper, 1);

                                if (i < 0)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() CivilCodeGBLogicDeviceCatalogInfoProc ERROR:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() CivilCodeGBLogicDeviceCatalogInfoProc OK:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                }
                            }
                            else
                            {
                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备目录通知消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 事件=%s, 逻辑设备ID长度=%d, 逻辑设备类型=%d, 上报的点位为行政区域机构组织编码, 不支持的事件类型", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName, strEvent, iDeviceIDLen, iDeviceType);
                            }
                        }
                    }
                    else
                    {
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备目录通知消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 事件=%s, 逻辑设备ID长度=%d, 逻辑设备类型=%d, 上报的点位为行政区域机构组织编码, 本地不解析", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName, strEvent, iDeviceIDLen, iDeviceType);
                    }
                }
                else if (20 == iDeviceIDLen) /* 点位或者业务分组编码 */
                {
                    if (EV9000_DEVICETYPE_TRAFFIC_GROUP == iDeviceType || EV9000_DEVICETYPE_VIRTURAL_ORGAN == iDeviceType) /* 业务分组编码或者虚拟组织编码 */
                    {
                        if (2 == g_AnalysisSubGroupFlag)
                        {
                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备目录通知消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 事件=%s, 逻辑设备ID长度=%d, 逻辑设备类型=%d, 上报的点位为业务分组编码或者虚拟组织编码", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName, strEvent, iDeviceIDLen, iDeviceType);

                            if (EV9000_DEVICETYPE_SIPSERVER == pGBDeviceInfo->device_type && 1 == pGBDeviceInfo->three_party_flag)
                            {
                                if (sstrcmp(strEvent, "ADD") == 0 || sstrcmp(strEvent, "UPDATE") == 0)
                                {
                                    i = GroupCodeGBLogicDeviceCatalogInfoProc(pGBDeviceInfo, strGBLogicDeviceID, strName, strParentID, 1, pDevice_Srv_dboper, 1);

                                    if (i < 0)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() GroupCodeGBLogicDeviceCatalogInfoProc ERROR:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() GroupCodeGBLogicDeviceCatalogInfoProc OK:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                    }
                                }
                                else if (sstrcmp(strEvent, "DEL") == 0)
                                {
                                    i = GroupCodeGBLogicDeviceCatalogInfoProc(pGBDeviceInfo, strGBLogicDeviceID, strName, strParentID, 2, pDevice_Srv_dboper, 1);

                                    if (i < 0)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() GroupCodeGBLogicDeviceCatalogInfoProc ERROR:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() GroupCodeGBLogicDeviceCatalogInfoProc OK:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                    }
                                }
                                else
                                {
                                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备目录通知消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 事件=%s, 逻辑设备ID长度=%d, 逻辑设备类型=%d, 事件类型=%s, 上报的点位为业务分组编码或者虚拟组织编码, 不支持的事件类型", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName, strEvent, iDeviceIDLen, iDeviceType);
                                }
                            }
                        }
                        else
                        {
                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备目录通知消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 事件=%s, 逻辑设备ID长度=%d, 逻辑设备类型=%d, 事件类型=%s, 上报的点位为业务分组编码或者虚拟组织编码, 本地不解析", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName, strEvent, iDeviceIDLen, iDeviceType);
                        }
                    }
                    else
                    {
                        if (sstrcmp(strEvent, "ADD") == 0 || sstrcmp(strEvent, "UPDATE") == 0)
                        {
                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备目录通知消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 事件=%s, 逻辑设备ID长度=%d, 逻辑设备类型=%d, 状态=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName, strEvent, iDeviceIDLen, iDeviceType, strStatus);
                            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end device directory notification message:logic device reported ID=%s, logic point name=%s, event=%s, status=%s", strGBLogicDeviceID, strName, strEvent, strStatus);

                            if (EV9000_DEVICETYPE_INTELLIGENTANALYSIS == pGBDeviceInfo->device_type)/* 智能行为分析设备,在原有逻辑设备信息里面添加智能分析物理设备信息即可 */
                            {
                                i = IntelligentAnalysisGBLogicDeviceCatalogInfoProc(pGBDeviceInfo, strGBLogicDeviceID, pDevice_Srv_dboper);
                            }
                            else
                            {
                                /* 查找旧的逻辑设备,看旧的逻辑设备是否是本级的逻辑设备 */
                                pOldGBLogicDeviceInfo = GBLogicDevice_info_find(strGBLogicDeviceID);

                                if (NULL != pOldGBLogicDeviceInfo && 1 == pOldGBLogicDeviceInfo->enable)
                                {
                                    /* 如果是下级CMS上报的点位，查看是否有重复上报的点位 */
                                    if (EV9000_DEVICETYPE_SIPSERVER == pGBDeviceInfo->device_type)
                                    {
                                        pOldGBDeviceInfo = GBDevice_info_get_by_stream_type(pOldGBLogicDeviceInfo, EV9000_STREAM_TYPE_MASTER);

                                        if (NULL != pOldGBDeviceInfo && 1 == pOldGBDeviceInfo->reg_status)
                                        {
                                            if (0 != sstrcmp(pOldGBDeviceInfo->device_id, pGBDeviceInfo->device_id)) /* 两次上报的物理设备不一样 */
                                            {
                                                if (EV9000_DEVICETYPE_SIPSERVER != pOldGBDeviceInfo->device_type)
                                                {
                                                    SystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 该逻辑设备是本级设备:ID=%s, IP=%s中的逻辑设备", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName, pOldGBDeviceInfo->device_id, pOldGBDeviceInfo->login_ip);
                                                    EnSystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device directory search response message:logic device reported ID=%s, logic point name=%s, this logic device is the local level device ID=%s,IP=%s logic device", strGBLogicDeviceID, strName, pOldGBDeviceInfo->device_id, pOldGBDeviceInfo->login_ip);
                                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_catalog_proc() exit---: GBLogic Device ID=%s, is My Device: ID=%s, IP=%s Logic Device \r\n", strGBLogicDeviceID, pOldGBDeviceInfo->device_id, pOldGBDeviceInfo->login_ip);
                                                    ItemAccNode = inPacket.SearchNextElement(true);
                                                    continue;
                                                }
                                                else
                                                {
                                                    SystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 该逻辑设备是另外一个下级CMS平台:ID=%s, IP=%s中的逻辑设备", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName, pOldGBDeviceInfo->device_id, pOldGBDeviceInfo->login_ip);
                                                    EnSystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device directory search response message:logic device reported ID=%s, logic point name=%s, this logic device is the local level device ID=%s,IP=%s logic device", strGBLogicDeviceID, strName, pOldGBDeviceInfo->device_id, pOldGBDeviceInfo->login_ip);
                                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_catalog_proc() exit---: GBLogic Device ID=%s, is My Device: ID=%s, IP=%s Logic Device \r\n", strGBLogicDeviceID, pOldGBDeviceInfo->device_id, pOldGBDeviceInfo->login_ip);
                                                    ItemAccNode = inPacket.SearchNextElement(true);
                                                    continue;
                                                }
                                            }
                                        }
                                    }
                                }

                                /* 将信息写入新的结构 */
                                i = GBLogicDevice_info_init(&pNewGBLogicDeviceInfo);

                                if (i != 0)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_catalog_proc() exit---: GBLogicDevice Info Init Error \r\n");
                                    ItemAccNode = inPacket.SearchNextElement(true);
                                    continue;
                                }

                                /* 点位统一编号 */
                                if (strGBLogicDeviceID[0] != '\0')
                                {
                                    osip_strncpy(pNewGBLogicDeviceInfo->device_id, strGBLogicDeviceID, MAX_ID_LEN);
                                }

                                /* 逻辑设备索引 */
                                if (strDeviceIndex[0] != '\0')
                                {
                                    pNewGBLogicDeviceInfo->id = strtoul(strDeviceIndex, NULL, 10);
                                }
                                else
                                {
                                    if ('\0' != pNewGBLogicDeviceInfo->device_id[0])
                                    {
                                        pNewGBLogicDeviceInfo->id = crc32((unsigned char*)pNewGBLogicDeviceInfo->device_id, MAX_ID_LEN);
                                    }
                                }

                                /* 所属的CMS统一编号，如果是下级CMS上报的，则存在该数据，如果是具体物理设备，填本级CMSID */
                                if (strCMSID[0] != '\0')
                                {
                                    osip_strncpy(pNewGBLogicDeviceInfo->cms_id, strCMSID, MAX_ID_LEN);
                                }
                                else
                                {
                                    osip_strncpy(pNewGBLogicDeviceInfo->cms_id, local_cms_id_get(), MAX_ID_LEN);
                                }

                                /* 点位名称 */
                                if (strName[0] != '\0')
                                {
                                    osip_strncpy(pNewGBLogicDeviceInfo->device_name, strName, MAX_128CHAR_STRING_LEN);
                                }

                                /* 设备类型 */
                                if (iDeviceType > 0)
                                {
                                    pNewGBLogicDeviceInfo->device_type = iDeviceType;
                                }
                                else
                                {
                                    pNewGBLogicDeviceInfo->device_type = EV9000_DEVICETYPE_IPC;
                                }

                                /* 是否启用 */
                                if (strEnable[0] != '\0')
                                {
                                    pNewGBLogicDeviceInfo->enable = osip_atoi(strEnable);
                                }
                                else
                                {
                                    pNewGBLogicDeviceInfo->enable = 1;
                                }

                                /* 是否可控 */
                                if (strPTZType[0] != '\0') /* 国标新增扩展协议, 1-球机；2-半球；3-固定枪机； 4-遥控枪机 */
                                {
                                    iPTZType = osip_atoi(strPTZType);

                                    pNewGBLogicDeviceInfo->ctrl_enable = iPTZType;
                                }
                                else
                                {
                                    if (strCtrlEnable[0] != '\0')
                                    {
                                        if (0 == sstrcmp((char*)"Disable", strCtrlEnable))
                                        {
                                            pNewGBLogicDeviceInfo->ctrl_enable = 0;
                                        }
                                        else if (0 == sstrcmp((char*)"Enable", strCtrlEnable))
                                        {
                                            pNewGBLogicDeviceInfo->ctrl_enable = 1;
                                        }
                                        else
                                        {
                                            pNewGBLogicDeviceInfo->ctrl_enable = 0;
                                        }
                                    }
                                    else
                                    {
                                        pNewGBLogicDeviceInfo->ctrl_enable = 0;
                                    }
                                }

                                /* 是否支持对讲 */
                                if (strMicEnable[0] != '\0')
                                {
                                    if (0 == sstrcmp((char*)"Disable", strMicEnable))
                                    {
                                        pNewGBLogicDeviceInfo->mic_enable = 0;
                                    }
                                    else if (0 == sstrcmp((char*)"Enable", strMicEnable))
                                    {
                                        pNewGBLogicDeviceInfo->mic_enable = 1;
                                    }
                                    else
                                    {
                                        pNewGBLogicDeviceInfo->mic_enable = 0;
                                    }
                                }
                                else
                                {
                                    pNewGBLogicDeviceInfo->mic_enable = 0;
                                }

                                /* 帧率 */
                                if (strFrameCount[0] != '\0')
                                {
                                    pNewGBLogicDeviceInfo->frame_count = osip_atoi(strFrameCount);
                                }
                                else
                                {
                                    pNewGBLogicDeviceInfo->frame_count = 25;
                                }

                                /* 是否支持多码流 */
                                if (strStreamCount[0] != '\0')
                                {
                                    pNewGBLogicDeviceInfo->stream_count = osip_atoi(strStreamCount);
                                }
                                else
                                {
                                    if (pNewGBLogicDeviceInfo->device_type == EV9000_DEVICETYPE_CAMERA
                                        || pNewGBLogicDeviceInfo->device_type == EV9000_DEVICETYPE_IPC
                                        || pNewGBLogicDeviceInfo->device_type == EV9000_DEVICETYPE_SCREEN
                                        || pNewGBLogicDeviceInfo->device_type == EV9000_DEVICETYPE_CODER)
                                    {
                                        pNewGBLogicDeviceInfo->stream_count = 1;
                                    }
                                    else
                                    {
                                        pNewGBLogicDeviceInfo->stream_count = 0;
                                    }
                                }

                                /* 帧率 */
                                if (strAlarmLengthOfTime[0] != '\0')
                                {
                                    pNewGBLogicDeviceInfo->alarm_duration = osip_atoi(strAlarmLengthOfTime);
                                }
                                else
                                {
                                    pNewGBLogicDeviceInfo->alarm_duration = 0;
                                }

                                /* 是否属于其他域 */
                                pNewGBLogicDeviceInfo->other_realm = 0;

                                /* 对应的媒体物理设备索引 */
                                pNewGBLogicDeviceInfo->phy_mediaDeviceIndex = pGBDeviceInfo->id;

                                /* 对应的媒体物理设备通道 */
                                pNewGBLogicDeviceInfo->phy_mediaDeviceChannel = iItemNumCount - 1;

                                /* 对应的控制物理设备索引 */
                                pNewGBLogicDeviceInfo->phy_ctrlDeviceIndex = pGBDeviceInfo->id;

                                /* 对应的控制物理设备通道 */
                                pNewGBLogicDeviceInfo->phy_ctrlDeviceChannel = iItemNumCount - 1;

                                /* 设备生产商 */
                                if (strManufacturer[0] != '\0')
                                {
                                    osip_strncpy(pNewGBLogicDeviceInfo->manufacturer, strManufacturer, MAX_128CHAR_STRING_LEN);
                                }

                                /* 设备型号 */
                                if (strModel[0] != '\0')
                                {
                                    osip_strncpy(pNewGBLogicDeviceInfo->model, strModel, MAX_128CHAR_STRING_LEN);
                                }

                                /* 设备归属 */
                                if (strOwner[0] != '\0')
                                {
                                    osip_strncpy(pNewGBLogicDeviceInfo->owner, strOwner, MAX_128CHAR_STRING_LEN);
                                }

#if 0

                                /* 行政区域 */
                                if (strCivilCode[0] != '\0')
                                {
                                    if (StringIsAllDigit(strCivilCode)) /* 判断是否为全数字，有的摄像机带过来的就是 CivilCode */
                                    {
                                        if (CivilCodeIsMatchLocalCivilCode(strCivilCode)) /* 如果为全数字，判断是否和本地分组code一致，可能有的摄像机带的错误的编码 */
                                        {
                                            pNewGBLogicDeviceInfo->civil_code = osip_getcopy(strCivilCode);
                                        }
                                        else
                                        {
                                            tmp_civil_code = GetGBLogicDeviceCivilCode(pNewGBLogicDeviceInfo->id, pDevice_Srv_dboper);

                                            if (NULL != tmp_civil_code)
                                            {
                                                pNewGBLogicDeviceInfo->civil_code = osip_getcopy(tmp_civil_code);
                                            }
                                            else
                                            {
                                                pNewGBLogicDeviceInfo->civil_code = osip_getcopy(local_civil_code_get());
                                            }
                                        }
                                    }
                                    else
                                    {
                                        tmp_civil_code = GetGBLogicDeviceCivilCode(pNewGBLogicDeviceInfo->id, pDevice_Srv_dboper);

                                        if (NULL != tmp_civil_code)
                                        {
                                            pNewGBLogicDeviceInfo->civil_code = osip_getcopy(tmp_civil_code);
                                        }
                                        else
                                        {
                                            pNewGBLogicDeviceInfo->civil_code = osip_getcopy(local_civil_code_get());
                                        }
                                    }
                                }
                                else
                                {
                                    tmp_civil_code = GetGBLogicDeviceCivilCode(pNewGBLogicDeviceInfo->id, pDevice_Srv_dboper);

                                    if (NULL != tmp_civil_code)
                                    {
                                        pNewGBLogicDeviceInfo->civil_code = osip_getcopy(tmp_civil_code);
                                    }
                                    else
                                    {
                                        pNewGBLogicDeviceInfo->civil_code = osip_getcopy(local_civil_code_get());
                                    }
                                }

#endif

                                /* 警区 */
                                if (strBlock[0] != '\0')
                                {
                                    osip_strncpy(pNewGBLogicDeviceInfo->block, strBlock, MAX_128CHAR_STRING_LEN);
                                }

                                /* 安装地址 */
                                if (strAddress[0] != '\0')
                                {
                                    osip_strncpy(pNewGBLogicDeviceInfo->address, strAddress, MAX_128CHAR_STRING_LEN);
                                }

                                /* 是否有子设备 */
                                if (strParental[0] != '\0')
                                {
                                    pNewGBLogicDeviceInfo->parental = osip_atoi(strParental);
                                }

                                /* 父设备/区域/系统ID */
                                if (strParentID[0] != '\0')
                                {
                                    osip_strncpy(pNewGBLogicDeviceInfo->parentID, strParentID, MAX_128CHAR_STRING_LEN);
                                }

                                /* 信令安全模式*/
                                if (strSafetyWay[0] != '\0')
                                {
                                    pNewGBLogicDeviceInfo->safety_way = osip_atoi(strSafetyWay);
                                }

                                /* 注册方式 */
                                if (strRegisterWay[0] != '\0')
                                {
                                    pNewGBLogicDeviceInfo->register_way = osip_atoi(strRegisterWay);
                                }

                                /* 证书序列号*/
                                if (strCertNum[0] != '\0')
                                {
                                    osip_strncpy(pNewGBLogicDeviceInfo->cert_num, strCertNum, MAX_128CHAR_STRING_LEN);
                                }

                                /* 证书有效标识 */
                                if (strCertifiable[0] != '\0')
                                {
                                    pNewGBLogicDeviceInfo->certifiable = osip_atoi(strCertifiable);
                                }

                                /* 无效原因码 */
                                if (strErrCode[0] != '\0')
                                {
                                    pNewGBLogicDeviceInfo->error_code = osip_atoi(strErrCode);
                                }

                                /* 证书终止有效期*/
                                if (strEndTime[0] != '\0')
                                {
                                    osip_strncpy(pNewGBLogicDeviceInfo->end_time, strEndTime, MAX_128CHAR_STRING_LEN);
                                }

                                /* 保密属性 */
                                if (strSecrecy[0] != '\0')
                                {
                                    pNewGBLogicDeviceInfo->secrecy = osip_atoi(strSecrecy);
                                }

                                /* IP地址*/
                                if (strIPAddress[0] != '\0')
                                {
                                    osip_strncpy(pNewGBLogicDeviceInfo->ip_address, strIPAddress, MAX_IP_LEN);
                                }
                                else
                                {
                                    osip_strncpy(pNewGBLogicDeviceInfo->ip_address, pGBDeviceInfo->login_ip, MAX_IP_LEN);
                                }

                                /* 端口号*/
                                if (strPort[0] != '\0')
                                {
                                    pNewGBLogicDeviceInfo->port = osip_atoi(strPort);
                                }
                                else
                                {
                                    pNewGBLogicDeviceInfo->port = 0;
                                }

                                /* 密码*/
                                if (strPassword[0] != '\0')
                                {
                                    osip_strncpy(pNewGBLogicDeviceInfo->password, strPassword, MAX_128CHAR_STRING_LEN);
                                }

                                /* 点位状态 */
                                if (strStatus[0] != '\0' && (0 == sstrcmp(strStatus, (char*)"ON") || 0 == sstrcmp(strStatus, (char*)"ONLINE")))
                                {
                                    pNewGBLogicDeviceInfo->status = 1;
                                }
                                else if (strStatus[0] != '\0' && (0 == sstrcmp(strStatus, (char*)"OFF") || 0 == sstrcmp(strStatus, (char*)"OFFLINE")))
                                {
                                    pNewGBLogicDeviceInfo->status = 0;
                                    pNewGBLogicDeviceInfo->intelligent_status = INTELLIGENT_STATUS_NULL;
                                    pNewGBLogicDeviceInfo->alarm_status = ALARM_STATUS_NULL;
                                }
                                else if (strStatus[0] != '\0' && 0 == sstrcmp(strStatus, (char*)"NOVIDEO"))
                                {
                                    pNewGBLogicDeviceInfo->status = 2;
                                }
                                else if (strStatus[0] != '\0' && 0 == sstrcmp(strStatus, (char*)"VLOST"))
                                {
                                    pNewGBLogicDeviceInfo->status = 2;
                                }
                                else if (strStatus[0] != '\0' && 0 == sstrcmp(strStatus, (char*)"INTELLIGENT"))
                                {
                                    pNewGBLogicDeviceInfo->status = 1;
                                    pNewGBLogicDeviceInfo->intelligent_status = INTELLIGENT_STATUS_ON;
                                }
                                else if (strStatus[0] != '\0' && 0 == sstrcmp(strStatus, (char*)"CLOSE"))
                                {
                                    pNewGBLogicDeviceInfo->status = 1;
                                    pNewGBLogicDeviceInfo->alarm_status = ALARM_STATUS_CLOSE;
                                }
                                else if (strStatus[0] != '\0' && 0 == sstrcmp(strStatus, (char*)"APART"))
                                {
                                    pNewGBLogicDeviceInfo->status = 1;
                                    pNewGBLogicDeviceInfo->alarm_status = ALARM_STATUS_APART;
                                }
                                else
                                {
                                    pNewGBLogicDeviceInfo->status = 0;
                                }

                                /* 经度 */
                                if (strLongitude[0] != '\0')
                                {
                                    pNewGBLogicDeviceInfo->longitude = strtod(strLongitude, (char**) NULL);
                                }

                                /* 纬度 */
                                if (strLatitude[0] != '\0')
                                {
                                    pNewGBLogicDeviceInfo->latitude = strtod(strLatitude, (char**) NULL);
                                }

                                /* 所属图层 */
                                if (strMapLayer[0] != '\0')
                                {
                                    osip_strncpy(pNewGBLogicDeviceInfo->map_layer, strMapLayer, MAX_128CHAR_STRING_LEN);
                                }

                                /* 报警设备子类型 */
                                if (strAlarmDeviceSubType[0] != '\0')
                                {
                                    pNewGBLogicDeviceInfo->alarm_device_sub_type = osip_atoi(strAlarmDeviceSubType);
                                }
                                else
                                {
                                    pNewGBLogicDeviceInfo->alarm_device_sub_type = 0;
                                }

                                /* 报警级别 */
                                if (strAlarmPriority[0] != '\0')
                                {
                                    pNewGBLogicDeviceInfo->AlarmPriority = osip_atoi(strAlarmPriority);
                                }

                                /* 是否布防 */
                                if (strGuard[0] != '\0')
                                {
                                    pNewGBLogicDeviceInfo->guard_type = osip_atoi(strGuard);
                                }

                                /* 单位 */
                                if (strUnit[0] != '\0')
                                {
                                    osip_strncpy(pNewGBLogicDeviceInfo->Unit, strUnit, 32);
                                }

                                /* Value */
                                if (strValue[0] != '\0')
                                {
                                    osip_strncpy(pNewGBLogicDeviceInfo->Value, strValue, 256);
                                }

                                i = GBDevice_add(pNewGBLogicDeviceInfo, EV9000_STREAM_TYPE_MASTER, pGBDeviceInfo);

                                if (i < 0)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() GBDevice_add:device_id=%s, stream_type=EV9000_STREAM_TYPE_MASTER Error:i=%d \r\n", pNewGBLogicDeviceInfo->device_id, i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_notify_catalog_proc() GBDevice_add:device_id=%s, stream_type=EV9000_STREAM_TYPE_MASTER OK:i=%d \r\n", pNewGBLogicDeviceInfo->device_id, i);
                                }

                                /* 根据旧的逻辑设备判断 */
                                if (NULL != pOldGBLogicDeviceInfo)
                                {
                                    i = GBLogicDeviceCatalogInfoProc(pGBDeviceInfo, pNewGBLogicDeviceInfo, pOldGBLogicDeviceInfo, pDevice_Srv_dboper);

                                    if (i < 0)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() GBLogicDeviceCatalogInfoProc Error:i=%d \r\n", i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_notify_catalog_proc() GBLogicDeviceCatalogInfoProc:iRet=%d \r\n", i);
                                    }

                                    /* 处理分组关系 */
                                    if (EV9000_DEVICETYPE_SIPSERVER == pGBDeviceInfo->device_type && 1 == pGBDeviceInfo->three_party_flag)
                                    {
                                        if (1 == g_AnalysisSubGroupFlag) /* 只解析行政区域编码 */
                                        {
                                            /* 行政区域 */
                                            i = GBLogicDeviceCatalogGroupMapProc(pGBDeviceInfo, pNewGBLogicDeviceInfo, strCivilCode, pDevice_Srv_dboper, 1);
                                        }
                                        else if (2 == g_AnalysisSubGroupFlag) /* 解析业务分组编码 */
                                        {
                                            /* 父设备/区域/系统ID */
                                            if (strParentID[0] != '\0')
                                            {
                                                if (0 == strcmp(strParentID, pGBDeviceInfo->device_id)) /* 如果父节点是平台ID，则还以行政区域编码为准 */
                                                {
                                                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "前端设备目录通知消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 携带的ParentID是下级平台的服务器ID,默认使用CivilCode作为分组依据", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName);

                                                    /* 行政区域 */
                                                    i = GBLogicDeviceCatalogGroupMapProc(pGBDeviceInfo, pNewGBLogicDeviceInfo, strCivilCode, pDevice_Srv_dboper, 1);
                                                }
                                                else
                                                {
                                                    i = GBLogicDeviceCatalogGroupMapProc(pGBDeviceInfo, pNewGBLogicDeviceInfo, strParentID, pDevice_Srv_dboper, 1);
                                                }
                                            }
                                            else
                                            {
                                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "前端设备目录通知消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 携带的ParentID是空,默认使用CivilCode作为分组依据", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName);

                                                /* 行政区域 */
                                                i = GBLogicDeviceCatalogGroupMapProc(pGBDeviceInfo, pNewGBLogicDeviceInfo, strCivilCode, pDevice_Srv_dboper, 1);
                                            }
                                        }
                                    }

                                    GBLogicDevice_info_free(pNewGBLogicDeviceInfo);
                                    osip_free(pNewGBLogicDeviceInfo);
                                    pNewGBLogicDeviceInfo = NULL;
                                }
                                else
                                {
                                    /* 添加逻辑设备信息 */
                                    logic_device_pos = GBLogicDevice_info_add(pNewGBLogicDeviceInfo);

                                    //DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_catalog_proc() GBLogicDevice_info_add:logic_device_pos=%d \r\n", logic_device_pos);

                                    if (logic_device_pos < 0)
                                    {
                                        GBLogicDevice_info_free(pNewGBLogicDeviceInfo);
                                        osip_free(pNewGBLogicDeviceInfo);
                                        pNewGBLogicDeviceInfo = NULL;
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_catalog_proc() exit---: GBLogicDevice Info Add Error \r\n");
                                        ItemAccNode = inPacket.SearchNextElement(true);
                                        continue;
                                    }

                                    /* 发送Catalog变化通知事件消息处理 */
                                    i = SendNotifyCatalogMessageToAllRoute(pNewGBLogicDeviceInfo, 0, pDevice_Srv_dboper);

                                    if (i < 0)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_catalog_proc() SendNotifyCatalogMessageToAllRoute Error:iRet=%d \r\n", i);
                                    }
                                    else if (i > 0)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_notify_catalog_proc() SendNotifyCatalogMessageToAllRoute OK:iRet=%d \r\n", i);
                                    }

                                    /* 更新数据库 */
                                    i = AddGBLogicDeviceInfo2DB(strGBLogicDeviceID, pDevice_Srv_dboper);

                                    if (i < 0)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() AddGBLogicDeviceInfo2DB ERROR:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() AddGBLogicDeviceInfo2DB OK:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                    }

                                    /* 处理分组关系 */
                                    if (EV9000_DEVICETYPE_SIPSERVER == pGBDeviceInfo->device_type && 1 == pGBDeviceInfo->three_party_flag)
                                    {
                                        if (1 == g_AnalysisSubGroupFlag) /* 只解析行政区域编码 */
                                        {
                                            /* 行政区域 */
                                            i = GBLogicDeviceCatalogGroupMapProc(pGBDeviceInfo, pNewGBLogicDeviceInfo, strCivilCode, pDevice_Srv_dboper, 1);
                                        }
                                        else if (2 == g_AnalysisSubGroupFlag) /* 解析业务分组编码 */
                                        {
                                            /* 父设备/区域/系统ID */
                                            if (strParentID[0] != '\0')
                                            {
                                                if (0 == strcmp(strParentID, pGBDeviceInfo->device_id)) /* 如果父节点是平台ID，则还以行政区域编码为准 */
                                                {
                                                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "前端设备目录通知消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 携带的ParentID是下级平台的服务器ID,默认使用CivilCode作为分组依据", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName);

                                                    /* 行政区域 */
                                                    i = GBLogicDeviceCatalogGroupMapProc(pGBDeviceInfo, pNewGBLogicDeviceInfo, strCivilCode, pDevice_Srv_dboper, 1);
                                                }
                                                else
                                                {
                                                    i = GBLogicDeviceCatalogGroupMapProc(pGBDeviceInfo, pNewGBLogicDeviceInfo, strParentID, pDevice_Srv_dboper, 1);
                                                }
                                            }
                                            else
                                            {
                                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "前端设备目录通知消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 携带的ParentID是空,默认使用CivilCode作为分组依据", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName);

                                                /* 行政区域 */
                                                i = GBLogicDeviceCatalogGroupMapProc(pGBDeviceInfo, pNewGBLogicDeviceInfo, strCivilCode, pDevice_Srv_dboper, 1);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else if (sstrcmp(strEvent, "DEL") == 0)
                        {
                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备目录通知:前端设备ID=%s, IP地址=%s, 端口号=%d, 删除点位, 上报的逻辑设备ID=%s, 逻辑点位名称=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName);
                            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "Front-end device directory notify delete message:logic device reported ID=%s, logic point name=%s", strGBLogicDeviceID, strName);
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_catalog_proc() : DeviceID=%s, DeviceName=%s, Notify Event=DEL \r\n", strGBLogicDeviceID, strName);

                            /* 查找旧的逻辑设备 */
                            pOldGBLogicDeviceInfo = GBLogicDevice_info_find(strGBLogicDeviceID);

                            if (NULL == pOldGBLogicDeviceInfo)
                            {
                                SystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备目录通知:前端设备ID=%s, IP地址=%s, 端口号=%d, 删除点位, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 没有找到对应的逻辑设备信息", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName);
                                EnSystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device directory notify delete message:logic device reported ID=%s, logic point name=%s, did not find corresponding logic device", strGBLogicDeviceID, strName);
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_catalog_proc() exit---: Find GBLogicDevice Info Error \r\n");
                                ItemAccNode = inPacket.SearchNextElement(true);
                                continue;
                            }

                            if (0 == pOldGBLogicDeviceInfo->enable)
                            {
                                SystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_WARNING, "前端设备目录通知:前端设备ID=%s, IP地址=%s, 端口号=%d, 删除点位, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 上报的点位已经被禁用", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName);
                                EnSystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_WARNING, "Front-end device directory notify delete message:logic device reported ID=%s, logic point name=%s, analysis point reported is disabled", strGBLogicDeviceID, strName);
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_catalog_proc() exit---: Find GBLogicDevice Info Error \r\n");
                                ItemAccNode = inPacket.SearchNextElement(true);
                                continue;
                            }

                            if (EV9000_DEVICETYPE_INTELLIGENTANALYSIS == pGBDeviceInfo->device_type)/* 智能行为分析设备,在原有逻辑设备信息里面添加智能分析物理设备信息即可 */
                            {
                                /* 移除智能分析物理设备 */
                                i = GBDevice_remove(pOldGBLogicDeviceInfo, EV9000_STREAM_TYPE_INTELLIGENCE);

                                if (i < 0)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() GBDevice_remove:device_id=%s, stream_type=EV9000_STREAM_TYPE_INTELLIGENCE Error:i=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_notify_catalog_proc() GBDevice_remove:device_id=%s, stream_type=EV9000_STREAM_TYPE_INTELLIGENCE OK:i=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                }

                                i = StopAllServiceTaskByLogicDeviceIDAndStreamType(pOldGBLogicDeviceInfo->device_id, EV9000_STREAM_TYPE_INTELLIGENCE);

                                if (0 != i)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() StopAllServiceTaskByLogicDeviceIDAndStreamType ERROR:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() StopAllServiceTaskByLogicDeviceIDAndStreamType OK:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                }

                                if (INTELLIGENT_STATUS_ON == pOldGBLogicDeviceInfo->intelligent_status)
                                {
                                    pOldGBLogicDeviceInfo->intelligent_status = INTELLIGENT_STATUS_NULL;

                                    if (1 == pOldGBLogicDeviceInfo->status)
                                    {
                                        /* 发送设备状态变化消息  */
                                        i = SendDeviceStatusMessageProc(pOldGBLogicDeviceInfo, pOldGBLogicDeviceInfo->status, pDevice_Srv_dboper);

                                        if (0 != i)
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() SendDeviceStatusMessageProc ERROR:device_id=%s, status=%d, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, pOldGBLogicDeviceInfo->status, i);
                                        }
                                        else
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() SendDeviceStatusMessageProc OK:device_id=%s, status=%d, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, pOldGBLogicDeviceInfo->status, i);
                                        }

                                        /* 发送告警信息到客户端 */
                                        i = SendIntelligentDeviceOffLineAlarmToAllClientUser(pOldGBLogicDeviceInfo->device_id);

                                        if (0 != i)
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() SendIntelligentDeviceOffLineAlarmToAllClientUser Error:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                        }
                                        else
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() SendIntelligentDeviceOffLineAlarmToAllClientUser OK:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                        }
                                    }
                                }
                            }
                            else
                            {
                                pOldGBLogicDeviceInfo->enable = 0;
                                pOldGBLogicDeviceInfo->status = 0;

                                /* 发送设备状态消息给客户端 */
                                i = SendDeviceStatusToAllClientUser(pOldGBLogicDeviceInfo->device_id, 0, pDevice_Srv_dboper);

                                if (i < 0)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_catalog_proc() SendDeviceStatusToAllClientUser Error:iRet=%d \r\n", i);
                                }
                                else if (i > 0)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_notify_catalog_proc() SendDeviceStatusToAllClientUser OK:iRet=%d \r\n", i);
                                }

                                /* 发送Catalog变化通知事件消息处理  */
                                i = SendNotifyCatalogMessageToAllRoute(pOldGBLogicDeviceInfo, 1, pDevice_Srv_dboper);

                                if (i < 0)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() SendNotifyCatalogMessageToAllRoute ERROR:device_id=%s, status=%d, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, pOldGBLogicDeviceInfo->status, i);
                                }
                                else if (i > 0)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() SendNotifyCatalogMessageToAllRoute OK:device_id=%s, status=%d, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, pOldGBLogicDeviceInfo->status, i);
                                }

                                /* 发送告警信息到客户端 */
                                i = SendDeviceOffLineAlarmToAllClientUser(pOldGBLogicDeviceInfo->device_id);

                                if (0 != i)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() SendDeviceOffLineAlarmToAllClientUser Error:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() SendDeviceOffLineAlarmToAllClientUser OK:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                }

                                /* 停止呼叫任务 */
                                if (pGBDeviceInfo->device_type == EV9000_DEVICETYPE_DECODER) /* 解码器通道根据主叫ID停止业务 */
                                {
                                    i = StopAllServiceTaskByCallerID(pOldGBLogicDeviceInfo->device_id);

                                    if (0 != i)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() StopAllServiceTaskByCallerID ERROR:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_notify_catalog_proc() StopAllServiceTaskByCallerID OK:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                    }
                                }
                                else
                                {
                                    i = StopAllServiceTaskByLogicDeviceID(pOldGBLogicDeviceInfo->device_id);

                                    if (0 != i)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() StopAllServiceTaskByLogicDeviceID ERROR:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_notify_catalog_proc() StopAllServiceTaskByLogicDeviceID OK:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                    }

                                    /* 停止音频对讲业务 */
                                    i = StopAudioServiceTaskByLogicDeviceID(pOldGBLogicDeviceInfo->device_id);

                                    if (0 != i)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() StopAudioServiceTaskByLogicDeviceID Error:DeviceID=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() StopAudioServiceTaskByLogicDeviceID OK:DeviceID=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                    }
                                }

                                /* 更新数据库 */
                                i = AddGBLogicDeviceInfo2DB(strGBLogicDeviceID, pDevice_Srv_dboper);

                                if (i < 0)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() AddGBLogicDeviceInfo2DB ERROR:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_notify_catalog_proc() AddGBLogicDeviceInfo2DB OK:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                }
                            }
                        }
                        else if (sstrcmp(strEvent, "ON") == 0)
                        {
                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备目录通知:前端设备ID=%s, IP地址=%s, 端口号=%d, 点位上线, 上报的逻辑设备ID=%s, 逻辑点位名称=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName);
                            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end device directory notify online message:logic device reported ID=%s, logic point name=%s", strGBLogicDeviceID, strName);
                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_catalog_proc() : DeviceID=%s, DeviceName=%s, Notify Event=OFF \r\n", strGBLogicDeviceID, strName);

                            /* 查找旧的逻辑设备 */
                            pOldGBLogicDeviceInfo = GBLogicDevice_info_find(strGBLogicDeviceID);

                            if (NULL == pOldGBLogicDeviceInfo)
                            {
                                SystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备目录通知:前端设备ID=%s, IP地址=%s, 端口号=%d, 点位上线, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 没有找到对应的逻辑设备信息", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName);
                                EnSystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device directory notify online message:logic device reported ID=%s, logic point name=%s, did not find corresponding logic device", strGBLogicDeviceID, strName);
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_catalog_proc() exit---: Find GBLogicDevice Info Error \r\n");
                                ItemAccNode = inPacket.SearchNextElement(true);
                                continue;
                            }

                            if (EV9000_DEVICETYPE_INTELLIGENTANALYSIS == pGBDeviceInfo->device_type)/* 智能行为分析设备,在原有逻辑设备信息里面添加智能分析物理设备信息即可 */
                            {
                                if (0 == pOldGBLogicDeviceInfo->enable)
                                {
                                    SystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_WARNING, "前端设备目录通知:前端设备ID=%s, IP地址=%s, 端口号=%d, 点位上线, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 前端设备是智能行为分析设备，上报的分析点位已经被禁用", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName);
                                    EnSystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_WARNING, "Front-end device directory notify online message:logic device reported ID=%s, logic point name=%s, front-end device is intelligent analysis device，analysis point reported is disabled", strGBLogicDeviceID, strName);
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_catalog_proc() exit---: Find GBLogicDevice Info Error \r\n");
                                    ItemAccNode = inPacket.SearchNextElement(true);
                                    continue;
                                }

                                if (INTELLIGENT_STATUS_NULL == pOldGBLogicDeviceInfo->intelligent_status)
                                {
                                    pOldGBLogicDeviceInfo->intelligent_status = INTELLIGENT_STATUS_ON;

                                    /* 发送设备状态消息给客户端 */
                                    if (1 == pOldGBLogicDeviceInfo->status)
                                    {
                                        /* 发送设备状态变化消息  */
                                        i = SendDeviceStatusMessageProc(pOldGBLogicDeviceInfo, 4, pDevice_Srv_dboper);

                                        if (0 != i)
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() SendDeviceStatusMessageProc ERROR:device_id=%s, status=%d, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, 4, i);
                                        }
                                        else
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() SendDeviceStatusMessageProc OK:device_id=%s, status=%d, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, 4, i);
                                        }
                                    }
                                }

                                /* 增加智能分析类型设备 */
                                pIntelligentGBDevice = GBDevice_get_by_stream_type(pOldGBLogicDeviceInfo, EV9000_STREAM_TYPE_INTELLIGENCE);

                                if (NULL != pIntelligentGBDevice) /* 已经存在，比较看是否一样 */
                                {
                                    pIntelligentGBDeviceInfo = pIntelligentGBDevice->ptGBDeviceInfo;

                                    if (NULL != pIntelligentGBDeviceInfo)
                                    {
                                        if (pIntelligentGBDeviceInfo != pGBDeviceInfo)
                                        {
                                            pIntelligentGBDevice->ptGBDeviceInfo = pGBDeviceInfo;
                                        }
                                    }
                                    else
                                    {
                                        pIntelligentGBDevice->ptGBDeviceInfo = pGBDeviceInfo;
                                    }
                                }
                                else /* 不存在，直接添加 */
                                {
                                    i = GBDevice_add(pOldGBLogicDeviceInfo, EV9000_STREAM_TYPE_INTELLIGENCE, pGBDeviceInfo);

                                    if (i < 0)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() GBDevice_add:device_id=%s, stream_type=EV9000_STREAM_TYPE_INTELLIGENCE Error:i=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_notify_catalog_proc() GBDevice_add:device_id=%s, stream_type=EV9000_STREAM_TYPE_INTELLIGENCE OK:i=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                    }
                                }
                            }
                            else
                            {
                                if (0 == pOldGBLogicDeviceInfo->enable)
                                {
                                    pOldGBLogicDeviceInfo->enable = 1;
                                    pOldGBLogicDeviceInfo->status = 1;
                                }

                                if (pOldGBLogicDeviceInfo->status == 0)
                                {
                                    pOldGBLogicDeviceInfo->status = 1;

                                    /* 发送设备状态变化消息  */
                                    i = SendDeviceStatusMessageProc(pOldGBLogicDeviceInfo, pOldGBLogicDeviceInfo->status, pDevice_Srv_dboper);

                                    if (0 != i)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() SendDeviceStatusMessageProc ERROR:device_id=%s, status=%d, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, pOldGBLogicDeviceInfo->status, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() SendDeviceStatusMessageProc OK:device_id=%s, status=%d, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, pOldGBLogicDeviceInfo->status, i);
                                    }

                                    /* 更新数据库 */
                                    i = AddGBLogicDeviceInfo2DB(strGBLogicDeviceID, pDevice_Srv_dboper);

                                    if (i < 0)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() AddGBLogicDeviceInfo2DB ERROR:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() AddGBLogicDeviceInfo2DB OK:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                    }
                                }
                            }
                        }
                        else if (sstrcmp(strEvent, "OFF") == 0)
                        {
                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备目录通知:前端设备ID=%s, IP地址=%s, 端口号=%d, 点位下线, 上报的逻辑设备ID=%s, 逻辑点位名称=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName);
                            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "Front-end device directory notify offline message:logic device reported ID=%s, logic point name=%s", strGBLogicDeviceID, strName);

                            /* 查找旧的逻辑设备 */
                            pOldGBLogicDeviceInfo = GBLogicDevice_info_find(strGBLogicDeviceID);

                            if (NULL == pOldGBLogicDeviceInfo)
                            {
                                SystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备目录通知:前端设备ID=%s, IP地址=%s, 端口号=%d, 点位下线, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 没有找到对应的逻辑设备信息", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName);
                                EnSystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device directory notify offline message:logic device reported ID=%s, logic point name=%s, did not find corresponding logic device", strGBLogicDeviceID, strName);
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_catalog_proc() exit---: Find GBLogicDevice Info Error \r\n");
                                ItemAccNode = inPacket.SearchNextElement(true);
                                continue;
                            }

                            if (0 == pOldGBLogicDeviceInfo->enable)
                            {
                                SystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_WARNING, "前端设备目录通知:前端设备ID=%s, IP地址=%s, 端口号=%d, 点位下线, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 上报的点位已经被禁用", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName);
                                EnSystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_WARNING, "Front-end device directory notify offline message:logic device reported ID=%s, logic point name=%s, analysis point reported is disabled", strGBLogicDeviceID, strName);
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_catalog_proc() exit---: Find GBLogicDevice Info Error \r\n");
                                ItemAccNode = inPacket.SearchNextElement(true);
                                continue;
                            }

                            if (EV9000_DEVICETYPE_INTELLIGENTANALYSIS == pGBDeviceInfo->device_type)/* 智能行为分析设备,在原有逻辑设备信息里面添加智能分析物理设备信息即可 */
                            {
                                i = GBDevice_remove(pOldGBLogicDeviceInfo, EV9000_STREAM_TYPE_INTELLIGENCE);

                                if (i < 0)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() GBDevice_remove:device_id=%s, stream_type=EV9000_STREAM_TYPE_INTELLIGENCE Error:i=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_notify_catalog_proc() GBDevice_remove:device_id=%s, stream_type=EV9000_STREAM_TYPE_INTELLIGENCE OK:i=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                }

                                i = StopAllServiceTaskByLogicDeviceIDAndStreamType(pOldGBLogicDeviceInfo->device_id, EV9000_STREAM_TYPE_INTELLIGENCE);

                                if (0 != i)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() StopAllServiceTaskByLogicDeviceIDAndStreamType ERROR:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() StopAllServiceTaskByLogicDeviceIDAndStreamType OK:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                }

                                if (INTELLIGENT_STATUS_ON == pOldGBLogicDeviceInfo->intelligent_status)
                                {
                                    pOldGBLogicDeviceInfo->intelligent_status = INTELLIGENT_STATUS_NULL;

                                    if (1 == pOldGBLogicDeviceInfo->status)
                                    {
                                        /* 发送设备状态变化消息 */
                                        i = SendDeviceStatusMessageProc(pOldGBLogicDeviceInfo, pOldGBLogicDeviceInfo->status, pDevice_Srv_dboper);

                                        if (0 != i)
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() SendDeviceStatusMessageProc ERROR:device_id=%s, status=%d, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, pOldGBLogicDeviceInfo->status, i);
                                        }
                                        else
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() SendDeviceStatusMessageProc OK:device_id=%s, status=%d, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, pOldGBLogicDeviceInfo->status, i);
                                        }

                                        /* 发送告警信息到客户端 */
                                        i = SendIntelligentDeviceOffLineAlarmToAllClientUser(pOldGBLogicDeviceInfo->device_id);

                                        if (0 != i)
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() SendIntelligentDeviceOffLineAlarmToAllClientUser Error:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                        }
                                        else
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() SendIntelligentDeviceOffLineAlarmToAllClientUser OK:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                        }
                                    }
                                }
                            }
                            else
                            {
                                if (pOldGBLogicDeviceInfo->status == 1)
                                {
                                    pOldGBLogicDeviceInfo->status = 0;

                                    /* 发送设备状态变化消息  */
                                    i = SendDeviceStatusMessageProc(pOldGBLogicDeviceInfo, pOldGBLogicDeviceInfo->status, pDevice_Srv_dboper);

                                    if (0 != i)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() SendDeviceStatusMessageProc ERROR:device_id=%s, status=%d, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, pOldGBLogicDeviceInfo->status, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() SendDeviceStatusMessageProc OK:device_id=%s, status=%d, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, pOldGBLogicDeviceInfo->status, i);
                                    }

                                    /* 发送告警信息到客户端 */
                                    i = SendDeviceOffLineAlarmToAllClientUser(pOldGBLogicDeviceInfo->device_id);

                                    if (0 != i)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() SendDeviceOffLineAlarmToAllClientUser Error:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() SendDeviceOffLineAlarmToAllClientUser OK:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                    }

                                    /* 停止呼叫任务 */
                                    if (pGBDeviceInfo->device_type == EV9000_DEVICETYPE_DECODER) /* 解码器通道根据主叫ID停止业务 */
                                    {
                                        i = StopAllServiceTaskByCallerID(pOldGBLogicDeviceInfo->device_id);

                                        if (0 != i)
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() StopAllServiceTaskByCallerID ERROR:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                        }
                                        else
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() StopAllServiceTaskByCallerID OK:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                        }
                                    }
                                    else
                                    {
                                        i = StopAllServiceTaskByLogicDeviceID(pOldGBLogicDeviceInfo->device_id);

                                        if (0 != i)
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() StopAllServiceTaskByLogicDeviceID ERROR:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                        }
                                        else
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() StopAllServiceTaskByLogicDeviceID OK:device_id=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                        }

                                        /* 停止音频对讲业务 */
                                        i = StopAudioServiceTaskByLogicDeviceID(pOldGBLogicDeviceInfo->device_id);

                                        if (0 != i)
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() StopAudioServiceTaskByLogicDeviceID Error:DeviceID=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                        }
                                        else
                                        {
                                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() StopAudioServiceTaskByLogicDeviceID OK:DeviceID=%s, iRet=%d \r\n", pOldGBLogicDeviceInfo->device_id, i);
                                        }
                                    }

                                    /* 更新数据库 */
                                    i = AddGBLogicDeviceInfo2DB(strGBLogicDeviceID, pDevice_Srv_dboper);

                                    if (i < 0)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_catalog_proc() AddGBLogicDeviceInfo2DB ERROR:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_catalog_proc() AddGBLogicDeviceInfo2DB OK:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                    }
                                }
                            }
                        }
                        else
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_notify_catalog_proc() Event Error:Event=%s \r\n", strEvent);
                        }
                    }
                }

                ItemAccNode = inPacket.SearchNextElement(true);
            }
        }
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_notify_reopen_proc
 功能描述  : DEC 设备重新连接处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月13日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_reopen_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    int iSumNum = 0;
    int iDeviceListNum = 0;
    int iItemNumCount = 0;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strSumNum[16] = {0};
    string strDeviceListNum;
    DOMElement* ItemAccNode = NULL;

    char strGBLogicDeviceID[32] = {0};
    char strCameraID[32] = {0};
    char strStreamType[32] = {0};
    char strMediaPort[32] = {0};
    int iStreamType = 0;
    int iMediaPort = 0;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_reopen_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_reopen_proc() exit---: Param Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知重新打开视频流消息:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front end device is notified to re open the video stream message:front-end device ID=%s, IP=%s, port=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

    /* <?xml version="1.0" ?>
          <Notify>
              <CmdType>ReOpen</CmdType>
              <SN>1</SN>
              <DeviceID>32011501001140000001</DeviceID>
              <SumNum>1</SumNum>
              <DeviceList Num="1" />
              <Item>
                  <DeviceID>32011501001330000001</DeviceID>
                  <DialogIndex>0</DialogIndex>
                  <CameraID></CameraID>
              </Item>
          </Notify>
     */

    /* 查看被叫是否是本CMS ID */
    if (0 != strncmp(callee_id, local_cms_id_get(), 20))
    {
        SystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知重新打开视频流消息处理失败:前端设备ID=%s, 原因=CMS ID不属于本CMS: CMS ID=%s", caller_id, callee_id);
        EnSystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "The front end device is notified to re open the video stream message processing failure: the front end device ID=%s, the cause= CMS ID does not belong to this CMS CMS ID=%s", caller_id, callee_id);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_reopen_proc() exit---: Not Belong To Mine \r\n");
        return -1;
    }

    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);
    inPacket.GetElementValue((char*)"SumNum", strSumNum);
    inPacket.GetElementAttr((char*)"DeviceList", (char*)"Num", strDeviceListNum);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_reopen_proc() \
    \r\n XML Para: \
    \r\n SN=%s \
    \r\n DeviceID=%s \
    \r\n strSumNum=%s \
    \r\n strDeviceListNum=%s \r\n ", strSN, strDeviceID, strSumNum, (char*)strDeviceListNum.c_str());

    if (strSumNum[0] == '\0')
    {
        SystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知重新打开视频流消息处理失败:前端设备ID=%, 原因=获取XML消息的总数失败", caller_id);
        EnSystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "The front-end device is notified to re open the video stream message processing failure: the front end device ID=%, the cause = total number of XML messages accessed lost", caller_id);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_reopen_proc() exit---: Get Sun Num Error \r\n");
        return -1;
    }

    if (0 != sstrcmp(caller_id, strDeviceID))
    {
        SystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知重新打开视频流消息处理失败:前端设备ID=%, 原因=XML消息的DeviceID不正确:DeviceID=%s", caller_id, strDeviceID);
        EnSystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "The front-end device notification to re open the video stream message processing failed: the front end device ID=%, the reason=XML message DeviceID is not correct:DeviceID=%s", caller_id, strDeviceID);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_reopen_proc() exit---: Caller ID Error:DeviceID=%s, caller_id=%s \r\n", strDeviceID, caller_id);
        return -1;
    }

    if (EV9000_DEVICETYPE_DECODER != pGBDeviceInfo->device_type)
    {
        SystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知设备状态消息处理失败:前端设备ID=%, 原因=物理设备类型不是解码器:DeviceType=%s", caller_id, pGBDeviceInfo->device_type);
        EnSystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "The front-end device informs the device status message handling failure: the front end device ID=%, the reason = the physical device type is not the decoder:DeviceType=%s", caller_id, pGBDeviceInfo->device_type);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_reopen_proc() exit---: GBDevice Type Is Not DEC:device_type=%d \r\n", pGBDeviceInfo->device_type);
        return -1;
    }

    /* 将设备信息写入标准逻辑设备表 */
    iSumNum = osip_atoi(strSumNum);
    iDeviceListNum = osip_atoi((char*)strDeviceListNum.c_str());
    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_notify_reopen_proc() SumNum=%d, DeviceListNum=%d \r\n", iSumNum, iDeviceListNum);

    if (iSumNum <= 0 || iDeviceListNum <= 0)
    {
        SystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知设备状态消息处理失败:前端设备ID=%, 原因=没有可操作的通道信息", caller_id);
        EnSystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "The front-end device informs the device status message handling failure: the front end device ID=%, the reason = no operable channel information", caller_id);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_reopen_proc() exit---: No Channel To ReOpen \r\n");
        return 0;
    }

    /* 获取所有的Item 数据 */
    ItemAccNode = inPacket.SearchElement((char*)"Item");

    if (!ItemAccNode)
    {
        SystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知设备状态消息处理失败:前端设备ID=%, 原因=获取操作的通道信息失败", caller_id);
        EnSystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "The front-end device informs the device status message handling failure: the front end device ID=% , the cause = access to the operation of the channel information failure", caller_id);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_reopen_proc() exit---: Get Item Node Error \r\n");
        return -1;
    }

    inPacket.SetCurrentElement(ItemAccNode);

    while (ItemAccNode)
    {
        iItemNumCount++;

        if (iItemNumCount > iDeviceListNum)
        {
            break;
        }

        memset(strGBLogicDeviceID, 0, 32);
        inPacket.GetElementValue((char*)"DeviceID", strGBLogicDeviceID);

        memset(strCameraID, 0, 32);
        inPacket.GetElementValue((char*)"CameraID", strCameraID);

        memset(strStreamType, 0, 32);
        inPacket.GetElementValue((char*)"StreamType", strStreamType);

        memset(strMediaPort, 0, 32);
        inPacket.GetElementValue((char*)"MediaPort", strMediaPort);

        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_reopen_proc() \
                    \r\n XML Item %d: \
                    \r\n DeviceID=%s \
                    \r\n CameraID=%s \
                    \r\n StreamType=%s \
                    \r\n MediaPort=%s \
                    \r\n", iItemNumCount, strGBLogicDeviceID, strCameraID, strStreamType, strMediaPort);

        /* DEC 通道编码 */
        if (strGBLogicDeviceID[0] == '\0' || (strGBLogicDeviceID[0] == '0' && strlen(strGBLogicDeviceID) == 1))
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_reopen_proc() exit---: dec_id Error: dec_id=%s \r\n", strGBLogicDeviceID);
            ItemAccNode = inPacket.SearchNextElement(true);
            continue;
        }

        /* DEC 通道解码的前端设备编码*/
        if (strCameraID[0] == '\0' || (strCameraID[0] == '0' && strlen(strCameraID) == 1))
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_reopen_proc() exit---: device_id Error: device_id=%s \r\n", strCameraID);
            ItemAccNode = inPacket.SearchNextElement(true);
            continue;
        }

        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知重新打开视墙消息:电视墙通道ID=%s, 逻辑设备ID=%s, 流类型=%s, 解码器媒体端口=%s", strGBLogicDeviceID, strCameraID, strStreamType, strMediaPort);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front end of the device is to re open the visual wall: the TV wall ID=%s, the logic device ID=%s, the flow type =%s, DEC Media Port=%s", strGBLogicDeviceID, strCameraID, strStreamType, strMediaPort);

        if (strMediaPort[0] == '\0')
        {
            iMediaPort = 0;
        }
        else
        {
            iMediaPort = osip_atoi(strMediaPort);
        }

        if (strStreamType[0] == '\0')
        {
            i = start_connect_tv_proc(strCameraID, EV9000_STREAM_TYPE_MASTER, strGBLogicDeviceID, iMediaPort);
        }
        else
        {
            iStreamType = osip_atoi(strStreamType);

            if (strStreamType <= 0)
            {
                i = start_connect_tv_proc(strCameraID, EV9000_STREAM_TYPE_MASTER, strGBLogicDeviceID, iMediaPort);
            }
            else
            {
                i = start_connect_tv_proc(strCameraID, iStreamType, strGBLogicDeviceID, iMediaPort);
            }
        }

        if (i < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_reopen_proc() start_connect_tv_proc Error:CameraID=%s, DECID=%s\r\n", strCameraID, strGBLogicDeviceID);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_reopen_proc() start_connect_tv_proc OK:CameraID=%s, DECID=%s\r\n", strCameraID, strGBLogicDeviceID);
        }

        ItemAccNode = inPacket.SearchNextElement(true);
    }

    return 0;
}

/*****************************************************************************
 函 数 名  : device_notify_RCU_status_proc
 功能描述  : 前端设备通知状态
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2016年10月12日
    作    者   : 用户路由信息清理
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_RCU_status_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strGuard[32] = {0};
    char strAlarmPriority[32] = {0};
    char strValue[256] = {0};
    char strUnit[32] = {0};
    char strStatus[32] = {0};
    int iOldGuard = 0;
    int iOldStatus = 0;
    int iOldAlarmPriority = 0;
    char strOldValue[256] = {0};
    char strOldUnit[32] = {0};
    GBLogicDevice_info_t* pGBLogicDeviceInfo = NULL;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_RCU_status_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_RCU_status_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 查看被叫是否是本CMS ID */
    if (0 != strncmp(callee_id, local_cms_id_get(), 20))
    {
        SystemLog(EV9000_CMS_NOTIFY_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "前端RCU设备通知设备状态消息处理失败:前端设备ID=%, 原因=CMS ID不属于本CMS: CMS ID=%s", caller_id, callee_id);
        EnSystemLog(EV9000_CMS_NOTIFY_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "The failure of the state message handling of the front end of the RCU device to notify the device: front end device ID=%, cause =CMS ID is not belong to this CMS: CMS ID=%s", caller_id, callee_id);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_RCU_status_proc() exit---: Not Belong To Mine:callee_id=%s \r\n", callee_id);
        return -1;
    }

    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);
    inPacket.GetElementValue((char*)"Guard", strGuard);
    inPacket.GetElementValue((char*)"AlarmPriority", strAlarmPriority);
    inPacket.GetElementValue((char*)"Value", strValue);
    inPacket.GetElementValue((char*)"Unit", strUnit);
    inPacket.GetElementValue((char*)"Status", strStatus);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_RCU_status_proc() \
		\r\n XML Para: \
		\r\n SN=%s, DeviceID=%s \r\n", strSN, strDeviceID);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端RCU设备通知设备状态消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The status message handling of the front-end RCU device notification equipment:front-end device ID=%s, IP=%s, port=%d, logic device ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);

    pGBLogicDeviceInfo = GBLogicDevice_info_find(strDeviceID);

    if (NULL == pGBLogicDeviceInfo)
    {
        SystemLog(EV9000_CMS_NOTIFY_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "前端RCU设备通知设备状态消息处理失败:前端设备ID=%s, 原因=获取逻辑设备信息失败: DeviceID=%s", caller_id, strDeviceID);
        EnSystemLog(EV9000_CMS_NOTIFY_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "The failure of the status message handling of the front-end device notification equipment: the front end device ID=%s, cause = failure of the acquisition of the logic device information: DeviceID=%s", caller_id, strDeviceID);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_RCU_status_proc() exit---: Find GBLogic Device Info Error:DeviceID=%s \r\n", strDeviceID);
        return -1;
    }

    iOldGuard = pGBLogicDeviceInfo->guard_type;
    iOldAlarmPriority = pGBLogicDeviceInfo->AlarmPriority;
    iOldStatus = pGBLogicDeviceInfo->status;
    osip_strncpy(strOldValue, pGBLogicDeviceInfo->Value, 256);
    osip_strncpy(strOldUnit, pGBLogicDeviceInfo->Unit, 32);

    /*状态*/
    if (strStatus[0] != '\0')
    {
        pGBLogicDeviceInfo->status = osip_atoi(strStatus);
    }

    /* 报警级别 */
    if (strAlarmPriority[0] != '\0')
    {
        pGBLogicDeviceInfo->AlarmPriority = osip_atoi(strAlarmPriority);
    }

    /* Guard*/
    if (strGuard[0] != '\0')
    {
        pGBLogicDeviceInfo->guard_type = osip_atoi(strGuard);
    }


    /* 单位 */
    if (strUnit[0] != '\0')
    {
        memset(pGBLogicDeviceInfo->Unit, 0, EV9000_SHORT_STRING_LEN);
        osip_strncpy(pGBLogicDeviceInfo->Unit, strUnit, 32);
    }

    /* Value */
    if (strValue[0] != '\0')
    {
        memset(pGBLogicDeviceInfo->Value, 0, EV9000_LONG_LONG_STRING_LEN);
        osip_strncpy(pGBLogicDeviceInfo->Value, strValue, 256);
    }

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_RCU_status_proc() DeviceID=%s, NewDeviceStatus=%d, NewIntelligentDeviceStatus=%d, NewAlarmDeviceStatus=%d \r\n ", strDeviceID, pGBLogicDeviceInfo->status, pGBLogicDeviceInfo->intelligent_status, pGBLogicDeviceInfo->alarm_status);

    /* 查看RCU上报信息是否有变化 */
    if (iOldStatus != pGBLogicDeviceInfo->status
        || iOldGuard != pGBLogicDeviceInfo->guard_type
        || iOldAlarmPriority != pGBLogicDeviceInfo->AlarmPriority
        || (sstrcmp(strOldUnit, pGBLogicDeviceInfo->Unit) != 0)
        || (sstrcmp(strOldValue, pGBLogicDeviceInfo->Value) != 0))
    {
        /*发送RCU设备状态消息给客户端*/
        i = SendRCUDeviceStatusToAllClientUser(pGBLogicDeviceInfo->device_id, pGBLogicDeviceInfo->status, pGBLogicDeviceInfo->AlarmPriority, pGBLogicDeviceInfo->guard_type, pGBLogicDeviceInfo->Value, pGBLogicDeviceInfo->Unit);

        if (0 != i)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_RCU_status_proc() SendRCUDeviceStatusToAllClientUser ERROR:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, pGBLogicDeviceInfo->status, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_RCU_status_proc() SendRCUDeviceStatusToAllClientUser OK:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, pGBLogicDeviceInfo->status, i);
        }

        /* 发送RCU设备状态消息给上级CMS  */
        i = SendRCUDeviceStatusToRouteCMS(pGBLogicDeviceInfo, pDevice_Srv_dboper);

        if (i < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_RCU_status_proc() SendRCUDeviceStatusToRouteCMS ERROR:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
        }
        else if (i > 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_RCU_status_proc() SendRCUDeviceStatusToRouteCMS OK:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
        }

        /* 发送RCU设备状态消息给下级CMS  */
        i = SendRCUDeviceStatusToSubCMS(pGBLogicDeviceInfo, pDevice_Srv_dboper);

        if (i < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_RCU_status_proc() SendRCUDeviceStatusToSubCMS ERROR:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
        }
        else if (i > 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_RCU_status_proc() SendRCUDeviceStatusToSubCMS OK:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
        }

        if (pGBLogicDeviceInfo->status != iOldStatus)
        {
            /* 更新数据库 */
            i = UpdateGBLogicDeviceRegStatus2DB(pGBLogicDeviceInfo->device_id, pGBLogicDeviceInfo->status, pDevice_Srv_dboper);

            if (i < 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_RCU_status_proc() UpdateGBLogicDeviceRegStatus2DB Error:device_id=%s, status=%d, i=%d \r\n", pGBLogicDeviceInfo->device_id, pGBLogicDeviceInfo->status, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_RCU_status_proc() UpdateGBLogicDeviceRegStatus2DB OK:device_id=%s, status=%d, i=%d \r\n", pGBLogicDeviceInfo->device_id, pGBLogicDeviceInfo->status, i);
            }
        }
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端RCU设备通知设备状态消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end RCU equipment inform status message processing success: ID = % s front-end equipment, IP address = % s, port = % d, logical device ID = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
    return 0;
}

/*****************************************************************************
 函 数 名  : device_notify_status_proc
 功能描述  : 前端设备通知状态
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年10月12日
    作    者   : 用户路由信息清理
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_status_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    int iRet = 0;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strStatus[32] = {0};
    int iOldDeviceStatus = 0;
    intelligent_status_t iOldIntelligentDeviceStatus = INTELLIGENT_STATUS_NULL;
    alarm_status_t iOldAlarmDeviceStatus = ALARM_STATUS_NULL;
    GBLogicDevice_info_t* pGBLogicDeviceInfo = NULL;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_status_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_status_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 查看被叫是否是本CMS ID */
    if (0 != strncmp(callee_id, local_cms_id_get(), 20))
    {
        SystemLog(EV9000_CMS_NOTIFY_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知设备状态消息处理失败:前端设备ID=%, 原因=CMS ID不属于本CMS: CMS ID=%s", caller_id, callee_id);
        EnSystemLog(EV9000_CMS_NOTIFY_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "The failure of the state message handling of the front end of the device to notify the device: front end device ID=%, cause =CMS ID is not belong to this CMS: CMS ID=%s", caller_id, callee_id);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_status_proc() exit---: Not Belong To Mine:callee_id=%s \r\n", callee_id);
        return -1;
    }

    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);
    inPacket.GetElementValue((char*)"Status", strStatus);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_status_proc() \
    \r\n XML Para: \
    \r\n SN=%s, DeviceID=%s, Status=%s \r\n", strSN, strDeviceID, strStatus);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知设备状态消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, 状态=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID, strStatus);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The status message handling of the front-end device notification equipment:front-end device ID=%s, IP=%s, port=%d, logic device ID=%s, 状态=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID, strStatus);

    pGBLogicDeviceInfo = GBLogicDevice_info_find(strDeviceID);

    if (NULL == pGBLogicDeviceInfo)
    {
        SystemLog(EV9000_CMS_NOTIFY_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知设备状态消息处理失败:前端设备ID=%s, 原因=获取逻辑设备信息失败: DeviceID=%s", caller_id, strDeviceID);
        EnSystemLog(EV9000_CMS_NOTIFY_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "The failure of the status message handling of the front-end device notification equipment: the front end device ID=%s, cause = failure of the acquisition of the logic device information: DeviceID=%s", caller_id, strDeviceID);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_status_proc() exit---: Find GBLogic Device Info Error:DeviceID=%s \r\n", strDeviceID);
        return -1;
    }

    iOldDeviceStatus = pGBLogicDeviceInfo->status;
    iOldIntelligentDeviceStatus = pGBLogicDeviceInfo->intelligent_status;
    iOldAlarmDeviceStatus = pGBLogicDeviceInfo->alarm_status;

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_status_proc() DeviceID=%s, OldDeviceStatus=%d, OldIntelligentDeviceStatus=%d, OldAlarmDeviceStatus=%d \r\n ", strDeviceID, iOldDeviceStatus, iOldIntelligentDeviceStatus, iOldAlarmDeviceStatus);

    if (0 == sstrcmp(strStatus, (char*)"ON") || sstrcmp(strStatus, (char*)"ONLINE") == 0)
    {
        pGBLogicDeviceInfo->status = 1;
    }
    else if (0 == sstrcmp(strStatus, (char*)"OFF") || sstrcmp(strStatus, (char*)"OFFLINE") == 0)
    {
        pGBLogicDeviceInfo->status = 0;
        pGBLogicDeviceInfo->intelligent_status = INTELLIGENT_STATUS_NULL;
        pGBLogicDeviceInfo->alarm_status = ALARM_STATUS_NULL;

        if (EV9000_DEVICETYPE_SCREEN != pGBLogicDeviceInfo->device_type)
        {
            //iRet = shdb_device_operate_cmd_proc(pGBLogicDeviceInfo, EV9000_SHDB_DVR_VIDEO_LOSS, pDevice_Srv_dboper);
        }
    }
    else if (sstrcmp(strStatus, (char*)"NOVIDEO") == 0)
    {
        pGBLogicDeviceInfo->status = 2;

        if (EV9000_DEVICETYPE_SCREEN != pGBLogicDeviceInfo->device_type)
        {
            //iRet = shdb_device_operate_cmd_proc(pGBLogicDeviceInfo, EV9000_SHDB_DVR_VIDEO_LOSS, pDevice_Srv_dboper);
        }
    }
    else if (sstrcmp(strStatus, (char*)"VLOST") == 0)
    {
        pGBLogicDeviceInfo->status = 2;

        if (EV9000_DEVICETYPE_SCREEN != pGBLogicDeviceInfo->device_type)
        {
            //iRet = shdb_device_operate_cmd_proc(pGBLogicDeviceInfo, EV9000_SHDB_DVR_VIDEO_LOSS, pDevice_Srv_dboper);
        }
    }
    else if (sstrcmp(strStatus, (char*)"INTELLIGENT") == 0)
    {
        pGBLogicDeviceInfo->status = 1;
        pGBLogicDeviceInfo->intelligent_status = INTELLIGENT_STATUS_ON;
    }
    else if (sstrcmp(strStatus, (char*)"CLOSE") == 0)
    {
        pGBLogicDeviceInfo->status = 1;
        pGBLogicDeviceInfo->alarm_status = ALARM_STATUS_CLOSE;
    }
    else if (sstrcmp(strStatus, (char*)"APART") == 0)
    {
        pGBLogicDeviceInfo->status = 1;
        pGBLogicDeviceInfo->alarm_status = ALARM_STATUS_APART;
    }
    else if (strStatus[0] == '\0')
    {
        if (EV9000_DEVICETYPE_ALARMINPUT == pGBLogicDeviceInfo->device_type) /* 海康NVR 报警输入通道状态返回的时候没有携带Status字段，默认在线 */
        {
            pGBLogicDeviceInfo->status = 1;
        }
    }

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_status_proc() DeviceID=%s, NewDeviceStatus=%d, NewIntelligentDeviceStatus=%d, NewAlarmDeviceStatus=%d \r\n ", strDeviceID, pGBLogicDeviceInfo->status, pGBLogicDeviceInfo->intelligent_status, pGBLogicDeviceInfo->alarm_status);

    /* 查看状态是否有变化 */
    if (pGBLogicDeviceInfo->status != iOldDeviceStatus
        || iOldIntelligentDeviceStatus != pGBLogicDeviceInfo->intelligent_status
        || iOldAlarmDeviceStatus != pGBLogicDeviceInfo->alarm_status)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "前端设备通知设备状态消息, 逻辑设备状态变化:设备ID=%s, 老状态=%d, 新状态=%d; 智能分析老状态=%d,新状态=%d; 报警老状态=%d,新状态=%d", pGBLogicDeviceInfo->device_id, iOldDeviceStatus, pGBLogicDeviceInfo->status, iOldIntelligentDeviceStatus, pGBLogicDeviceInfo->intelligent_status, iOldAlarmDeviceStatus, pGBLogicDeviceInfo->alarm_status);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "Front-end equipment inform status messages, logical device status changes:device ID=%s, old status=%d, new status=%d; the old state of intelligent analysis =%d,new status=%d; alarm old status=%d,new status=%d", pGBLogicDeviceInfo->device_id, iOldDeviceStatus, pGBLogicDeviceInfo->status, iOldIntelligentDeviceStatus, pGBLogicDeviceInfo->intelligent_status, iOldAlarmDeviceStatus, pGBLogicDeviceInfo->alarm_status);

        if (pGBLogicDeviceInfo->status != iOldDeviceStatus)
        {
            /* 更新数据库 */
            i = UpdateGBLogicDeviceRegStatus2DB(pGBLogicDeviceInfo->device_id, pGBLogicDeviceInfo->status, pDevice_Srv_dboper);

            if (i < 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() UpdateGBLogicDeviceRegStatus2DB Error:device_id=%s, status=%d, i=%d \r\n", pGBLogicDeviceInfo->device_id, pGBLogicDeviceInfo->status, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() UpdateGBLogicDeviceRegStatus2DB OK:device_id=%s, status=%d, i=%d \r\n", pGBLogicDeviceInfo->device_id, pGBLogicDeviceInfo->status, i);
            }
        }

        /* 发送设备状态消息给客户端 */
        if (1 == pGBLogicDeviceInfo->status && INTELLIGENT_STATUS_ON == pGBLogicDeviceInfo->intelligent_status)
        {
            /* 发送设备状态变化消息  */
            i = SendDeviceStatusMessageProc(pGBLogicDeviceInfo, 4, pDevice_Srv_dboper);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() SendDeviceStatusMessageProc ERROR:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() SendDeviceStatusMessageProc OK:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
            }
        }
        else if (1 == pGBLogicDeviceInfo->status && ALARM_STATUS_CLOSE == pGBLogicDeviceInfo->alarm_status)
        {
            /* 发送设备状态变化消息  */
            i = SendDeviceStatusMessageProc(pGBLogicDeviceInfo, 5, pDevice_Srv_dboper);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() SendDeviceStatusMessageProc ERROR:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() SendDeviceStatusMessageProc OK:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
            }
        }
        else if (1 == pGBLogicDeviceInfo->status && ALARM_STATUS_APART == pGBLogicDeviceInfo->alarm_status)
        {
            /* 发送设备状态变化消息  */
            i = SendDeviceStatusMessageProc(pGBLogicDeviceInfo, 6, pDevice_Srv_dboper);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() SendDeviceStatusMessageProc ERROR:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() SendDeviceStatusMessageProc OK:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
            }
        }
        else
        {
            /* 发送设备状态变化消息  */
            i = SendDeviceStatusMessageProc(pGBLogicDeviceInfo, pGBLogicDeviceInfo->status, pDevice_Srv_dboper);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() SendDeviceStatusMessageProc ERROR:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() SendDeviceStatusMessageProc OK:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
            }
        }

        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_notify_status_proc() UpdateGBLogicDeviceRegStatus2DB:device_id=%s,status=%d\r\n", pGBLogicDeviceInfo->device_id, pGBLogicDeviceInfo->status);
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "前端设备通知设备状态消息:逻辑设备ID=%s, 老状态=%d, 新状态=%d", pGBLogicDeviceInfo->device_id, iOldDeviceStatus, pGBLogicDeviceInfo->status);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "The device status message handling of the front-end device notification:logic device ID=%s, old state=%d, new state=%d", pGBLogicDeviceInfo->device_id, iOldDeviceStatus, pGBLogicDeviceInfo->status);
    }

    if (iOldDeviceStatus == 1 && (pGBLogicDeviceInfo->status == 0 || pGBLogicDeviceInfo->status == 2))
    {
        if (iOldDeviceStatus == 1 && pGBLogicDeviceInfo->status == 0)
        {
            /* 发送告警信息到客户端 */
            i = SendDeviceOffLineAlarmToAllClientUser(pGBLogicDeviceInfo->device_id);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() SendDeviceOffLineAlarmToAllClientUser Error:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() SendDeviceOffLineAlarmToAllClientUser OK:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
            }
        }
        else if (iOldDeviceStatus == 1 && pGBLogicDeviceInfo->status == 2)
        {
            /* 发送告警信息到客户端 */
            i = SendDeviceNoStreamAlarmToAllClientUser(pGBLogicDeviceInfo->device_id);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() SendDeviceNoStreamAlarmToAllClientUser Error:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() SendDeviceNoStreamAlarmToAllClientUser OK:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
            }
        }

        if (pGBDeviceInfo->device_type == EV9000_DEVICETYPE_DECODER) /* 解码器通道根据主叫ID停止业务 */
        {
            i = StopAllServiceTaskByCallerID(pGBLogicDeviceInfo->device_id);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() StopAllServiceTaskByCallerID Error:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() StopAllServiceTaskByCallerID OK:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
            }
        }
        else if (EV9000_DEVICETYPE_INTELLIGENTANALYSIS == pGBDeviceInfo->device_type)
        {
            i = StopAllServiceTaskByLogicDeviceIDAndStreamType(pGBLogicDeviceInfo->device_id, EV9000_STREAM_TYPE_INTELLIGENCE);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() StopAllServiceTaskByLogicDeviceIDAndStreamType Error:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() StopAllServiceTaskByLogicDeviceIDAndStreamType OK:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
            }
        }
        else
        {
            i = StopAllServiceTaskByLogicDeviceID(pGBLogicDeviceInfo->device_id);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() StopAllServiceTaskByLogicDeviceID Error:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() StopAllServiceTaskByLogicDeviceID OK:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
            }

            /* 停止音频对讲业务 */
            i = StopAudioServiceTaskByLogicDeviceID(pGBLogicDeviceInfo->device_id);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() StopAudioServiceTaskByLogicDeviceID Error:DeviceID=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() StopAudioServiceTaskByLogicDeviceID OK:DeviceID=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
            }
        }
    }
    else if (INTELLIGENT_STATUS_ON == iOldIntelligentDeviceStatus && INTELLIGENT_STATUS_NULL == pGBLogicDeviceInfo->intelligent_status)
    {
        /* 发送告警信息到客户端 */
        i = SendIntelligentDeviceOffLineAlarmToAllClientUser(pGBLogicDeviceInfo->device_id);

        if (0 != i)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() SendIntelligentDeviceOffLineAlarmToAllClientUser Error:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() SendIntelligentDeviceOffLineAlarmToAllClientUser OK:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
        }

        i = StopAllServiceTaskByLogicDeviceIDAndStreamType(pGBLogicDeviceInfo->device_id, EV9000_STREAM_TYPE_INTELLIGENCE);

        if (0 != i)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() StopAllServiceTaskByLogicDeviceIDAndStreamType Error:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() StopAllServiceTaskByLogicDeviceIDAndStreamType OK:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
        }
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知设备状态消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment inform status message processing success: ID = % s front-end equipment, IP address = % s, port = % d, logical device ID = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
    return 0;
}

/*****************************************************************************
 函 数 名  : device_notify_cms_restart_proc
 功能描述  : 下级CMS通知下级CMS重启了
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年7月6日 星期日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_cms_restart_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket)
{
    int iRet = 0;
    char strSN[32] = {0};
    char strCMSID[32] = {0};

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_cms_restart_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_cms_restart_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 取得 数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"CMSID", strCMSID);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_cms_restart_proc() \
    \r\n XML Para: \
    \r\n SN=%s \
    \r\n CMSID=%s \r\n", strSN, strCMSID);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知重启消息:前端设备ID=%s, IP地址=%s, 端口号=%d, CMSID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strCMSID);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment inform restart news: ID = % s front-end equipment, IP address = % s, port = % d, CMSID = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strCMSID);

    if (EV9000_DEVICETYPE_SIPSERVER != pGBDeviceInfo->device_type)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_cms_restart_proc() exit---: GBDeviceI type Error:device_type=%d \r\n", pGBDeviceInfo->device_type);
        return -1;
    }

    iRet = StopAllServiceTaskByCalleeIPAndPort(pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

    if (0 != iRet)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_cms_restart_proc() StopAllServiceTaskByCalleeIPAndPort Error:device_id=%s, device_ip=%s, device_port=%d, iRet=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, iRet);
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_cms_restart_proc() StopAllServiceTaskByCalleeIPAndPort OK:device_id=%s, device_ip=%s, device_port=%d, iRet=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, iRet);
    }

#if 0
    /* 发送点位推送消息到下级CMS */
    iRet = SendNotifyCatalogMessageToSubCMS(pGBDeviceInfo->device_id);

    if (0 != iRet)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "route_notify_cms_restart_proc() SendNotifyCatalogMessageToSubCMS Error:device_id=%s, device_ip=%s, device_port=%d, iRet=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, iRet);
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "route_notify_cms_restart_proc() SendNotifyCatalogMessageToSubCMS OK:device_id=%s, device_ip=%s, device_port=%d, iRet=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, iRet);
    }

#endif

    return iRet;
}

/*****************************************************************************
 函 数 名  : device_notify_diagnosis_proc
 功能描述  : 智能诊断结果上报通知命令处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年9月12日 星期五
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_diagnosis_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    int iRet = 0;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strVideoChlCode[32] = {0};
    char strDiagnosisTime[32] = {0};
    char strImageFile[256] = {0};
    char strVideoLost[32] = {0};
    char strVideoOcclusion[32] = {0};
    char strVideoFrozen[32] = {0};
    char strVideoLum[32] = {0};
    char strVideoShake[32] = {0};
    char strVideoSnow[32] = {0};
    char strVideoBlur[32] = {0};
    char strVideoHue[32] = {0};
    char strVideoNightMode[32] = {0};
    char strVideoLumLow[32] = {0};
    char strVideoContrastLow[32] = {0};
    char strVideoUpheaval[32] = {0};
    char strVideoMosaic[32] = {0};
    char strVideoStripe[32] = {0};
    char strVideoPTZ[32] = {0};
    char strVideoSceneChange[32] = {0};
    char strVideoNetWork[32] = {0};
    char strVideoLogIn[32] = {0};
    char strVideoNoStream[32] = {0};

    diagnosis_msg_t* pDiagnosisMsg = NULL;

    CPacket outPacket;
    DOMElement* AccNode = NULL;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_diagnosis_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_diagnosis_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 智能诊断结果上报

          命令包括如下字段:
          <!--命令类型：诊断通知（固定必选）-->
            <element name="CmdType" fixed="DiagnosisNotice"/>
            <!--命令序列号（必选） -->
            <element name="SN"type="integer"minlnelusive value="1" />
            <!--诊断设备编码 （20位必选）-->
            <element name="DeviceCode" type="string"/>
            <!--视频通道编号（20位必选） -->
            <element name="VideoChlCode" type="string"/>
            <!--诊断时间（必选） -->
            <element name=" DiagnosisTime" type="dateTime"/>
            <!--抓图存放名称（必选） -->
            <element name="ImageFile" type="string"/>
            <!--视频丢失（必选） -->
            <element name="VideoLost" type="integer"/>
            <!--镜头遮挡（必选） -->
            <element name="VideoOcclusion" type="integer"/>
            <!--画面冻结（必选） -->
            <element name="VideoFrozen" type="integer"/>
            <!--亮度异常（必选） -->
            <element name="VideoLum" type="integer"/>
            <!--镜头抖动（必选） -->
            <element name="VideoShake" type="integer"/>
            <!--雪花噪声（必选） -->
            <element name="VideoSnow" type="integer"/>
            <!--镜头模糊（必选） -->
            <element name="VideoBlur" type="integer"/>
            <!--画面偏色（必选） -->
            <element name="VideoHue" type="integer"/>
            <!--黑白图像（必选） -->
            <element name="VideoNightMode" type="integer"/>
            <!--图像过暗（必选） -->
            <element name="VideoLumLow" type="integer"/>
            <!--低对比度（必选） -->
            <element name="VideoContrastLow" type="integer"/>
            <!--视频剧变（必选） -->
            <element name="VideoUpheaval" type="integer"/>
            <!--马赛克（必选） -->
            <element name="VideoMosaic" type="integer"/>
            <!--条纹干扰（必选） -->
            <element name="VideoStripe" type="integer"/>
            <!--PTZ异常（必选） -->
            <element name="VideoPTZ" type="integer"/>
            <!--场景变更（必选） -->
            <element name="VideoSceneChange" type="integer"/>
            <!--网络异常（必选） -->
            <element name="VideoNetWork" type="integer"/>
            <!--登录失败（必选） -->
            <element name="VideoLogIn" type="integer"/>
            <!--取流失败（必选） -->
            <element name="VideoNoStream" type="integer"/>
      */

    /* 取得报警数据 */
    inPacket.GetElementValue((char*)"SN", strSN);                             /* 命令序列号 */
    inPacket.GetElementValue((char*)"DeviceCode", strDeviceID);               /* 设备编码 */
    inPacket.GetElementValue((char*)"VideoChlCode", strVideoChlCode);         /* 视频通道编号 */
    inPacket.GetElementValue((char*)"DiagnosisTime", strDiagnosisTime);       /* 诊断时间 */
    inPacket.GetElementValue((char*)"ImageFile", strImageFile);               /* 抓图存放名称 */
    inPacket.GetElementValue((char*)"VideoLost", strVideoLost);               /* 视频丢失 */
    inPacket.GetElementValue((char*)"VideoOcclusion", strVideoOcclusion);     /* 镜头遮挡 */
    inPacket.GetElementValue((char*)"VideoFrozen", strVideoFrozen);           /* 画面冻结 */
    inPacket.GetElementValue((char*)"VideoLum", strVideoLum);                 /* 亮度异常 */
    inPacket.GetElementValue((char*)"VideoShake", strVideoShake);             /* 镜头抖动 */
    inPacket.GetElementValue((char*)"VideoSnow", strVideoSnow);               /* 雪花噪声 */
    inPacket.GetElementValue((char*)"VideoBlur", strVideoBlur);               /* 镜头模糊 */
    inPacket.GetElementValue((char*)"VideoHue", strVideoHue);                 /* 画面偏色 */
    inPacket.GetElementValue((char*)"VideoNightMode", strVideoNightMode);     /* 黑白图像 */
    inPacket.GetElementValue((char*)"VideoLumLow", strVideoLumLow);           /* 图像过暗 */
    inPacket.GetElementValue((char*)"VideoContrastLow", strVideoContrastLow); /* 低对比度 */
    inPacket.GetElementValue((char*)"VideoUpheaval", strVideoUpheaval);       /* 视频剧变 */
    inPacket.GetElementValue((char*)"VideoMosaic", strVideoMosaic);           /* 马赛克 */
    inPacket.GetElementValue((char*)"VideoStripe", strVideoStripe);           /* 条纹干扰 */
    inPacket.GetElementValue((char*)"VideoPTZ", strVideoPTZ);                 /* PTZ异常 */
    inPacket.GetElementValue((char*)"VideoSceneChange", strVideoSceneChange); /* 场景变更 */
    inPacket.GetElementValue((char*)"VideoNetWork", strVideoNetWork);         /* 网络异常 */
    inPacket.GetElementValue((char*)"VideoLogIn", strVideoLogIn);             /* 登录失败 */
    inPacket.GetElementValue((char*)"VideoNoStream", strVideoNoStream);       /* 取流失败 */

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_diagnosis_proc() \
    \r\n XML Para: \
    \r\n SN=%s \
    \r\n DeviceID=%s \
    \r\n VideoChlCode=%s \
    \r\n DiagnosisTime=%s \
    \r\n ImageFile=%s \r\n", strSN, strDeviceID, strVideoChlCode, strDiagnosisTime, strImageFile);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_diagnosis_proc() \
    \r\n XML Para: \
    \r\n VideoLost=%s \
    \r\n VideoOcclusion=%s \
    \r\n VideoFrozen=%s \
    \r\n VideoLum=%s \
    \r\n VideoShake=%s \
    \r\n VideoSnow=%s \
    \r\n VideoBlur=%s \
    \r\n VideoHue=%s \r\n", strVideoLost, strVideoOcclusion, strVideoFrozen, strVideoLum, strVideoShake, strVideoSnow, strVideoBlur, strVideoHue);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_diagnosis_proc() \
    \r\n XML Para: \
    \r\n VideoNightMode=%s \
    \r\n VideoLumLow=%s \
    \r\n VideoContrastLow=%s \
    \r\n VideoUpheaval=%s \
    \r\n VideoMosaic=%s \
    \r\n VideoStripe=%s \
    \r\n VideoPTZ=%s \
    \r\n VideoSceneChange=%s \
    \r\n VideoNetWork=%s \
    \r\n VideoLogIn=%s \
    \r\n VideoNoStream=%s \r\n", strVideoNightMode, strVideoLumLow, strVideoContrastLow, strVideoUpheaval, strVideoMosaic, strVideoStripe, strVideoPTZ, strVideoSceneChange, strVideoNetWork, strVideoLogIn, strVideoNoStream);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知诊断消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 序列号=%s, 视频通道编号=%s, 诊断时间=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strSN, strVideoChlCode, strDiagnosisTime);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment inform diagnostic messages: ID = % s front-end equipment, IP address = % s, port = % d, serial number = % s, video channel number = % s, diagnosis time = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strSN, strVideoChlCode, strDiagnosisTime);

    /* 添加到诊断结果上报消息队列 */
    iRet = diagnosis_msg_init(&pDiagnosisMsg);

    if (iRet != 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_diagnosis_proc() exit---: Diagnosis Message Init Error \r\n");
        return -1;
    }

    if ('\0' != strSN[0])
    {
        osip_strncpy(pDiagnosisMsg->strSN, strSN, 32);
    }

    if ('\0' != strDeviceID[0])
    {
        osip_strncpy(pDiagnosisMsg->strDeviceID, strDeviceID, MAX_ID_LEN);
    }

    if ('\0' != pGBDeviceInfo->login_ip[0])
    {
        osip_strncpy(pDiagnosisMsg->strDeviceIP, pGBDeviceInfo->login_ip, MAX_IP_LEN);
    }

    if ('\0' != strVideoChlCode[0])
    {
        osip_strncpy(pDiagnosisMsg->strChannelID, strVideoChlCode, MAX_ID_LEN);
    }

    if ('\0' != strDiagnosisTime[0])
    {
        osip_strncpy(pDiagnosisMsg->strDiagnosisTime, strDiagnosisTime, 32);
    }

    if ('\0' != strImageFile[0])
    {
        osip_strncpy(pDiagnosisMsg->strImageFile, strImageFile, 256);
    }

    /* 视频丢失 */
    if ('\0' != strVideoLost[0])
    {
        osip_strncpy(pDiagnosisMsg->strVideoLost, strVideoLost, 32);
    }

    /* 镜头遮挡 */
    if ('\0' != strVideoOcclusion[0])
    {
        osip_strncpy(pDiagnosisMsg->strVideoOcclusion, strVideoOcclusion, 32);
    }

    /* 画面冻结 */
    if ('\0' != strVideoFrozen[0])
    {
        osip_strncpy(pDiagnosisMsg->strVideoFrozen, strVideoFrozen, 32);
    }

    /* 亮度异常 */
    if ('\0' != strVideoLum[0])
    {
        osip_strncpy(pDiagnosisMsg->strVideoLum, strVideoLum, 32);
    }

    /* 镜头抖动 */
    if ('\0' != strVideoShake[0])
    {
        osip_strncpy(pDiagnosisMsg->strVideoShake, strVideoShake, 32);
    }

    /* 雪花噪声 */
    if ('\0' != strVideoSnow[0])
    {
        osip_strncpy(pDiagnosisMsg->strVideoSnow, strVideoSnow, 32);
    }

    /* 镜头模糊 */
    if ('\0' != strVideoBlur[0])
    {
        osip_strncpy(pDiagnosisMsg->strVideoBlur, strVideoBlur, 32);
    }

    /* 画面偏色 */
    if ('\0' != strVideoHue[0])
    {
        osip_strncpy(pDiagnosisMsg->strVideoHue, strVideoHue, 32);
    }

    /* 黑白图像 */
    if ('\0' != strVideoNightMode[0])
    {
        osip_strncpy(pDiagnosisMsg->strVideoNightMode, strVideoNightMode, 32);
    }

    /* 图像过暗 */
    if ('\0' != strVideoLumLow[0])
    {
        osip_strncpy(pDiagnosisMsg->strVideoLumLow, strVideoLumLow, 32);
    }

    /* 低对比度 */
    if ('\0' != strVideoContrastLow[0])
    {
        osip_strncpy(pDiagnosisMsg->strVideoContrastLow, strVideoContrastLow, 32);
    }

    /* 视频剧变 */
    if ('\0' != strVideoUpheaval[0])
    {
        osip_strncpy(pDiagnosisMsg->strVideoUpheaval, strVideoUpheaval, 32);
    }

    /* 马赛克 */
    if ('\0' != strVideoMosaic[0])
    {
        osip_strncpy(pDiagnosisMsg->strVideoMosaic, strVideoMosaic, 32);
    }

    /* 条纹干扰 */
    if ('\0' != strVideoStripe[0])
    {
        osip_strncpy(pDiagnosisMsg->strVideoStripe, strVideoStripe, 32);
    }

    /* PTZ异常 */
    if ('\0' != strVideoPTZ[0])
    {
        osip_strncpy(pDiagnosisMsg->strVideoPTZ, strVideoPTZ, 32);
    }

    /* 场景变更 */
    if ('\0' != strVideoSceneChange[0])
    {
        osip_strncpy(pDiagnosisMsg->strVideoSceneChange, strVideoSceneChange, 32);
    }

    /* 网络异常 */
    if ('\0' != strVideoNetWork[0])
    {
        osip_strncpy(pDiagnosisMsg->strVideoNetWork, strVideoNetWork, 32);
    }

    /* 登录失败 */
    if ('\0' != strVideoLogIn[0])
    {
        osip_strncpy(pDiagnosisMsg->strVideoLogIn, strVideoLogIn, 32);
    }

    /* 取流失败 */
    if ('\0' != strVideoNoStream[0])
    {
        osip_strncpy(pDiagnosisMsg->strVideoNoStream, strVideoNoStream, 32);
    }

    i = diagnosis_msg_add(pDiagnosisMsg);

    if (0 != i)
    {
        diagnosis_msg_free(pDiagnosisMsg);
        osip_free(pDiagnosisMsg);
        pDiagnosisMsg = NULL;
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_diagnosis_proc() diagnosis_msg_add Error:i=%d \r\n", i);
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_diagnosis_proc() diagnosis_msg_add OK:i=%d \r\n", i);
    }

    /* 回复响应 */
    outPacket.SetRootTag("Response");
    AccNode = outPacket.CreateElement((char*)"CmdType");
    outPacket.SetElementValue(AccNode, (char*)"DiagnosisNotice");
    AccNode = outPacket.CreateElement((char*)"SN");
    outPacket.SetElementValue(AccNode, strSN);
    AccNode = outPacket.CreateElement((char*)"DeviceID");
    outPacket.SetElementValue(AccNode, strDeviceID);
    AccNode = outPacket.CreateElement((char*)"Result");
    outPacket.SetElementValue(AccNode, (char*)"OK");

    i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pGBDeviceInfo->strRegServerIP, pGBDeviceInfo->iRegServerPort, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

    if (i != 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_diagnosis_proc() SIP_SendMessage Error:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_diagnosis_proc() SIP_SendMessage OK:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_notify_target_tount_proc
 功能描述  : 智能分析，目标计数结果上报通知命令处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2015年11月9日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_target_tount_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    int iRet = 0;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strVideoChlCode[32] = {0};
    char strAreaIndex[32] = {0};
    char strAreaName[32] = {0};
    char strTargetCountTime[32] = {0};
    char strEnterPeople[32] = {0};
    char strEnterCar[32] = {0};
    char strLeavePeople[32] = {0};
    char strLeaveCar[32] = {0};

    analysis_target_count_msg_t* pAnalysisTargetCountMsg = NULL;

    CPacket outPacket;
    DOMElement* AccNode = NULL;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_target_tount_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_target_tount_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 智能诊断结果上报

          命令包括如下字段:
            <!--命令类型：诊断通知（固定必选）-->
            <element name="CmdType" fixed="TargetCount"/>
            <!--命令序列号（必选） -->
            <element name="SN"type="integer"minlnelusive value="1" />
            <!--诊断设备编码 （20位必选）-->
            <element name="DeviceCode" type="string"/>
            <!--视频通道编号（20位必选） -->
            <element name="DeviceIndex" type="string"/>
            <!--分析区域  最多8个区域  1~8 -->
            <element name=" AreaIndex" type="interger"/>
            <!--分析区域名称 -->
            <element name=" AreaName" type="string"/>
            <!--当前时间（必选） -->
            <element name=" TargetCountTime" type="dateTime"/>
            <!--进入分析区域人数（必选） -->
            <element name="EnterPeople" type="integer"/>
            <!-- 进入分析区域车辆数（必选） -->
            <element name="EnterCar" type="integer"/>
            <!-- 离开分析区域人数（必选） -->
            <element name="LeavePeople" type="integer"/>
            <!-- 离开分析区域车辆数（必选） -->
            <element name="LeaveCar" type="integer"/>
      */

    /* 取得报警数据 */
    inPacket.GetElementValue((char*)"SN", strSN);                             /* 命令序列号 */
    inPacket.GetElementValue((char*)"DeviceCode", strDeviceID);               /* 诊断设备编码 */
    inPacket.GetElementValue((char*)"DeviceIndex", strVideoChlCode);          /* 视频通道编号 */
    inPacket.GetElementValue((char*)"AreaIndex", strAreaIndex);               /* 分析区域 */
    inPacket.GetElementValue((char*)"AreaName", strAreaName);                 /* 分析区域名称 */
    inPacket.GetElementValue((char*)"TargetCountTime", strTargetCountTime);   /* 当前时间（必选） */
    inPacket.GetElementValue((char*)"EnterPeople", strEnterPeople);           /* 进入分析区域人数（必选） */
    inPacket.GetElementValue((char*)"EnterCar", strEnterCar);                 /* 进入分析区域车辆数（必选） */
    inPacket.GetElementValue((char*)"LeavePeople", strLeavePeople);           /* 离开分析区域人数（必选） */
    inPacket.GetElementValue((char*)"LeaveCar", strLeaveCar);                 /* 离开分析区域车辆数（必选） */

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_target_tount_proc() \
    \r\n XML Para: \
    \r\n SN=%s \
    \r\n DeviceID=%s \
    \r\n VideoChlCode=%s \
    \r\n AreaIndex=%s \
    \r\n AreaName=%s \
    \r\n TargetCountTime=%s \r\n", strSN, strDeviceID, strVideoChlCode, strAreaIndex, strAreaName, strTargetCountTime);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_target_tount_proc() \
    \r\n XML Para: \
    \r\n EnterPeople=%s \
    \r\n EnterCar=%s \
    \r\n LeavePeople=%s \
    \r\n LeaveCar=%s \r\n", strEnterPeople, strEnterCar, strLeavePeople, strLeaveCar);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知智能分析，目标计数结果消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 序列号=%s, 视频通道编号=%s, 诊断时间=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strSN, strVideoChlCode, strTargetCountTime);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment notice intelligence analysis, target counting result message: ID = % s front-end equipment, IP address = % s, port = % d, serial number = % s, video channel number = % s, diagnosis time = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strSN, strVideoChlCode, strTargetCountTime);

    /* 添加到结果上报消息队列 */
    iRet = analysis_target_count_msg_init(&pAnalysisTargetCountMsg);

    if (iRet != 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_target_tount_proc() exit---: Diagnosis Message Init Error \r\n");
        return -1;
    }

    if ('\0' != strSN[0])
    {
        osip_strncpy(pAnalysisTargetCountMsg->strSN, strSN, 32);
    }

    /* 诊断设备编码 */
    if ('\0' != strDeviceID[0])
    {
        osip_strncpy(pAnalysisTargetCountMsg->strDeviceID, strDeviceID, MAX_ID_LEN);
    }

    /* 视频通道编号（20位必选） */
    if ('\0' != strVideoChlCode[0])
    {
        osip_strncpy(pAnalysisTargetCountMsg->strChannelID, strVideoChlCode, MAX_ID_LEN);
    }

    /* 分析区域 */
    if ('\0' != strAreaIndex[0])
    {
        osip_strncpy(pAnalysisTargetCountMsg->strAreaIndex, strAreaIndex, 32);
    }

    /* 分析区域名称 */
    if ('\0' != strAreaName[0])
    {
        osip_strncpy(pAnalysisTargetCountMsg->strAreaName, strAreaName, 32);
    }

    /* 当前时间（必选） */
    if ('\0' != strTargetCountTime[0])
    {
        osip_strncpy(pAnalysisTargetCountMsg->strTargetCountTime, strTargetCountTime, 32);
    }

    /* 进入分析区域人数（必选） */
    if ('\0' != strEnterPeople[0])
    {
        osip_strncpy(pAnalysisTargetCountMsg->strEnterPeople, strEnterPeople, 32);
    }

    /* 进入分析区域车辆数（必选） */
    if ('\0' != strEnterCar[0])
    {
        osip_strncpy(pAnalysisTargetCountMsg->strEnterCar, strEnterCar, 32);
    }

    /* 离开分析区域人数（必选） */
    if ('\0' != strLeavePeople[0])
    {
        osip_strncpy(pAnalysisTargetCountMsg->strLeavePeople, strLeavePeople, 32);
    }

    /* 离开分析区域车辆数（必选） */
    if ('\0' != strLeaveCar[0])
    {
        osip_strncpy(pAnalysisTargetCountMsg->strLeaveCar, strLeaveCar, 32);
    }

    i = analysis_target_count_msg_add(pAnalysisTargetCountMsg);

    if (0 != i)
    {
        analysis_target_count_msg_free(pAnalysisTargetCountMsg);
        osip_free(pAnalysisTargetCountMsg);
        pAnalysisTargetCountMsg = NULL;
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_target_tount_proc() analysis_target_count_msg_add Error:i=%d \r\n", i);
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_target_tount_proc() analysis_target_count_msg_add OK:i=%d \r\n", i);
    }

    /* 回复响应 */
    outPacket.SetRootTag("Response");
    AccNode = outPacket.CreateElement((char*)"CmdType");
    outPacket.SetElementValue(AccNode, (char*)"TargetCount");
    AccNode = outPacket.CreateElement((char*)"SN");
    outPacket.SetElementValue(AccNode, strSN);
    AccNode = outPacket.CreateElement((char*)"DeviceID");
    outPacket.SetElementValue(AccNode, strDeviceID);
    AccNode = outPacket.CreateElement((char*)"Result");
    outPacket.SetElementValue(AccNode, (char*)"OK");

    i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pGBDeviceInfo->strRegServerIP, pGBDeviceInfo->iRegServerPort, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

    if (i != 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_target_tount_proc() SIP_SendMessage Error:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_target_tount_proc() SIP_SendMessage OK:device_id=%s, device_ip=%s, device_port=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_notify_topology_phydevice_config_proc
 功能描述  : 拓扑表变化通知消息处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年11月28日 星期五
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_topology_phydevice_config_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strEvent[32] = {0};
    char strDeviceName[128] = {0};
    char strDeviceType[64] = {0};
    char strDeviceIP[64] = {0};
    char strStatus[64] = {0};
    char strCMSID[64] = {0};
    char strLinkType[64] = {0};

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_topology_phydevice_config_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_topology_phydevice_config_proc() exit---: Param Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备拓扑物理设备配置信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment topology physical device configuration information query response message: ID = % s front-end equipment, IP address = % s, port = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

    /* 查看被叫是否是本CMS ID */
    if (0 == strncmp(callee_id, local_cms_id_get(), 20))
    {
        /* 逻辑设备分组信息 是下级CMS 注册成功之后上级CMS主动发起的查询 */
        /* 取得数据*/

        /* SN */
        memset(strSN, 0, 32);
        inPacket.GetElementValue((char*)"SN", strSN);

        /* 设备ID */
        memset(strDeviceID, 0, 32);
        inPacket.GetElementValue((char*)"DeviceID", strDeviceID);

        /* 事件 */
        memset(strEvent, 0, 32);
        inPacket.GetElementValue((char*)"Event", strEvent);

        /* 设备名称 */
        memset(strDeviceName, 0, 128);
        inPacket.GetElementValue((char*)"DeviceName", strDeviceName);

        /* 设备类型 */
        memset(strDeviceType, 0, 64);
        inPacket.GetElementValue((char*)"DeviceType", strDeviceType);

        /* 设备IP */
        memset(strDeviceIP, 0, 64);
        inPacket.GetElementValue((char*)"DeviceIP", strDeviceIP);

        /* 设备状态 */
        memset(strStatus, 0, 64);
        inPacket.GetElementValue((char*)"Status", strStatus);

        if (osip_atoi(strDeviceType) == EV9000_DEVICETYPE_SIPSERVER) /* 如果是CMS单板设备 */
        {
            /* 查看是否属于本CMS直属下级设备 */
            if (0 == sstrcmp(strDeviceID, pGBDeviceInfo->device_id))
            {
                memset(strCMSID, 0, 64);
                memset(strLinkType, 0, 64);

                snprintf(strCMSID, 64, "%s", local_cms_id_get());

                if (1 == pGBDeviceInfo->link_type) /* 同级的写1 */
                {
                    snprintf(strLinkType, 64, "%d", 1);
                }
                else
                {
                    snprintf(strLinkType, 64, "%d", 0);
                }
            }
            else
            {
                /* 所属 CMS 编号 */
                memset(strCMSID, 0, 64);
                inPacket.GetElementValue((char*)"CMSID", strCMSID);

                /* 是否同级 */
                memset(strLinkType, 0, 64);
                inPacket.GetElementValue((char*)"LinkType", strLinkType);
            }
        }
        else
        {
            /* 所属 CMS 编号 */
            memset(strCMSID, 0, 64);
            inPacket.GetElementValue((char*)"CMSID", strCMSID);

            /* 是否同级 */
            memset(strLinkType, 0, 64);
            inPacket.GetElementValue((char*)"LinkType", strLinkType);
        }

        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_topology_phydevice_config_proc() \
        \r\n XML Para: \
        \r\n SN=%s \
        \r\n DeviceID=%s \
        \r\n Event=%s,CMSID=%s,LinkType=%s \r\n ", strSN, strDeviceID, strEvent, strCMSID, strLinkType);

        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备拓扑物理设备配置信息变化消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 设备ID=%s, 设备名称=%s, CMSID=%s, LinkType=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID, strDeviceName, strCMSID, strLinkType);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment topology change physical device configuration information news: ID = % s front-end equipment, = % s IP address, port number = % d, device ID = % s, equipment, IP = % s CMSID = % s, LinkType = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID, strDeviceName, strCMSID, strLinkType);

        if (0 == sstrcmp(strEvent, (char*)"ADD")
            || 0 == sstrcmp(strEvent, (char*)"MOD"))
        {
            /* 写入或者更新数据库 */
            i = AddTopologyPhyDeviceInfo2DB(strDeviceID, strDeviceName, strDeviceType, strDeviceIP, strStatus, strCMSID, strLinkType, pDevice_Srv_dboper);

            if (i < 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_topology_phydevice_config_proc() AddTopologyPhyDeviceInfo2DB ERROR:device_id=%s, iRet=%d \r\n", strDeviceID, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_topology_phydevice_config_proc() AddTopologyPhyDeviceInfo2DB OK:device_id=%s, iRet=%d \r\n", strDeviceID, i);
            }
        }
        else if (0 == sstrcmp(strEvent, (char*)"DEL"))
        {
            i = DeleteTopologyPhyDeviceInfoFromDB(strDeviceID, pDevice_Srv_dboper);

            if (i < 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_topology_phydevice_config_proc() DeleteTopologyPhyDeviceInfoFromDB ERROR:device_id=%s, iRet=%d \r\n", strDeviceID, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_topology_phydevice_config_proc() DeleteTopologyPhyDeviceInfoFromDB OK:device_id=%s, iRet=%d \r\n", strDeviceID, i);
            }
        }
        else if (0 == sstrcmp(strEvent, (char*)"STATUS"))
        {
            i = UpdateTopologyPhyDeviceStatus2DB(strDeviceID, strStatus, pDevice_Srv_dboper);

            if (i < 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_topology_phydevice_config_proc() UpdateTopologyPhyDeviceStatus2DB ERROR:device_id=%s, iRet=%d \r\n", strDeviceID, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_topology_phydevice_config_proc() UpdateTopologyPhyDeviceStatus2DB OK:device_id=%s, iRet=%d \r\n", strDeviceID, i);
            }
        }

        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备拓扑物理设备配置信息变化消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment topology physical device configuration information change message processing success: ID = % s front-end equipment, IP address = % s, port = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    }
    else /* 转发出去 */
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备拓扑物理设备配置信息变化消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=CMS ID不属于本CMS: CMS ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "Front-end equipment topology change physical device configuration information message processing failure: ID = % s front-end equipment, IP address = % s, port = % d, reason = CMS ID does not belong to the CMS: CMS ID = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_notify_topology_phydevice_config_proc() exit---: Not Belong To Mine \r\n");
        return -1;
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_notify_channel_status_proc
 功能描述  : 解码器通道状态通知消息
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年5月5日 星期一
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_channel_status_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    char strSN[32] = {0};
    char strChannelID[32] = {0};

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_channel_status_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_channel_status_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"ChannelID", strChannelID);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_channel_status_proc() \
    \r\n XML Para: SN=%s, ChannelID=%s \r\n", strSN, strChannelID);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知通道状态消息:前端设备ID=%s, IP地址=%s, 端口号=%d, ChannelID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strChannelID);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment channel status response message: ID = % s front-end equipment, IP address = % s, port = % d, ChannelID = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strChannelID);

    /* 解码器通道状态消息直接转发给客户端，不作处理
      */

    if (0 == strncmp(callee_id, local_cms_id_get(), 20)) /* 查看被叫是否是本CMS ID */
    {
        i = SendMessageToOnlineUserForTVWallStatus((char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length());

        if (i < 0)
        {
            SystemLog(EV9000_CMS_QUERY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知通道状态消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=转发给在线用户失败", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            EnSystemLog(EV9000_CMS_QUERY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device notify channel status message process failed:front-end device ID=%s, cause=forward to online user failed", caller_id);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_channel_status_proc() SendMessageToOnlineUserForTVWallStatus Error: caller_id=%s \r\n", caller_id);
        }
        else if (i > 0)
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知通道状态消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 转发给在线用户", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment channel status response message processing success: the front-end device ID = % s, = % s IP address, port number = % d, forwarded to online users", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_channel_status_proc() SendMessageToOnlineUserForTVWallStatus OK: caller_id=%s \r\n", caller_id);
        }

        return i;
    }
    else /* 转发出去 */
    {
        if (IsMyUser(callee_id))
        {
            /* 发送给本级在线用户 */
            i = SendMessageToOnlineUserByUserIDForTVWallStatus(callee_id, (char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length());

            if (i < 0)
            {
                SystemLog(EV9000_CMS_QUERY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知通道状态消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=转发给在线用户失败, 用户ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
                EnSystemLog(EV9000_CMS_QUERY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device notify channel status message process failed:front-end device ID=%s, cause=forward to online user failed, user ID=%s", caller_id, callee_id);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_channel_status_proc() SendMessageToOnlineUserByUserIDForTVWallStatus Error:callee_id=%s, caller_id=%s \r\n", callee_id, caller_id);
            }
            else if (i > 0)
            {
                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知通道状态消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 转发给在线用户, 用户ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment channel status response message processing success: the front-end device ID = % s, = % s IP address, port number = % d, forwarded to online users", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_channel_status_proc() SendMessageToOnlineUserByUserIDForTVWallStatus OK:callee_id=%s, caller_id=%s \r\n", callee_id, caller_id);
            }
        }
        else
        {
            SystemLog(EV9000_CMS_QUERY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知通道状态消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=用户不在本级CMS范围内, 用户ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
            EnSystemLog(EV9000_CMS_QUERY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device notify channel status message process failed:front-end device ID=%s, cause=user is not in local level CMS, user ID=%s", caller_id, callee_id);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_channel_status_proc() User Not Belong To Mine :user_id=%s \r\n", callee_id);
        }
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_notify_data_value_proc
 功能描述  : 设备数据值通知信息处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月13日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_data_value_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_data_value_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_data_value_proc() exit---: Param Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知数据值消息消息:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment notification data values message: ID = % s front-end equipment, IP address = % s, port = % d", caller_id);

    if (0 == strncmp(callee_id, local_cms_id_get(), 20)) /* 查看被叫是否是本CMS ID */
    {
        i = SendMessageToOnlineUser((char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length(), 0);

        if (i < 0)
        {
            SystemLog(EV9000_CMS_QUERY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知数据值消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=转发给在线用户失败", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            EnSystemLog(EV9000_CMS_QUERY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device notify data value message process failed:front-end device ID=%s, cause=forward to online user failed", caller_id);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_data_value_proc() SendMessageToOnlineUser Error: caller_id=%s \r\n", caller_id);
        }
        else if (i > 0)
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通道状态响应消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 转发给在线用户", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end device notify data value message process successfully:front-end device ID=%s, forward to online user", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_data_value_proc() SendMessageToOnlineUser OK: caller_id=%s \r\n", caller_id);
        }

        return i;
    }
    else /* 转发出去 */
    {
        if (IsMyUser(callee_id))
        {
            /* 发送给本级在线用户 */
            i = SendMessageToOnlineUserByUserID(callee_id, (char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length());

            if (i < 0)
            {
                SystemLog(EV9000_CMS_QUERY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知数据值消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=转发给在线用户失败, 用户ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
                EnSystemLog(EV9000_CMS_QUERY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device notify data value message process failed:front-end device ID=%s, cause=forward to online user failed, user ID=%s", caller_id, callee_id);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_data_value_proc() SendMessageToOnlineUserByUserID Error:callee_id=%s, caller_id=%s \r\n", callee_id, caller_id);
            }
            else if (i > 0)
            {
                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通道状态响应消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 转发给在线用户, 用户ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end device channel status response message processing successfully:front-end device ID=%s, forward to online user, user ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_data_value_proc() SendMessageToOnlineUserByUserID OK:callee_id=%s, caller_id=%s \r\n", callee_id, caller_id);
            }
        }
        else
        {
            SystemLog(EV9000_CMS_QUERY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知数据值消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=用户不在本级CMS范围内, 用户ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, callee_id);
            EnSystemLog(EV9000_CMS_QUERY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device notify data value message process failed:front-end device ID=%s, cause=user is not in local level CMS, user ID=%s", caller_id, callee_id);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_data_value_proc() User Not Belong To Mine :user_id=%s \r\n", callee_id);
        }
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_notify_device_group_config_proc
 功能描述  : 前端逻辑设备分组通知信息处理
 输入参数  : GBDevice_info_t * pGBDeviceInfo
             char * caller_id
             char * callee_id
             CPacket & inPacket
             DBOper * pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2016年11月12日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_device_group_config_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    char strEvent[32] = {0};
    char strGroupID[64] = {0};
    char strName[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strSortID[64] = {0};
    char strParentID[64] = {0};

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_device_group_config_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_device_group_config_proc() exit---: Param Error \r\n");
        return -1;
    }

    //SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知逻辑设备分组信息消息:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    //EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment notification logic device group config message: ID = %s front-end equipment, IP address = %s, port = %d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

    /* 组编号 */
    memset(strGroupID, 0, 64);
    inPacket.GetElementValue((char*)"GroupID", strGroupID);

    /* 事件 */
    memset(strEvent, 0, 32);
    inPacket.GetElementValue((char*)"Event", strEvent);

    /* 组名称 */
    memset(strName, 0, 128);
    inPacket.GetElementValue((char*)"Name", strName);

    /* 同一父节点下组排序编号，默认0不排序 */
    memset(strSortID, 0, 64);
    inPacket.GetElementValue((char*)"SortID", strSortID);

    /* 父节点编号 */
    memset(strParentID, 0, 64);
    inPacket.GetElementValue((char*)"ParentID", strParentID);

    if (sstrcmp(strEvent, "ADD") == 0 || sstrcmp(strEvent, "UPDATE") == 0)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知逻辑设备分组信息消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的分组信息:组编号=%s, 组名称=%s, 事件类型=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGroupID, strName, strEvent);

        i = DeviceGroupConfigInfoProc(pGBDeviceInfo, strGroupID, strName, strParentID, osip_atoi(strSortID), 1, pDevice_Srv_dboper, 1);

        if (i < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_device_group_config_proc() DeviceGroupConfigInfoProc ERROR:GroupID=%s, iRet=%d \r\n", strGroupID, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_device_group_config_proc() DeviceGroupConfigInfoProc OK:GroupID=%s, iRet=%d \r\n", strGroupID, i);
        }
    }
    else if (sstrcmp(strEvent, "DEL") == 0)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备通知逻辑设备分组信息消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报删除分组信息:组编号=%s, 组名称=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGroupID, strName);

        i = DeviceGroupConfigInfoProc(pGBDeviceInfo, strGroupID, strName, strParentID, osip_atoi(strSortID), 2, pDevice_Srv_dboper, 1);

        if (i < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_device_group_config_proc() DeviceGroupConfigInfoProc ERROR:GroupID=%s, iRet=%d \r\n", strGroupID, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_device_group_config_proc() DeviceGroupConfigInfoProc OK:GroupID=%s, iRet=%d \r\n", strGroupID, i);
        }
    }
    else
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备通知逻辑设备分组信息消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的分组信息:组编号=%s, 组名称=%s, 不支持的事件类型", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGroupID, strName);
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_notify_device_group_map_config_proc
 功能描述  : 前端逻辑设备分组关系通知信息处理
 输入参数  : GBDevice_info_t * pGBDeviceInfo
             char * caller_id
             char * callee_id
             CPacket & inPacket
             DBOper * pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2016年11月12日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_device_group_map_config_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    char strEvent[32] = {0};
    char strGroupID[64] = {0};
    unsigned int iDeviceIndex = 0;
    char strDeviceIndex[64] = {0};
    char strSortID[64] = {0};

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_device_group_map_config_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_device_group_map_config_proc() exit---: Param Error \r\n");
        return -1;
    }

    //SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知逻辑设备分组关系信息消息:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    //EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment notification logic device map group config message: ID = %s front-end equipment, IP address = %s, port = %d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

    /* 组编号 */
    memset(strGroupID, 0, 64);
    inPacket.GetElementValue((char*)"GroupID", strGroupID);

    /* 事件 */
    memset(strEvent, 0, 32);
    inPacket.GetElementValue((char*)"Event", strEvent);

    /* 逻辑设备索引 */
    memset(strDeviceIndex, 0, 64);
    inPacket.GetElementValue((char*)"DeviceIndex", strDeviceIndex);

    /* 同一父节点下组排序编号 */
    memset(strSortID, 0, 64);
    inPacket.GetElementValue((char*)"SortID", strSortID);

    if (strDeviceIndex[0] != '\0')
    {
        iDeviceIndex = strtoul(strDeviceIndex, NULL, 10);
    }
    else
    {
        iDeviceIndex = 0;
    }

    if (sstrcmp(strEvent, "ADD") == 0 || sstrcmp(strEvent, "UPDATE") == 0)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知逻辑设备分组关系信息消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的分组关系信息:组编号=%s, 逻辑设备索引=%s, 事件类型=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGroupID, strDeviceIndex, strEvent);

        i = DeviceGroupMapConfigInfoProc(pGBDeviceInfo, strGroupID, iDeviceIndex, osip_atoi(strSortID), 1, pDevice_Srv_dboper, 1);

        if (i < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_device_group_map_config_proc() DeviceGroupMapConfigInfoProc ERROR:GroupID=%s, iRet=%d \r\n", strGroupID, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_device_group_map_config_proc() DeviceGroupMapConfigInfoProc OK:GroupID=%s, iRet=%d \r\n", strGroupID, i);
        }
    }
    else if (sstrcmp(strEvent, "DEL") == 0)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备通知逻辑设备分组关系信息消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报删除分组关系信息:组编号=%s, 逻辑设备索引=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGroupID, strDeviceIndex);

        i = DeviceGroupMapConfigInfoProc(pGBDeviceInfo, strGroupID, iDeviceIndex, osip_atoi(strSortID), 2, pDevice_Srv_dboper, 1);

        if (i < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_device_group_map_config_proc() DeviceGroupMapConfigInfoProc ERROR:GroupID=%s, iRet=%d \r\n", strGroupID, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_device_group_map_config_proc() DeviceGroupMapConfigInfoProc OK:GroupID=%s, iRet=%d \r\n", strGroupID, i);
        }
    }
    else
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备通知逻辑设备分组关系信息消息,上报的分组关系信息:组编号=%s, 点位索引=%u, 不支持的事件类型", strGroupID, iDeviceIndex);
    }

    return i;
}

/*****************************************************************************
 函 数 名  : user_device_control_response_proc
 功能描述  : 用户设备控制响应处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月13日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_device_control_response_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket)
{
    int i = 0;
    int xml_pos = -1;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    unsigned int transfer_xml_sn = 0;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_device_control_response_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_device_control_response_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 设备控制的响应命令直接转发，不做处理
          控制流程见9.3.2

          命令包括如下字段:
          <!-- 命令类型：设备控制（必选） -->
          <element name="CmdType" fixed ="DeviceControl" />
          <!-- 命令序列号（必选） -->
          <element name="SN" type="integer" minInclusive value = "1" />
          <!-- 目标设备编码（必选） -->
          <element name="DeviceID" type="tg:deviceIDType" />
          <!-- 执行结果标志（必选） -->
          <element name="Result" type="tg:resultType" />
      */

    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_device_control_response_proc() \
    \r\n XML Para: \
    \r\n SN=%s \
    \r\n DeviceID=%s \r\n ", strSN, strDeviceID);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备控制响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment control response message: front-end equipment, ID = % s = % s IP address, port number = % d, logical device ID = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);

    if (strSN[0] == '\0')
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_response_proc() exit---: Get XML SN Error\r\n");
        return -1;
    }

    if (strDeviceID[0] == '\0')
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_response_proc() exit---: Get XML DeviceID Error\r\n");
        return -1;
    }

    /* 看看是否是用户查询或者上级查询的 */
    transfer_xml_sn = strtoul(strSN, NULL, 10);
    xml_pos = transfer_xml_msg_find(XML_CONTROL_DEVICECONTROL, strDeviceID, transfer_xml_sn);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_device_control_response_proc() transfer_xml_msg_find:Type=%d, DeviceID=%s, transfer_xml_sn=%d, xml_pos=%d \r\n", XML_CONTROL_DEVICECONTROL, strDeviceID, transfer_xml_sn, xml_pos);

    if (xml_pos >= 0)
    {
        i = transfer_xml_message_to_dest2(xml_pos, inPacket);

        if (i != 0)
        {
            SystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备控制响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=根据XML的SN转发给目的地失败, xml_pos=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "The front-end device control response message processing failed: the front-end device ID=%s, the reason = SN XML forwarding to the destination failed", strDeviceID);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_response_proc() transfer_xml_message_to_dest Error:device_id=%s\r\n", caller_id);
        }
        else
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备控制响应消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d,根据XML的SN转发给目的地, xml_pos=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment control response message processing success: the front-end device ID = % s, = % s IP address, port number = % d, according to the XML SN forwarded to destination, xml_pos = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_control_response_proc() transfer_xml_message_to_dest OK:device_id=%s\r\n", caller_id);
        }
    }
    else
    {
        SystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备控制响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=根据XML的SN查找目的地失败, transfer_xml_sn=%d, strDeviceID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, transfer_xml_sn, strDeviceID);
        EnSystemLog(EV9000_CMS_DEVICE_CONTROL_ERROR, EV9000_LOG_LEVEL_ERROR, "The front-end device control response message processing failed: the front-end device ID=%s, the reason = SN XML forwarding to the destination failed", strDeviceID);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_response_proc() transfer_xml_message_to_dest Error:device_id=%s\r\n", caller_id);
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_set_device_video_param_response_proc
 功能描述  : 设置前端图像参数返回消息处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年12月25日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_set_device_video_param_response_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket)
{
    int i = 0;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_set_device_video_param_response_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_set_device_video_param_response_proc() exit---: Param Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备设置图像参数响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment set up image parameter response message: ID = % s front-end equipment, IP address = % s, port = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

    /* 设置前端图像参数的响应消息直接转发给客户端或者上级CMS，不做处理

          命令包括如下字段:

      <?xml version="1.0"?>
      <Response>
      <CmdType>SetDeviceVideoParam</CmdType>
      <SN>43</SN>
      <DeviceID>64010000001110000001</DeviceID>
      <Result>OK</ Result >   // 设置结果
      </Response >
      */


    return i;
}

/*****************************************************************************
 函 数 名  : device_get_device_video_param_response_proc
 功能描述  : 获取前端图像参数返回消息处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年12月25日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_get_device_video_param_response_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket)
{
    int i = 0;
    int xml_pos = -1;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    unsigned int transfer_xml_sn = 0;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_get_device_video_param_response_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_get_device_video_param_response_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 获取前端图像参数的响应消息直接转发给客户端或者上级CMS，不做处理

          命令包括如下字段:


      <?xml version="1.0"?>
      <Response>
      <CmdType>GetDeviceVideoParam</CmdType>
      <SN>43</SN>
      <DeviceID>64010000001110000001</DeviceID>
      <Brightness>12</ Brightness >          // 亮度
      <Saturation>22</ Saturation >           // 饱和度
      <Contrast>2</ Contrast>                   // 对比度
      <ColourDegree>2</ ColourDegree >    // 色度
      </ Response >
      */

    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_get_device_video_param_response_proc() \
    \r\n XML Para: \
    \r\n SN=%s \
    \r\n DeviceID=%s \r\n ", strSN, strDeviceID);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备获取图像参数响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment for image parameter response message: ID = % s front-end equipment, IP address = % s, port = % d, logical device ID = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);

    if (strSN[0] == '\0')
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_get_device_video_param_response_proc() exit---: Get XML SN Error\r\n");
        return -1;
    }

    if (strDeviceID[0] == '\0')
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_get_device_video_param_response_proc() exit---: Get XML DeviceID Error\r\n");
        return -1;
    }

    /* 看看是否是用户查询或者上级查询的 */
    transfer_xml_sn = strtoul(strSN, NULL, 10);
    xml_pos = transfer_xml_msg_find(XML_QUERY_DEVICEVIDEOPARAM, strDeviceID, transfer_xml_sn);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_get_device_video_param_response_proc() transfer_xml_msg_find:Type=%d, DeviceID=%s, transfer_xml_sn=%d, xml_pos=%d \r\n", XML_QUERY_DEVICEVIDEOPARAM, strDeviceID, transfer_xml_sn, xml_pos);

    if (xml_pos >= 0)
    {
        i = transfer_xml_message_to_dest2(xml_pos, inPacket);

        if (i != 0)
        {
            SystemLog(EV9000_CMS_SET_VIDEO_PARAM_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备图像参数信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=根据XML的SN转发给目的地失败, xml_pos=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            EnSystemLog(EV9000_CMS_SET_VIDEO_PARAM_ERROR, EV9000_LOG_LEVEL_ERROR, "The front-end device image parameter information query response message processing failed: the front-end device ID=%s, the reason = SN XML forwarding to the destination failed", caller_id);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_get_device_video_param_response_proc() transfer_xml_message_to_dest Error:device_id=%s\r\n", caller_id);
        }
        else
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备图像参数查询响应消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 根据XML的SN转发给目的地, xml_pos=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment image parameters query response message processing success: the front-end device ID = % s, = % s IP address, port number = % d, according to the XML SN forwarded to destination, xml_pos = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_get_device_video_param_response_proc() transfer_xml_message_to_dest OK:device_id=%s\r\n", caller_id);
        }
    }
    else
    {
        SystemLog(EV9000_CMS_SET_VIDEO_PARAM_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备图像参数信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=根据XML的SN查找目的地失败, transfer_xml_sn=%d, strDeviceID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, transfer_xml_sn, strDeviceID);
        EnSystemLog(EV9000_CMS_SET_VIDEO_PARAM_ERROR, EV9000_LOG_LEVEL_ERROR, "The front-end image parameter information query response message processing failed: the front-end device ID=%s, the reason = SN XML forwarding to the destination failed", strDeviceID);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_control_response_proc() transfer_xml_message_to_dest Error:device_id=%s\r\n", caller_id);
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_get_dbip_response_proc
 功能描述  : 获取下级CMS数据库IP地址的回应消息处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年3月10日 星期一
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_get_dbip_response_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int iRet = 0;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strDBIP[32] = {0};
    char strUpdateDBIP[32] = {0};

    string strSQL = "";
    int record_count = 0;
    unsigned int tmp_uvalue = 0;
    unsigned int uIPAddr = 0;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_get_dbip_response_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_get_dbip_response_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 获取下级CMS 数据库IP 地址回应消息直接和数据库进行比较，更新到数据库

          命令包括如下字段:

      <?xml version="1.0"?>
      <Response>
      <CmdType> GetDBIP</CmdType>
      <SN>43</SN>
      <DeviceID>64010000001110000001</DeviceID>
      <DBIP>172.X.X.X</DBIP>
      </ Response >
      */

    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);
    inPacket.GetElementValue((char*)"DBIP", strDBIP);

    uIPAddr = (unsigned int)inet_addr(strDBIP);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_get_dbip_response_proc() \
    \r\n XML Para: \
    \r\n SN=%s \
    \r\n DeviceID=%s \
    \r\n DBIP=%s \
    \r\n uIPAddr=%u \r\n", strSN, strDeviceID, strDBIP, uIPAddr);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备获取数据库地址响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s, DBIP=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID, strDBIP);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Access database front-end equipment address response message: ID = % s front-end equipment, IP address = % s, port = % d, logical device ID = % s, DBIP = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID, strDBIP);

    /* 查看被叫是否是本CMS ID */
    if (0 != strncmp(callee_id, local_cms_id_get(), 20))
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_get_dbip_response_proc() exit---: Not Belong To Mine \r\n");
        return -1;
    }

    /* 查询标准物理设备表 */
    strSQL.clear();
    strSQL = "select * from GBPhyDeviceConfig WHERE DeviceID like '";
    strSQL += strDeviceID;
    strSQL += "';";

    record_count = pDevice_Srv_dboper->DB_Select(strSQL.c_str(), 1);

    if (record_count < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_get_dbip_response_proc() DB Oper Error:strSQL=%s, record_count=%d \r\n", strSQL.c_str(), record_count);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_get_dbip_response_proc() ErrorMsg=%s\r\n", pDevice_Srv_dboper->GetLastDbErrorMsg());
        return -1;
    }
    else if (record_count == 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "device_get_dbip_response_proc() exit---: No Record Count \r\n");
        return 0;
    }

    /* 数据库IP 地址*/
    tmp_uvalue = 0;
    pDevice_Srv_dboper->GetFieldValue("Resved1", tmp_uvalue);

    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_get_dbip_response_proc() tmp_uvalue=%u \r\n", tmp_uvalue);

    if (tmp_uvalue != uIPAddr)
    {
        /* 更新数据库 */
        strSQL.clear();
        strSQL = "UPDATE GBPhyDeviceConfig SET Resved1 = ";
        snprintf(strUpdateDBIP, 32, "%u", uIPAddr);
        strSQL += strUpdateDBIP;
        strSQL += " WHERE DeviceID like '";
        strSQL += strDeviceID;
        strSQL += "'";

        iRet = pDevice_Srv_dboper->DB_Update(strSQL.c_str(), 1);

        if (iRet < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_get_dbip_response_proc() DB Oper Error:strSQL=%s, iRet=%d \r\n", strSQL.c_str(), iRet);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_get_dbip_response_proc() ErrorMsg=%s\r\n", pDevice_Srv_dboper->GetLastDbErrorMsg());
        }
    }

    return iRet;
}

/*****************************************************************************
 函 数 名  : device_get_service_id_proc
 功能描述  : 设备获取服务器ID
 输入参数  : char* caller_id
             char* caller_ip
             int caller_port
             char* callee_id
             char* local_ip
             int local_port
             char* pcSN
             char* pcServerIP
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2016年6月12日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_get_service_id_proc(char * caller_id, char * caller_ip, int caller_port, char * callee_id, char * local_ip, int local_port, char * pcSN, char * pcServerIP, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    CPacket outPacket;
    DOMElement* AccNode = NULL;

    if (NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_get_service_id_proc() exit---: Device Srv dboper Error \r\n");
        return -1;
    }

    if ((NULL == caller_id) || (NULL == caller_ip) || (caller_port <= 0))
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_get_service_id_proc() exit---: Caller Info Error \r\n");
        return -1;
    }

    if ((NULL == callee_id) || (NULL == local_ip) || (local_port <= 0))
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_get_service_id_proc() exit---: Callee Info Error \r\n");
        return -1;
    }

    if ((NULL == pcServerIP) || (pcServerIP[0] == '\0'))
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_get_service_id_proc() exit---: Server Info Error \r\n");
        return -1;
    }

    /* 回复响应,组建消息 */
    outPacket.SetRootTag("Response");

    AccNode = outPacket.CreateElement((char*)"CmdType");
    outPacket.SetElementValue(AccNode, (char*)"GetServerID");

    AccNode = outPacket.CreateElement((char*)"SN");
    outPacket.SetElementValue(AccNode, pcSN);

    AccNode = outPacket.CreateElement((char*)"ServerID");
    outPacket.SetElementValue(AccNode, local_cms_id_get());

    i = SIP_SendMessage(NULL, caller_id, callee_id, local_ip, local_port, caller_ip, caller_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

    if (i == 0)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "设备登录前开始获取服务器ID成功:设备IP地址=%s, 端口号=%d, 服务器ID=%s", caller_ip, caller_port, local_cms_id_get());
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Equipment login ID began to get the server before success: IP address = % s, port = % d, the server ID = % s", caller_ip, caller_port, local_cms_id_get());
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_get_service_id_proc() SIP_SendMessage OK:user_id=%s, user_ip=%s, user_port=%d \r\n", caller_id, caller_ip, caller_port);
    }
    else
    {
        SystemLog(EV9000_CMS_GET_SERVERID_ERROR, EV9000_LOG_LEVEL_ERROR, "设备登录前开始获取服务器ID失败:设备IP地址=%s, 端口号=%d, 原因=%s", caller_ip, caller_port, (char*)"发送SIP响应消息失败");
        EnSystemLog(EV9000_CMS_GET_SERVERID_ERROR, EV9000_LOG_LEVEL_ERROR, "Before the user log in,start to get server ID and user ID failed:user IP:%s , port=%d , reason= %s", caller_ip, caller_port, (char*)"Sending a SIP response message failed.");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_get_service_id_proc() SIP_SendMessage Error:user_id=%s, user_ip=%s, user_port=%d \r\n", caller_id, caller_ip, caller_port);
    }

    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_get_service_id_proc() Exit--- \r\n");
    //printf("\r\n ********** user_get_service_id_proc Exit--- \r\n");
    //printf_system_time();

    return i;
}

/*****************************************************************************
 函 数 名  : device_notify_tv_status_response_proc
 功能描述  : 客户端通知电视墙状态返回消息
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年12月25日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_tv_status_response_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket)
{
    int i = 0;
    int pos = -1;
    route_info_t* pRouteInfo = NULL;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_tv_status_response_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_notify_tv_status_response_proc() exit---: Param Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知电视墙状态响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment notification state TV wall response message: ID = % s front-end equipment, IP address = % s, port = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

    /* 客户端通知电视墙状态的响应消息直接转发给客户端或者上级CMS，不做处理

          命令包括如下字段:

        <?xml version="1.0"?>
        <Response>
        <CmdType>TVStatus</ CmdType>
        <Result>OK</Result>            OK: 成功 其他：错误原因
        <SN>1234</SN>
      </Response>

      */

    /* 查看被叫是否是本CMS ID */
    if (0 == strncmp(callee_id, local_cms_id_get(), 20))
    {
        /* 发送给本级在线用户 */
        i = SendMessageToOnlineUserForTVWallStatus((char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length());

        if (i < 0)
        {
            SystemLog(EV9000_CMS_NOTIFY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知电视墙状态响应消息处理失败:前端设备ID=%s, 原因=转发给在线用户失败, 用户ID=%s", caller_id, callee_id);
            EnSystemLog(EV9000_CMS_NOTIFY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device notify TV wall status response message process failed:front-end device ID=%s, cause =forward to online user failed, user ID=%s", caller_id, callee_id);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_tv_status_response_proc() SendMessageToOnlineUserForTVWallStatus Error:callee_id=%s, caller_id=%s \r\n", callee_id, caller_id);
        }
        else if (i > 0)
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知电视墙状态响应消息处理成功:前端设备ID=%s, 转发给在线用户, 用户ID=%s", caller_id, callee_id);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment notification state TV wall response message processing success: ID = % s front-end equipment, forwarded to the online user, the user ID = % s", caller_id, callee_id);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_tv_status_response_proc() SendMessageToOnlineUserForTVWallStatus OK:callee_id=%s, caller_id=%s \r\n", callee_id, caller_id);
        }
    }
    else /* 转发出去 */
    {
        pos = route_info_find(callee_id);

        if (pos >= 0)
        {
            pRouteInfo = route_info_get(pos);

            if (NULL != pRouteInfo)
            {
                if (pRouteInfo->reg_status == 1)
                {
                    /* 转发消息给上级CMS */
                    i = SIP_SendMessage(NULL, local_cms_id_get(), callee_id, pRouteInfo->strRegLocalIP, pRouteInfo->iRegLocalPort, pRouteInfo->server_ip, pRouteInfo->server_port, (char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length());

                    if (i != 0)
                    {
                        SystemLog(EV9000_CMS_NOTIFY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知电视墙状态响应消息处理失败:前端设备ID=%s, 原因=转发到上级CMS失败, 上级CMS ID=%s, IP地址=%s, 端口号=%d", caller_id, callee_id, pRouteInfo->server_ip, pRouteInfo->server_port);
                        EnSystemLog(EV9000_CMS_NOTIFY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device notify TV wall status response message process failed:front-end device ID=%s, cause =forward to superior CMSfailed, superiorCMS ID=%s, superiorCMS IP=%s, port number=%d", caller_id, callee_id, pRouteInfo->server_ip, pRouteInfo->server_port);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_tv_status_response_proc() SIP_SendMessage Error:dest_id=%s, dest_ip=%s, dest_port=%d \r\n", callee_id, pRouteInfo->server_ip, pRouteInfo->server_port);
                    }
                    else
                    {
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知电视墙状态响应消息处理成功:前端设备ID=%s, 转发到上级CMS, 上级CMS ID=%s, IP地址=%s, 端口号=%d", caller_id, callee_id, pRouteInfo->server_ip, pRouteInfo->server_port);
                        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment notification state TV wall response message processing success: ID = % s front-end equipment, forwarded to the superior CMS, superior CMS, ID = % s IP address = % s, port = % d", caller_id, callee_id, pRouteInfo->server_ip, pRouteInfo->server_port);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_tv_status_response_proc() SIP_SendMessage OK:dest_id=%s, dest_ip=%s, dest_port=%d \r\n", callee_id, pRouteInfo->server_ip, pRouteInfo->server_port);
                    }
                }
            }
            else
            {
                SystemLog(EV9000_CMS_NOTIFY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知电视墙状态响应消息处理失败:前端设备ID=%s, 原因=没有找到上级CMS信息, 上级CMS ID=%s", caller_id, callee_id);
                EnSystemLog(EV9000_CMS_NOTIFY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device notify TV wall status response message process failed:front-end device ID=%s, cause=superior CMS information not found, superiorCMS ID=%s", caller_id, callee_id);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_tv_status_response_proc() exit---: Get Route Info Error:Route Server ID=%s \r\n", callee_id);
                return -1;
            }
        }
        else if (IsMyUser(callee_id))
        {
            /* 发送给本级在线用户 */
            i = SendMessageToOnlineUserByUserIDForTVWallStatus(callee_id, (char*)inPacket.GetXml(NULL).c_str(), inPacket.GetXml(NULL).length());

            if (i < 0)
            {
                SystemLog(EV9000_CMS_NOTIFY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通知电视墙状态响应消息处理失败:前端设备ID=%s, 原因=转发给在线用户失败, 用户ID=%s", caller_id, callee_id);
                EnSystemLog(EV9000_CMS_NOTIFY_DEC_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device notify TV wall status response message process failed:front-end deviceID=%s, cause=forward to onlice user failed, userID=%s", caller_id, callee_id);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_tv_status_response_proc() SendMessageToOnlineUserByUserIDForTVWallStatus Error:callee_id=%s, caller_id=%s \r\n", callee_id, caller_id);
            }
            else if (i > 0)
            {
                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通知电视墙状态响应消息处理成功:前端设备ID=%s, 转发给在线用户, 用户ID=%s", caller_id, callee_id);
                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end device notify TV wall status response message process success: the front-end device ID = % s and forwarded to the online user, the user ID = % s", caller_id, callee_id);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_tv_status_response_proc() SendMessageToOnlineUserByUserIDForTVWallStatus OK:callee_id=%s, caller_id=%s \r\n", callee_id, caller_id);
            }
        }
        else
        {

        }
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_notify_alarm_response_proc
 功能描述  : 设备告警信息响应处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月13日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_alarm_response_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket)
{

    /* 报警响应消息暂时不需要处理

      命令包括如下字段:
      <!-- 命令类型：报警通知（必选） -->
      <element name="CmdType" fixed ="Alarm" />
      <!-- 命令序列号（必选） -->
      <element name="SN" type="integer" minInclusive value = "1" />
      <!-- 目标设备编码（必选） -->
      <element name="DeviceID" type="tg:deviceIDType" />
      <!-- 执行结果标志（必选） -->
      <element name="Result" type="tg:resultType" />
      */


    return 0;
}

/*****************************************************************************
 函 数 名  : user_query_catalog_response_proc
 功能描述  : 逻辑设备目录查询响应消息处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月21日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_query_catalog_response_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    int xml_pos = -1;
    int logic_device_pos = -1;
    char strSN[32] = {0};
    char strDeviceIndex[64] = {0};
    char strDeviceID[32] = {0};
    char strGBLogicDeviceID[32] = {0};
    char strSumNum[16] = {0};
    string strDeviceListNum = "";
    int iSumNum = 0;
    int iDeviceListNum = 0;
    int iItemNumCount = 0;
    char strName[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strEnable[64] = {0};
    char strAlarmDeviceSubType[64] = {0};
    char strCtrlEnable[64] = {0};
    char strMicEnable[64] = {0};
    char strFrameCount[64] = {0};
    char strStreamCount[64] = {0};
    char strAlarmLengthOfTime[64] = {0};
    char strManufacturer[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strModel[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strOwner[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strCivilCode[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strBlock[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strAddress[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strParental[16] = {0};
    char strParentID[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strSafetyWay[16] = {0};
    char strRegisterWay[16] = {0};
    char strCertNum[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strCertifiable[16] = {0};
    char strErrCode[16] = {0};
    char strEndTime[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strSecrecy[16] = {0};
    char strIPAddress[MAX_IP_LEN] = {0};
    char strPort[16] = {0};
    char strPassword[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strStatus[16] = {0};
    char strLongitude[64] = {0};
    char strLatitude[64] = {0};
    char strMapLayer[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strCMSID[MAX_ID_LEN + 4] = {0};
    char strAlarmPriority[32] = {0};/*2016.10.10 add for RCU*/
    char strGuard[32] = {0};/*2016.10.10 add for RCU*/
    char strValue[256] = {0};/*2016.10.10 add for RCU*/
    char strUnit[32] = {0};/*2016.10.10 add for RCU*/
    char strPTZType[64] = {0};
    GBLogicDevice_info_t* pOldGBLogicDeviceInfo = NULL;
    GBLogicDevice_info_t* pNewGBLogicDeviceInfo = NULL;
    GBDevice_info_t* pOldGBDeviceInfo = NULL;
    DOMElement* ItemAccNode = NULL;
    char strDeviceType[4] = {0};
    int iDeviceType = 0;
    int iDeviceIDLen = 0;
    int iPTZType = 0;
    char* pTmp = NULL;
    //char* tmp_civil_code;
    unsigned int transfer_xml_sn = 0;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_catalog_response_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_catalog_response_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 网络设备信息查询响应消息直接转发，不做处理
          控制流程见9.5.2

          命令包括如下字段:
          <!-- 命令类型：设备目录查询（必选） -->
          <element name="CmdType" fixed ="Catalog" />
          <!-- 命令序列号（必选） -->
          <element name="SN" type="integer" minInclusive value = "1" />
          <!-- 目标设备的设备编码（必选） -->
          <element name="DeviceID" type="tg:deviceIDType" />
          <!-- 设备目录项列表,num表示目录项个数 -->
          <element name="DeviceList">
          <attribute name="Num" type="integer"/>
          <choice minOccurs= "0" maxOccurs= " unbounded " >
          <element name="Item" type="tg:itemType"/>
          </choice>
          </element>
          <!-- 扩展信息，可多项 -->
          <element name= "Info" minOccurs= "0" maxOccurs="unbounded">
          <restriction base= "string">
          <maxLength value= "1024" />
          </restriction>
          </element>
      */

    /* 逻辑设备信息一般是设备注册成功之后CMS主动发起的查询 */
    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);
    inPacket.GetElementValue((char*)"SumNum", strSumNum);
    inPacket.GetElementAttr((char*)"DeviceList", (char*)"Num", strDeviceListNum);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_catalog_response_proc() \
    \r\n XML Para: \
    \r\n SN=%s \
    \r\n DeviceID=%s \
    \r\n SumNum=%s \
    \r\n DeviceList Num=%s \r\n ", strSN, strDeviceID, strSumNum, (char*)strDeviceListNum.c_str());

    //SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
    //EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment directory query response message: front-end equipment, ID = % s = % s IP address, port number = % d, logical device ID = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);

    if (strSumNum[0] == '\0')
    {
        SystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备目录查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=没有获取到前端上报的逻辑通道目录总数", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        EnSystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device directory search response message process failed:front-end device ID=%s, cause= did not get total number of logic channel directory reported from front-end", caller_id);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_catalog_response_proc() exit---: Get Sun Num Error \r\n");
        return -1;
    }

    /* 可能属于虚拟组织下面,这里的判断暂时去掉
        if (0 != sstrcmp(strDeviceID, pGBDeviceInfo->device_id))
        {
            SystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备目录查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=前端设备的XML里面的设备ID错误, XML设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
            EnSystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device directory search response message process failed:front-end deviceID=%s, cause = XML device ID  from front-end device incorrect, XML device ID=%s", caller_id, strDeviceID);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_catalog_response_proc() exit---: DeviceID Error:DeviceID=%s \r\n", strDeviceID);
            return -1;
        }
    */

    /* 将设备信息写入标准逻辑设备表 */
    iSumNum = osip_atoi(strSumNum);
    iDeviceListNum = osip_atoi((char*)strDeviceListNum.c_str());
    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_catalog_response_proc() SumNum=%d, DeviceListNum=%d \r\n", iSumNum, iDeviceListNum);
    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备总数=%d, 本次上报的逻辑设备个数=%d, 已经上报的个数统计=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, iSumNum, iDeviceListNum, pGBDeviceInfo->CataLogNumCount);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end equipment directory query response message: report of the total number of logical device = % d, report the number of logical device = % d", iSumNum, iDeviceListNum);

    /* 看看是否是用户查询或者上级查询的 */
    transfer_xml_sn = strtoul(strSN, NULL, 10);
    xml_pos = transfer_xml_msg_find(XML_QUERY_CATALOG, strDeviceID, transfer_xml_sn);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_query_catalog_response_proc() transfer_xml_msg_find:Type=%d, DeviceID=%s, transfer_xml_sn=%d, xml_pos=%d \r\n", XML_QUERY_CATALOG, strDeviceID, transfer_xml_sn, xml_pos);

    if (xml_pos >= 0)
    {
        i = transfer_xml_message_to_dest(xml_pos, iSumNum, iDeviceListNum, inPacket);

        if (i != 0)
        {
            SystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备目录查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=根据XML的SN转发给目的地失败, xml_pos=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            EnSystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device directory search response message process failed:front-end deviceID=%s, cause =SN XML forwarding to the destination failed", caller_id);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_catalog_response_proc() transfer_xml_message_to_dest Error:device_id=%s \r\n", caller_id);
        }
        else
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备目录通知消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d,根据XML的SN转发给目的地, xml_pos=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment directory notification message processing success: ID = % s front-end equipment, IP address = % s, port = % d, according to the XML SN forwarded to destination, xml_pos = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_catalog_response_proc() transfer_xml_message_to_dest OK:device_id=%s \r\n", caller_id);
        }
    }
    else /* CMS本身查询返回的 */
    {
        if (iSumNum > 0)
        {
            if (iDeviceListNum <= 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_catalog_response_proc() exit---: DeviceListNum Error \r\n");
                return -1;
            }

            if (pGBDeviceInfo->CataLogSN != (unsigned int)osip_atoi(strSN))
            {
                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备目录查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=收到响应报文不是本次请求的报文, 自动丢弃, 请求CataLogSN=%d, 响应CataLogSN=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, pGBDeviceInfo->CataLogSN, (unsigned int)osip_atoi(strSN));
                return -1;
            }

            if (1 == pGBDeviceInfo->iGetCataLogStatus)
            {
                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备目录查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=设备状态不是等待响应报文状态, 自动丢弃, 设备获取Catalog状态=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, pGBDeviceInfo->iGetCataLogStatus);
                return -1;
            }

            /* 设置获取逻辑通道的获取状态 */
            if (pGBDeviceInfo->CataLogNumCount == 0)
            {
                if (0 == pGBDeviceInfo->iGetCataLogStatus)
                {
                    pGBDeviceInfo->iGetCataLogStatus = 2;
                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_catalog_response_proc() GBDeviceInfo:DeviceID=%s,GetCataLogStatus=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->iGetCataLogStatus);
                }
            }

            if (EV9000_DEVICETYPE_DECODER == pGBDeviceInfo->device_type
                || EV9000_DEVICETYPE_INTELLIGENTANALYSIS  == pGBDeviceInfo->device_type)
            {
                /* 先将该物理设备下面的逻辑通道都置为删除状态 */
                if (pGBDeviceInfo->CataLogNumCount == 0)
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 收到第一个响应报文, 设置该物理设备下面所有通道删除标识", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment directory query response message: set up the physical device below all channels to delete logo, the front-end device ID = % s", pGBDeviceInfo->device_id);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_catalog_response_proc() Proc Catalog Item Begin---:device_id=%s, SumNum=%d \r\n", pGBDeviceInfo->device_id, iSumNum);
                    i = SetGBLogicDeviceInfoDelFlag(pGBDeviceInfo);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_catalog_response_proc() SetGBLogicDeviceInfoDelFlag:i=%d \r\n", i);
                }

                /* 上报个数统计 */
                pGBDeviceInfo->CataLogNumCount += iDeviceListNum;
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_catalog_response_proc() DeviceListNum=%d, GBDeviceInfo:DeviceID=%s,CataLogNumCount=%d \r\n", iDeviceListNum, pGBDeviceInfo->device_id, pGBDeviceInfo->CataLogNumCount);
            }
            else if (EV9000_DEVICETYPE_SIPSERVER == pGBDeviceInfo->device_type && 1 == pGBDeviceInfo->three_party_flag) /* 如果是第三方平台，解析分组的情况下 */
            {
                if (pGBDeviceInfo->CataLogNumCount == 0)
                {
                    if (1 == g_AnalysisSubGroupFlag || 2 == g_AnalysisSubGroupFlag)
                    {
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 收到第一个响应报文, 设置该设备下面的分组信息以及分组关系信息删除标识", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Receive front-end equipment grouping information query response message the first message: the front-end device ID = % s, = % s IP address, port number = % d, set up the equipment the following grouping information delete logo", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

                        /* 设置逻辑设备分组信息修改标识为3，表示全部删除 */
                        i = SetLogicDeviceGroupChangeFlag(pGBDeviceInfo, 3);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_catalog_response_proc() SetLogicDeviceGroupChangeFlag:i=%d \r\n", i);

                        /* 设置逻辑设备分组关系信息修改标识为3，表示全部删除 */
                        i = SetLogicDeviceMapGroupChangeFlag(pGBDeviceInfo, 3);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_catalog_response_proc() SetLogicDeviceMapGroupChangeFlag:i=%d \r\n", i);
                    }
                }

                /* 上报个数统计 */
                pGBDeviceInfo->CataLogNumCount += iDeviceListNum;
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_catalog_response_proc() DeviceListNum=%d, GBDeviceInfo:DeviceID=%s,CataLogNumCount=%d \r\n", iDeviceListNum, pGBDeviceInfo->device_id, pGBDeviceInfo->CataLogNumCount);
            }
            else
            {
                /* 上报个数统计 */
                pGBDeviceInfo->CataLogNumCount += iDeviceListNum;
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_catalog_response_proc() DeviceListNum=%d, GBDeviceInfo:DeviceID=%s,CataLogNumCount=%d \r\n", iDeviceListNum, pGBDeviceInfo->device_id, pGBDeviceInfo->CataLogNumCount);
            }

            /* 获取所有的Item 数据 */
            ItemAccNode = inPacket.SearchElement((char*)"Item");

            if (!ItemAccNode)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_catalog_response_proc() exit---: Get Item Node Error \r\n");
                return -1;
            }

            inPacket.SetCurrentElement(ItemAccNode);

            while (ItemAccNode)
            {
                iItemNumCount++;

                if (iItemNumCount > iDeviceListNum)
                {
                    break;
                }

                memset(strDeviceIndex, 0, 64);
                inPacket.GetElementValue((char*)"ID", strDeviceIndex);

                memset(strGBLogicDeviceID, 0, 32);
                inPacket.GetElementValue((char*)"DeviceID", strGBLogicDeviceID);

                memset(strName, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"Name", strName);

                memset(strEnable, 0, 64);
                inPacket.GetElementValue((char*)"Enable", strEnable);

                memset(strAlarmDeviceSubType, 0, 64);
                inPacket.GetElementValue((char*)"ChlType", strAlarmDeviceSubType);

                memset(strCtrlEnable, 0, 64);
                inPacket.GetElementValue((char*)"CtrlEnable", strCtrlEnable);

                memset(strMicEnable, 0, 64);
                inPacket.GetElementValue((char*)"MicEnable", strMicEnable);

                memset(strFrameCount, 0, 64);
                inPacket.GetElementValue((char*)"FrameCount", strFrameCount);

                memset(strStreamCount, 0, 64);
                inPacket.GetElementValue((char*)"StreamCount", strStreamCount);

                memset(strAlarmLengthOfTime, 0, 64);
                inPacket.GetElementValue((char*)"AlarmLengthOfTime", strAlarmLengthOfTime);

                memset(strManufacturer, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"Manufacturer", strManufacturer);

                memset(strModel, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"Model", strModel);

                memset(strOwner, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"Owner", strOwner);

                memset(strCivilCode, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"CivilCode", strCivilCode);

                memset(strBlock, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"Block", strBlock);

                memset(strAddress, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"Address", strAddress);

                memset(strParental, 0, 16);
                inPacket.GetElementValue((char*)"Parental", strParental);

                memset(strParentID, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"ParentID", strParentID);

                memset(strSafetyWay, 0, 16);
                inPacket.GetElementValue((char*)"SafetyWay", strSafetyWay);

                memset(strRegisterWay, 0, 16);
                inPacket.GetElementValue((char*)"RegisterWay", strRegisterWay);

                memset(strCertNum, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"CertNum", strCertNum);

                memset(strCertifiable, 0, 16);
                inPacket.GetElementValue((char*)"Certifiable", strCertifiable);

                memset(strErrCode, 0, 16);
                inPacket.GetElementValue((char*)"ErrCode", strErrCode);

                memset(strEndTime, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"EndTime", strEndTime);

                memset(strSecrecy, 0, 16);
                inPacket.GetElementValue((char*)"Secrecy", strSecrecy);

                memset(strIPAddress, 0, 16);
                inPacket.GetElementValue((char*)"IPAddress", strIPAddress);

                memset(strPort, 0, 16);
                inPacket.GetElementValue((char*)"Port", strPort);

                memset(strPassword, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"Password", strPassword);

                memset(strStatus, 0, 16);
                inPacket.GetElementValue((char*)"Status", strStatus);

                memset(strLongitude, 0, 64);
                inPacket.GetElementValue((char*)"Longitude", strLongitude);

                memset(strLatitude, 0, 64);
                inPacket.GetElementValue((char*)"Latitude", strLatitude);

                memset(strMapLayer, 0, MAX_128CHAR_STRING_LEN + 4);
                inPacket.GetElementValue((char*)"MapLayer", strMapLayer);

                memset(strCMSID, 0, 24);
                inPacket.GetElementValue((char*)"CMSID", strCMSID);

                memset(strValue, 0, 256);
                inPacket.GetElementValue((char*)"Value", strValue);

                memset(strUnit, 0, 32);
                inPacket.GetElementValue((char*)"Unit", strUnit);

                memset(strAlarmPriority, 0, 32);
                inPacket.GetElementValue((char*)"AlarmPriority", strAlarmPriority);

                memset(strGuard, 0, 32);
                inPacket.GetElementValue((char*)"Guard", strGuard);

                memset(strPTZType, 0, 64);
                inPacket.GetElementValue((char*)"PTZType", strPTZType);

                /* 确定点位ID长度 */
                iDeviceIDLen = strlen(strGBLogicDeviceID);

                /* 确定逻辑点位设备类型 */
                if ('\0' != strGBLogicDeviceID[0])
                {
                    pTmp = &strGBLogicDeviceID[10];
                    memset(strDeviceType, 0, 4);
                    osip_strncpy(strDeviceType, pTmp, 3);
                    iDeviceType = osip_atoi(strDeviceType);
                }

                if (strGBLogicDeviceID[0] == '\0')
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备目录查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=上报的逻辑设备ID为空", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    ItemAccNode = inPacket.SearchNextElement(true);
                    continue;
                }

                if (2 == iDeviceIDLen || 4 == iDeviceIDLen || 6 == iDeviceIDLen || 8 == iDeviceIDLen || 10 == iDeviceIDLen) /* 行政区域编码 */
                {
                    if (1 == g_AnalysisSubGroupFlag || 2 == g_AnalysisSubGroupFlag)
                    {
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 逻辑设备ID长度=%d, 逻辑设备类型=%d, 上报的点位为行政区域机构组织编码", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName, iDeviceIDLen, iDeviceType);

                        if (EV9000_DEVICETYPE_SIPSERVER == pGBDeviceInfo->device_type && 1 == pGBDeviceInfo->three_party_flag)
                        {
                            /* 上报个数统计 */
                            pGBDeviceInfo->LogicDeviceGroupConfigCount += 1;
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_catalog_response_proc() LogicDeviceGroupConfigCount=%d \r\n", pGBDeviceInfo->LogicDeviceGroupConfigCount);

                            i = CivilCodeGBLogicDeviceCatalogInfoProc(pGBDeviceInfo, strGBLogicDeviceID, strName, strParentID, 1, pDevice_Srv_dboper, 0);

                            if (i < 0)
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_catalog_response_proc() CivilCodeGBLogicDeviceCatalogInfoProc ERROR:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                            }
                            else
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_catalog_response_proc() CivilCodeGBLogicDeviceCatalogInfoProc OK:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                            }
                        }
                    }
                    else
                    {
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 逻辑设备ID长度=%d, 逻辑设备类型=%d, 上报的点位为行政区域机构组织编码, 本地不解析", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName, iDeviceIDLen, iDeviceType);
                    }
                }
                else if (20 == iDeviceIDLen) /* 点位或者业务分组编码 */
                {
                    if (EV9000_DEVICETYPE_TRAFFIC_GROUP == iDeviceType || EV9000_DEVICETYPE_VIRTURAL_ORGAN == iDeviceType) /* 业务分组编码或者虚拟组织编码 */
                    {
                        if (2 == g_AnalysisSubGroupFlag)
                        {
                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 逻辑设备ID长度=%d, 逻辑设备类型=%d, 上报的点位为业务分组编码或者虚拟组织编码", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName, iDeviceIDLen, iDeviceType);

                            if (EV9000_DEVICETYPE_SIPSERVER == pGBDeviceInfo->device_type && 1 == pGBDeviceInfo->three_party_flag)
                            {
                                /* 上报个数统计 */
                                pGBDeviceInfo->LogicDeviceGroupConfigCount += 1;
                                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_catalog_response_proc() LogicDeviceGroupConfigCount=%d \r\n", pGBDeviceInfo->LogicDeviceGroupConfigCount);

                                i = GroupCodeGBLogicDeviceCatalogInfoProc(pGBDeviceInfo, strGBLogicDeviceID, strName, strParentID, 1, pDevice_Srv_dboper, 0);

                                if (i < 0)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_catalog_response_proc() GroupCodeGBLogicDeviceCatalogInfoProc ERROR:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_catalog_response_proc() GroupCodeGBLogicDeviceCatalogInfoProc OK:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                }
                            }
                        }
                        else
                        {
                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 逻辑设备ID长度=%d, 逻辑设备类型=%d, 上报的点位为业务分组编码或者虚拟组织编码, 本地不解析", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName, iDeviceIDLen, iDeviceType);
                        }
                    }
                    else
                    {
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 逻辑设备ID长度=%d, 逻辑设备类型=%d, 状态=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName, iDeviceIDLen, iDeviceType, strStatus);
                        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment directory query response message: report the logical device ID = % s, logical point name = % s, state = % s", strGBLogicDeviceID, strName, strStatus);

                        if (EV9000_DEVICETYPE_INTELLIGENTANALYSIS == pGBDeviceInfo->device_type)/* 智能行为分析设备,在原有逻辑设备信息里面添加智能分析物理设备信息即可 */
                        {
                            i = IntelligentAnalysisGBLogicDeviceCatalogInfoProc(pGBDeviceInfo, strGBLogicDeviceID, pDevice_Srv_dboper);
                        }
                        else
                        {
                            /* 查找旧的逻辑设备,看旧的逻辑设备是否是本级的逻辑设备 */
                            pOldGBLogicDeviceInfo = GBLogicDevice_info_find(strGBLogicDeviceID);

                            if (NULL != pOldGBLogicDeviceInfo && 1 == pOldGBLogicDeviceInfo->enable)
                            {
                                /* 如果是下级CMS上报的点位，查看是否有重复上报的点位 */
                                if (EV9000_DEVICETYPE_SIPSERVER == pGBDeviceInfo->device_type)
                                {
                                    pOldGBDeviceInfo = GBDevice_info_get_by_stream_type(pOldGBLogicDeviceInfo, EV9000_STREAM_TYPE_MASTER);

                                    if (NULL != pOldGBDeviceInfo && 1 == pOldGBDeviceInfo->reg_status)
                                    {
                                        if (0 != sstrcmp(pOldGBDeviceInfo->device_id, pGBDeviceInfo->device_id)) /* 两次上报的物理设备不一样 */
                                        {
                                            if (EV9000_DEVICETYPE_SIPSERVER != pOldGBDeviceInfo->device_type)
                                            {
                                                SystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 该逻辑设备是本级设备:ID=%s, IP=%s中的逻辑设备", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName, pOldGBDeviceInfo->device_id, pOldGBDeviceInfo->login_ip);
                                                EnSystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device directory search response message:logic device reported ID=%s, logic point name=%s, this logic device is the local level device ID=%s,IP=%s logic device", strGBLogicDeviceID, strName, pOldGBDeviceInfo->device_id, pOldGBDeviceInfo->login_ip);
                                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_catalog_response_proc() exit---: GBLogic Device ID=%s, is My Device: ID=%s, IP=%s Logic Device \r\n", strGBLogicDeviceID, pOldGBDeviceInfo->device_id, pOldGBDeviceInfo->login_ip);
                                                ItemAccNode = inPacket.SearchNextElement(true);
                                                continue;
                                            }
                                            else
                                            {
                                                SystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 该逻辑设备是另外一个下级CMS平台:ID=%s, IP=%s中的逻辑设备", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName, pOldGBDeviceInfo->device_id, pOldGBDeviceInfo->login_ip);
                                                EnSystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device directory search response message:logic device reported ID=%s, logic point name=%s, this logic device is the local level device ID=%s,IP=%s logic device", strGBLogicDeviceID, strName, pOldGBDeviceInfo->device_id, pOldGBDeviceInfo->login_ip);
                                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_catalog_response_proc() exit---: GBLogic Device ID=%s, is My Device: ID=%s, IP=%s Logic Device \r\n", strGBLogicDeviceID, pOldGBDeviceInfo->device_id, pOldGBDeviceInfo->login_ip);
                                                ItemAccNode = inPacket.SearchNextElement(true);
                                                continue;
                                            }
                                        }
                                    }
                                }
                            }

                            /* 将信息写入新的结构 */
                            i = GBLogicDevice_info_init(&pNewGBLogicDeviceInfo);

                            if (i != 0)
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_catalog_response_proc() exit---: GBLogicDevice Info Init Error \r\n");
                                ItemAccNode = inPacket.SearchNextElement(true);
                                continue;
                            }

                            /* 点位统一编号 */
                            if (strGBLogicDeviceID[0] != '\0')
                            {
                                osip_strncpy(pNewGBLogicDeviceInfo->device_id, strGBLogicDeviceID, MAX_ID_LEN);
                            }

                            /* 逻辑设备索引 */
                            if (strDeviceIndex[0] != '\0')
                            {
                                pNewGBLogicDeviceInfo->id = strtoul(strDeviceIndex, NULL, 10);
                            }
                            else
                            {
                                if ('\0' != pNewGBLogicDeviceInfo->device_id[0])
                                {
                                    pNewGBLogicDeviceInfo->id = crc32((unsigned char*)pNewGBLogicDeviceInfo->device_id, MAX_ID_LEN);
                                }
                            }

                            /* 所属的CMS统一编号，如果是下级CMS上报的，则存在该数据，如果是具体物理设备，填本级CMSID */
                            if (strCMSID[0] != '\0')
                            {
                                osip_strncpy(pNewGBLogicDeviceInfo->cms_id, strCMSID, MAX_ID_LEN);
                            }
                            else
                            {
                                osip_strncpy(pNewGBLogicDeviceInfo->cms_id, local_cms_id_get(), MAX_ID_LEN);
                            }

                            /* 点位名称 */
                            if (strName[0] != '\0')
                            {
                                osip_strncpy(pNewGBLogicDeviceInfo->device_name, strName, MAX_128CHAR_STRING_LEN);
                            }

                            /* 设备类型 */
                            if (iDeviceType > 0)
                            {
                                pNewGBLogicDeviceInfo->device_type = iDeviceType;
                            }
                            else
                            {
                                pNewGBLogicDeviceInfo->device_type = EV9000_DEVICETYPE_IPC;
                            }

                            /* 是否启用 */
                            if (strEnable[0] != '\0')
                            {
                                pNewGBLogicDeviceInfo->enable = osip_atoi(strEnable);
                            }
                            else
                            {
                                pNewGBLogicDeviceInfo->enable = 1;
                            }

                            /* 是否可控 */
                            if (strPTZType[0] != '\0') /* 国标新增扩展协议, 1-球机；2-半球；3-固定枪机； 4-遥控枪机 */
                            {
                                iPTZType = osip_atoi(strPTZType);

                                pNewGBLogicDeviceInfo->ctrl_enable = iPTZType;
                            }
                            else
                            {
                                if (strCtrlEnable[0] != '\0')
                                {
                                    if (0 == sstrcmp((char*)"Disable", strCtrlEnable))
                                    {
                                        pNewGBLogicDeviceInfo->ctrl_enable = 0;
                                    }
                                    else if (0 == sstrcmp((char*)"Enable", strCtrlEnable))
                                    {
                                        pNewGBLogicDeviceInfo->ctrl_enable = 1;
                                    }
                                    else
                                    {
                                        pNewGBLogicDeviceInfo->ctrl_enable = 0;
                                    }
                                }
                                else
                                {
                                    pNewGBLogicDeviceInfo->ctrl_enable = 0;
                                }
                            }

                            /* 是否支持对讲 */
                            if (strMicEnable[0] != '\0')
                            {
                                if (0 == sstrcmp((char*)"Disable", strMicEnable))
                                {
                                    pNewGBLogicDeviceInfo->mic_enable = 0;
                                }
                                else if (0 == sstrcmp((char*)"Enable", strMicEnable))
                                {
                                    pNewGBLogicDeviceInfo->mic_enable = 1;
                                }
                                else
                                {
                                    pNewGBLogicDeviceInfo->mic_enable = 0;
                                }
                            }
                            else
                            {
                                pNewGBLogicDeviceInfo->mic_enable = 0;
                            }

                            /* 帧率 */
                            if (strFrameCount[0] != '\0')
                            {
                                pNewGBLogicDeviceInfo->frame_count = osip_atoi(strFrameCount);
                            }
                            else
                            {
                                pNewGBLogicDeviceInfo->frame_count = 25;
                            }

                            /* 是否支持多码流 */
                            if (strStreamCount[0] != '\0')
                            {
                                pNewGBLogicDeviceInfo->stream_count = osip_atoi(strStreamCount);
                            }
                            else
                            {
                                if (pNewGBLogicDeviceInfo->device_type == EV9000_DEVICETYPE_CAMERA
                                    || pNewGBLogicDeviceInfo->device_type == EV9000_DEVICETYPE_IPC
                                    || pNewGBLogicDeviceInfo->device_type == EV9000_DEVICETYPE_SCREEN
                                    || pNewGBLogicDeviceInfo->device_type == EV9000_DEVICETYPE_CODER)
                                {
                                    pNewGBLogicDeviceInfo->stream_count = 1;
                                }
                                else
                                {
                                    pNewGBLogicDeviceInfo->stream_count = 0;
                                }
                            }

                            /* 帧率 */
                            if (strAlarmLengthOfTime[0] != '\0')
                            {
                                pNewGBLogicDeviceInfo->alarm_duration = osip_atoi(strAlarmLengthOfTime);
                            }
                            else
                            {
                                pNewGBLogicDeviceInfo->alarm_duration = 0;
                            }

                            /* 是否属于其他域 */
                            pNewGBLogicDeviceInfo->other_realm = 0;

                            /* 对应的媒体物理设备索引 */
                            pNewGBLogicDeviceInfo->phy_mediaDeviceIndex = pGBDeviceInfo->id;

                            /* 对应的媒体物理设备通道 */
                            pNewGBLogicDeviceInfo->phy_mediaDeviceChannel = iItemNumCount - 1;

                            /* 对应的控制物理设备索引 */
                            pNewGBLogicDeviceInfo->phy_ctrlDeviceIndex = pGBDeviceInfo->id;

                            /* 对应的控制物理设备通道 */
                            pNewGBLogicDeviceInfo->phy_ctrlDeviceChannel = iItemNumCount - 1;

                            /* 设备生产商 */
                            if (strManufacturer[0] != '\0')
                            {
                                osip_strncpy(pNewGBLogicDeviceInfo->manufacturer, strManufacturer, MAX_128CHAR_STRING_LEN);
                            }

                            /* 设备型号 */
                            if (strModel[0] != '\0')
                            {
                                osip_strncpy(pNewGBLogicDeviceInfo->model, strModel, MAX_128CHAR_STRING_LEN);
                            }

                            /* 设备归属 */
                            if (strOwner[0] != '\0')
                            {
                                osip_strncpy(pNewGBLogicDeviceInfo->owner, strOwner, MAX_128CHAR_STRING_LEN);
                            }

#if 0

                            /* 行政区域 */
                            if (strCivilCode[0] != '\0')
                            {
                                if (StringIsAllDigit(strCivilCode))
                                {
                                    if (CivilCodeIsMatchLocalCivilCode(strCivilCode)) /* 如果为全数字，判断是否和本地分组code一致，可能有的摄像机带的错误的编码 */
                                    {
                                        pNewGBLogicDeviceInfo->civil_code = osip_getcopy(strCivilCode);
                                    }
                                    else
                                    {
                                        tmp_civil_code = GetGBLogicDeviceCivilCode(pNewGBLogicDeviceInfo->id, pDevice_Srv_dboper);

                                        if (NULL != tmp_civil_code)
                                        {
                                            pNewGBLogicDeviceInfo->civil_code = osip_getcopy(tmp_civil_code);
                                        }
                                        else
                                        {
                                            pNewGBLogicDeviceInfo->civil_code = osip_getcopy(local_civil_code_get());
                                        }
                                    }
                                }
                                else
                                {
                                    tmp_civil_code = GetGBLogicDeviceCivilCode(pNewGBLogicDeviceInfo->id, pDevice_Srv_dboper);

                                    if (NULL != tmp_civil_code)
                                    {
                                        pNewGBLogicDeviceInfo->civil_code = osip_getcopy(tmp_civil_code);
                                    }
                                    else
                                    {
                                        pNewGBLogicDeviceInfo->civil_code = osip_getcopy(local_civil_code_get());
                                    }
                                }
                            }
                            else
                            {
                                tmp_civil_code = GetGBLogicDeviceCivilCode(pNewGBLogicDeviceInfo->id, pDevice_Srv_dboper);

                                if (NULL != tmp_civil_code)
                                {
                                    pNewGBLogicDeviceInfo->civil_code = osip_getcopy(tmp_civil_code);
                                }
                                else
                                {
                                    pNewGBLogicDeviceInfo->civil_code = osip_getcopy(local_civil_code_get());
                                }
                            }

#endif

                            /* 警区 */
                            if (strBlock[0] != '\0')
                            {
                                osip_strncpy(pNewGBLogicDeviceInfo->block, strBlock, MAX_128CHAR_STRING_LEN);
                            }

                            /* 安装地址 */
                            if (strAddress[0] != '\0')
                            {
                                osip_strncpy(pNewGBLogicDeviceInfo->address, strAddress, MAX_128CHAR_STRING_LEN);
                            }

                            /* 是否有子设备 */
                            if (strParental[0] != '\0')
                            {
                                pNewGBLogicDeviceInfo->parental = osip_atoi(strParental);
                            }

                            /* 父设备/区域/系统ID */
                            if (strParentID[0] != '\0')
                            {
                                osip_strncpy(pNewGBLogicDeviceInfo->parentID, strParentID, MAX_128CHAR_STRING_LEN);
                            }

                            /* 信令安全模式*/
                            if (strSafetyWay[0] != '\0')
                            {
                                pNewGBLogicDeviceInfo->safety_way = osip_atoi(strSafetyWay);
                            }

                            /* 注册方式 */
                            if (strRegisterWay[0] != '\0')
                            {
                                pNewGBLogicDeviceInfo->register_way = osip_atoi(strRegisterWay);
                            }

                            /* 证书序列号*/
                            if (strCertNum[0] != '\0')
                            {
                                osip_strncpy(pNewGBLogicDeviceInfo->cert_num, strCertNum, MAX_128CHAR_STRING_LEN);
                            }

                            /* 证书有效标识 */
                            if (strCertifiable[0] != '\0')
                            {
                                pNewGBLogicDeviceInfo->certifiable = osip_atoi(strCertifiable);
                            }

                            /* 无效原因码 */
                            if (strErrCode[0] != '\0')
                            {
                                pNewGBLogicDeviceInfo->error_code = osip_atoi(strErrCode);
                            }

                            /* 证书终止有效期*/
                            if (strEndTime[0] != '\0')
                            {
                                osip_strncpy(pNewGBLogicDeviceInfo->end_time, strEndTime, MAX_128CHAR_STRING_LEN);
                            }

                            /* 保密属性 */
                            if (strSecrecy[0] != '\0')
                            {
                                pNewGBLogicDeviceInfo->secrecy = osip_atoi(strSecrecy);
                            }

                            /* IP地址*/
                            if (strIPAddress[0] != '\0')
                            {
                                osip_strncpy(pNewGBLogicDeviceInfo->ip_address, strIPAddress, MAX_IP_LEN);
                            }
                            else
                            {
                                osip_strncpy(pNewGBLogicDeviceInfo->ip_address, pGBDeviceInfo->login_ip, MAX_IP_LEN);
                            }

                            /* 端口号*/
                            if (strPort[0] != '\0')
                            {
                                pNewGBLogicDeviceInfo->port = osip_atoi(strPort);
                            }
                            else
                            {
                                pNewGBLogicDeviceInfo->port = 0;
                            }

                            /* 密码*/
                            if (strPassword[0] != '\0')
                            {
                                osip_strncpy(pNewGBLogicDeviceInfo->password, strPassword, MAX_128CHAR_STRING_LEN);
                            }

                            /* 点位状态 */
                            if (strStatus[0] != '\0' && (0 == sstrcmp(strStatus, (char*)"ON") || 0 == sstrcmp(strStatus, (char*)"ONLINE")))
                            {
                                pNewGBLogicDeviceInfo->status = 1;
                            }
                            else if (strStatus[0] != '\0' && (0 == sstrcmp(strStatus, (char*)"OFF") || 0 == sstrcmp(strStatus, (char*)"OFFLINE")))
                            {
                                pNewGBLogicDeviceInfo->status = 0;
                                pNewGBLogicDeviceInfo->intelligent_status = INTELLIGENT_STATUS_NULL;
                                pNewGBLogicDeviceInfo->alarm_status = ALARM_STATUS_NULL;
                            }
                            else if (strStatus[0] != '\0' && 0 == sstrcmp(strStatus, (char*)"NOVIDEO"))
                            {
                                pNewGBLogicDeviceInfo->status = 2;
                            }
                            else if (strStatus[0] != '\0' && 0 == sstrcmp(strStatus, (char*)"VLOST"))
                            {
                                pNewGBLogicDeviceInfo->status = 2;
                            }
                            else if (strStatus[0] != '\0' && 0 == sstrcmp(strStatus, (char*)"INTELLIGENT"))
                            {
                                pNewGBLogicDeviceInfo->status = 1;
                                pNewGBLogicDeviceInfo->intelligent_status = INTELLIGENT_STATUS_ON;
                            }
                            else if (strStatus[0] != '\0' && 0 == sstrcmp(strStatus, (char*)"CLOSE"))
                            {
                                pNewGBLogicDeviceInfo->status = 1;
                                pNewGBLogicDeviceInfo->alarm_status = ALARM_STATUS_CLOSE;
                            }
                            else if (strStatus[0] != '\0' && 0 == sstrcmp(strStatus, (char*)"APART"))
                            {
                                pNewGBLogicDeviceInfo->status = 1;
                                pNewGBLogicDeviceInfo->alarm_status = ALARM_STATUS_APART;
                            }
                            else
                            {
                                pNewGBLogicDeviceInfo->status = 0;
                            }

                            /* 经度 */
                            if (strLongitude[0] != '\0')
                            {
                                pNewGBLogicDeviceInfo->longitude = strtod(strLongitude, (char**) NULL);
                            }

                            /* 纬度 */
                            if (strLatitude[0] != '\0')
                            {
                                pNewGBLogicDeviceInfo->latitude = strtod(strLatitude, (char**) NULL);
                            }

                            /* 所属图层 */
                            if (strMapLayer[0] != '\0')
                            {
                                osip_strncpy(pNewGBLogicDeviceInfo->map_layer, strMapLayer, MAX_128CHAR_STRING_LEN);
                            }

                            /* 报警设备子类型 */
                            if (strAlarmDeviceSubType[0] != '\0')
                            {
                                pNewGBLogicDeviceInfo->alarm_device_sub_type = osip_atoi(strAlarmDeviceSubType);
                            }
                            else
                            {
                                pNewGBLogicDeviceInfo->alarm_device_sub_type = 0;
                            }

                            /* 报警级别 */
                            if (strAlarmPriority[0] != '\0')
                            {
                                pNewGBLogicDeviceInfo->AlarmPriority = osip_atoi(strAlarmPriority);
                            }

                            /* Guard*/
                            if (strGuard[0] != '\0')
                            {
                                pNewGBLogicDeviceInfo->guard_type = osip_atoi(strGuard);
                            }

                            /* 单位 */
                            if (strUnit[0] != '\0')
                            {
                                osip_strncpy(pNewGBLogicDeviceInfo->Unit, strUnit, 32);
                            }

                            /* Value */
                            if (strValue[0] != '\0')
                            {
                                osip_strncpy(pNewGBLogicDeviceInfo->Value, strValue, 256);
                            }

                            i = GBDevice_add(pNewGBLogicDeviceInfo, EV9000_STREAM_TYPE_MASTER, pGBDeviceInfo);

                            if (i < 0)
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_catalog_response_proc() GBDevice_add:device_id=%s, stream_type=EV9000_STREAM_TYPE_MASTER Error:i=%d \r\n", pNewGBLogicDeviceInfo->device_id, i);
                            }
                            else
                            {
                                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_query_catalog_response_proc() GBDevice_add:device_id=%s, stream_type=EV9000_STREAM_TYPE_MASTER OK:i=%d \r\n", pNewGBLogicDeviceInfo->device_id, i);
                            }

                            /* 根据旧的逻辑设备是否存在判断 */
                            if (NULL != pOldGBLogicDeviceInfo)
                            {
                                if (EV9000_DEVICETYPE_DECODER == pGBDeviceInfo->device_type)
                                {
                                    if (1 == pOldGBLogicDeviceInfo->del_mark)
                                    {
                                        /* 移除删除标识 */
                                        pOldGBLogicDeviceInfo->del_mark = 0;
                                    }
                                }

                                /* 海康NVR携带的Status都是写死的，先不处理状态，需要发送查询状态信息 */
                                if (EV9000_DEVICETYPE_DVR == pGBDeviceInfo->device_type
                                    || EV9000_DEVICETYPE_NVR  == pGBDeviceInfo->device_type)
                                {
                                    if (0 == sstrcmp(pGBDeviceInfo->manufacturer, (char*)"HIKVISION")
                                        || 0 == sstrcmp(pGBDeviceInfo->manufacturer, (char*)"Hikvision"))
                                    {
                                        pNewGBLogicDeviceInfo->status = pOldGBLogicDeviceInfo->status;
                                        pNewGBLogicDeviceInfo->intelligent_status = pOldGBLogicDeviceInfo->intelligent_status;
                                        pNewGBLogicDeviceInfo->alarm_status = pOldGBLogicDeviceInfo->alarm_status;
                                    }
                                }

                                i = GBLogicDeviceCatalogInfoProc(pGBDeviceInfo, pNewGBLogicDeviceInfo, pOldGBLogicDeviceInfo, pDevice_Srv_dboper);

                                if (i < 0)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_catalog_response_proc() GBLogicDeviceCatalogInfoProc Error:i=%d \r\n", i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_catalog_response_proc() GBLogicDeviceCatalogInfoProc:iRet=%d \r\n", i);
                                }

                                /* 处理分组关系 */
                                if (EV9000_DEVICETYPE_SIPSERVER == pGBDeviceInfo->device_type && 1 == pGBDeviceInfo->three_party_flag)
                                {
                                    if (1 == g_AnalysisSubGroupFlag) /* 只解析行政区域编码 */
                                    {
                                        /* 行政区域 */
                                        i = GBLogicDeviceCatalogGroupMapProc(pGBDeviceInfo, pNewGBLogicDeviceInfo, strCivilCode, pDevice_Srv_dboper, 0);
                                    }
                                    else if (2 == g_AnalysisSubGroupFlag) /* 解析业务分组编码 */
                                    {
                                        /* 父设备/区域/系统ID */
                                        if (strParentID[0] != '\0')
                                        {
                                            if (0 == strcmp(strParentID, pGBDeviceInfo->device_id)) /* 如果父节点是平台ID，则还以行政区域编码为准 */
                                            {
                                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 携带的ParentID是下级平台的服务器ID,默认使用CivilCode作为分组依据", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName);

                                                /* 行政区域 */
                                                i = GBLogicDeviceCatalogGroupMapProc(pGBDeviceInfo, pNewGBLogicDeviceInfo, strCivilCode, pDevice_Srv_dboper, 0);
                                            }
                                            else
                                            {
                                                i = GBLogicDeviceCatalogGroupMapProc(pGBDeviceInfo, pNewGBLogicDeviceInfo, strParentID, pDevice_Srv_dboper, 0);
                                            }
                                        }
                                        else
                                        {
                                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 携带的ParentID是空,默认使用CivilCode作为分组依据", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName);

                                            /* 行政区域 */
                                            i = GBLogicDeviceCatalogGroupMapProc(pGBDeviceInfo, pNewGBLogicDeviceInfo, strCivilCode, pDevice_Srv_dboper, 0);
                                        }
                                    }
                                }

                                GBLogicDevice_info_free(pNewGBLogicDeviceInfo);
                                osip_free(pNewGBLogicDeviceInfo);
                                pNewGBLogicDeviceInfo = NULL;
                            }
                            else
                            {
                                /* 添加逻辑设备信息 */
                                logic_device_pos = GBLogicDevice_info_add(pNewGBLogicDeviceInfo);

                                //DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_catalog_response_proc() GBLogicDevice_info_add:logic_device_pos=%d \r\n", logic_device_pos);

                                if (logic_device_pos < 0)
                                {
                                    GBLogicDevice_info_free(pNewGBLogicDeviceInfo);
                                    osip_free(pNewGBLogicDeviceInfo);
                                    pNewGBLogicDeviceInfo = NULL;
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_catalog_response_proc() exit---: GBLogicDevice Info Add Error \r\n");
                                    ItemAccNode = inPacket.SearchNextElement(true);
                                    continue;
                                }

                                /* 发送Catalog变化通知消息  */
                                i = SendNotifyCatalogMessageToAllRoute(pNewGBLogicDeviceInfo, 0, pDevice_Srv_dboper);

                                if (i < 0)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_catalog_response_proc() SendNotifyCatalogMessageToAllRoute Error:iRet=%d \r\n", i);
                                }
                                else if (i > 0)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_catalog_response_proc() SendNotifyCatalogMessageToAllRoute OK:iRet=%d \r\n", i);
                                }

                                /* 更新数据库 */
                                i = AddGBLogicDeviceInfo2DB(strGBLogicDeviceID, pDevice_Srv_dboper);

                                if (i < 0)
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_catalog_response_proc() AddGBLogicDeviceInfo2DB ERROR:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                }
                                else
                                {
                                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_catalog_response_proc() AddGBLogicDeviceInfo2DB OK:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                }

                                /* 处理分组关系 */
                                if (EV9000_DEVICETYPE_SIPSERVER == pGBDeviceInfo->device_type && 1 == pGBDeviceInfo->three_party_flag)
                                {
                                    if (1 == g_AnalysisSubGroupFlag) /* 只解析行政区域编码 */
                                    {
                                        /* 行政区域 */
                                        i = GBLogicDeviceCatalogGroupMapProc(pGBDeviceInfo, pNewGBLogicDeviceInfo, strCivilCode, pDevice_Srv_dboper, 0);
                                    }
                                    else if (2 == g_AnalysisSubGroupFlag) /* 解析业务分组编码 */
                                    {
                                        /* 父设备/区域/系统ID */
                                        if (strParentID[0] != '\0')
                                        {
                                            if (0 == strcmp(strParentID, pGBDeviceInfo->device_id)) /* 如果父节点是平台ID，则还以行政区域编码为准 */
                                            {
                                                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 携带的ParentID是下级平台的服务器ID,默认使用CivilCode作为分组依据", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName);

                                                /* 行政区域 */
                                                i = GBLogicDeviceCatalogGroupMapProc(pGBDeviceInfo, pNewGBLogicDeviceInfo, strCivilCode, pDevice_Srv_dboper, 0);
                                            }
                                            else
                                            {
                                                i = GBLogicDeviceCatalogGroupMapProc(pGBDeviceInfo, pNewGBLogicDeviceInfo, strParentID, pDevice_Srv_dboper, 0);
                                            }
                                        }
                                        else
                                        {
                                            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 携带的ParentID是空,默认使用CivilCode作为分组依据", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName);

                                            /* 行政区域 */
                                            i = GBLogicDeviceCatalogGroupMapProc(pGBDeviceInfo, pNewGBLogicDeviceInfo, strCivilCode, pDevice_Srv_dboper, 0);
                                        }
                                    }
                                }
                            }

                            /* 海康NVR携带的Status都是写死的，需要发送查询状态信息 */
                            if (EV9000_DEVICETYPE_DVR == pGBDeviceInfo->device_type
                                || EV9000_DEVICETYPE_NVR  == pGBDeviceInfo->device_type)
                            {
                                if (0 == sstrcmp(pGBDeviceInfo->manufacturer, (char*)"HIKVISION")
                                    || 0 == sstrcmp(pGBDeviceInfo->manufacturer, (char*)"Hikvision"))
                                {
                                    i = SendQueryGBLogicDeviceStatusMessage(strGBLogicDeviceID, pGBDeviceInfo);

                                    if (i < 0)
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_catalog_response_proc() SendQueryGBLogicDeviceStatusMessage ERROR:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                    }
                                    else
                                    {
                                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_catalog_response_proc() SendQueryGBLogicDeviceStatusMessage OK:device_id=%s, iRet=%d \r\n", strGBLogicDeviceID, i);
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    SystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_WARNING, "前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的逻辑设备ID=%s, 逻辑点位名称=%s, 逻辑设备ID长度不合法, 逻辑设备ID长度=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID, strName, strlen(strGBLogicDeviceID));
                    EnSystemLog(EV9000_CMS_NOTIFY_CATALOG_ERROR, EV9000_LOG_LEVEL_WARNING, "Front-end device directory search response message:logic device ID=%s,logic point name=%s, logic device ID length is not valid, logic device ID length=%d", strGBLogicDeviceID, strName, strlen(strGBLogicDeviceID));
                }

                ItemAccNode = inPacket.SearchNextElement(true);
            }

            if (EV9000_DEVICETYPE_DECODER == pGBDeviceInfo->device_type
                || EV9000_DEVICETYPE_INTELLIGENTANALYSIS  == pGBDeviceInfo->device_type)
            {
                /* 上报结束，清零 */
                if (pGBDeviceInfo->CataLogNumCount >= iSumNum)
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "收到前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 收到最后一个报文, 开始根据删除标识删除该物理设备下面的通道", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment directory query response message: start according to delete logo to remove the physical device the following passage, and the front-end device ID = % s", pGBDeviceInfo->device_id);
                    pGBDeviceInfo->CataLogNumCount = 0;

                    /* 根据删除标识，设置逻辑设备禁用标识 */
                    i = SetGBLogicDeviceInfoEnableFlagByDelMark(pGBDeviceInfo, pDevice_Srv_dboper);
                }
            }
            else if (EV9000_DEVICETYPE_SIPSERVER == pGBDeviceInfo->device_type && 1 == pGBDeviceInfo->three_party_flag) /* 如果是第三方平台，解析分组的情况下 */
            {
                /* 上报结束，清零 */
                if (pGBDeviceInfo->CataLogNumCount >= iSumNum)
                {
                    if (1 == g_AnalysisSubGroupFlag || 2 == g_AnalysisSubGroupFlag)
                    {
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "收到前端设备目录查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 收到最后一个报文, 收到的分组信息数=%d, 根据分组信息删除标识同步掉多余的分组信息以及分组关系信息", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, pGBDeviceInfo->LogicDeviceGroupConfigCount);
                        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Receive front-end equipment grouping information query response message last message: ID = % s front-end equipment, IP address = % s, port = % d, according to the grouping information delete logo synchronous off excess group", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        pGBDeviceInfo->LogicDeviceGroupConfigCount = 0;
                        pGBDeviceInfo->CataLogNumCount = 0;

                        /* 将变化同步到数据库 */
                        i = SynLogicDeviceGroupInfoToDB(pGBDeviceInfo, pDevice_Srv_dboper);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_catalog_response_proc() SynLogicDeviceGroupInfoToDB:i=%d \r\n", i);

                        /* 删除内存中多余的信息 */
                        i = DelLogicDeviceGroupInfo(pGBDeviceInfo);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_catalog_response_proc() SynLogicDeviceGroupInfoToDB:i=%d \r\n", i);

                        /* 将变化同步到数据库 */
                        i = SynLogicDeviceMapGroupInfoToDB(pGBDeviceInfo, pDevice_Srv_dboper);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_catalog_response_proc() SynLogicDeviceMapGroupInfoToDB:i=%d \r\n", i);

                        /* 删除内存中多余的信息 */
                        i = DelLogicDeviceMapGroupInfo(pGBDeviceInfo);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_catalog_response_proc() DelLogicDeviceMapGroupInfo:i=%d \r\n", i);

                        if (!checkRoutIfHasSendCataProc())
                        {
                            /* 设置逻辑设备分组配置信息数据库更新操作标识 */
                            i = GBLogicDeviceGroupInfoConfig_db_refresh_proc();
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_catalog_response_proc() GBLogicDeviceGroupInfoConfig_db_refresh_proc:i=%d \r\n", i);

                            /* 设置逻辑设备分组关系配置信息数据库更新操作标识 */
                            i = GBLogicDeviceGroupMapInfoConfig_db_refresh_proc();
                            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_catalog_response_proc() GBLogicDeviceGroupMapInfoConfig_db_refresh_proc:i=%d \r\n", i);
                        }
                        else
                        {
                            DEBUG_TRACE(MODULE_DEVICE, LOG_WARN,  "device_query_catalog_response_proc() Has Route Send Catalog Proc \r\n");
                        }
                    }
                }
            }

            /* 设置获取逻辑通道的获取状态 */
            if (pGBDeviceInfo->CataLogNumCount >= iSumNum)
            {
                if (2 == pGBDeviceInfo->iGetCataLogStatus)
                {
                    pGBDeviceInfo->iGetCataLogStatus = 1;
                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_catalog_response_proc() GBDeviceInfo:DeviceID=%s,GetCataLogStatus=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->iGetCataLogStatus);
                }
            }
        }
    }

    return i;
}

/*****************************************************************************
 函 数 名  : user_device_info_response_proc
 功能描述  : 用户设备设备信息查询响应处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月13日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_device_info_response_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    int xml_pos = -1;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strResult[32] = {0};
    char strDeviceType[32] = {0};
    char strManufacturer[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strModel[32] = {0};
    char strFirmware[128] = {0};
    char strMaxCamera[16] = {0};
    char strMaxAlarm[16] = {0};
    char strOwnerFlag[16] = {0};
    char strTransProtocol[16] = {0};
    unsigned int transfer_xml_sn = 0;

    GBDevice_cfg_t GBDevice_cfg;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_device_info_response_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_device_info_response_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 网络设备信息查询响应消息直接转发，不做处理
          控制流程见9.5.2

          命令包括如下字段:
          <!-- 命令类型：设备信息查询（必选） -->
          <element name="CmdType" fixed ="DeviceInfo" />
          <!-- 命令序列号（必选） -->
          <element name="SN" type="integer" minInclusive value = "1" />
          <!-- 目标设备的设备编码（必选） -->
          <element name="DeviceID" type="tg:deviceIDType" />
          <!-- 查询结果（必选） -->
          <element name="Result" type="tg:resultType" />
          <!-- 设备生产商（可选） -->
          <element name ="Manufacturer" type="normalizedString" minOccurs= "0"/ >
          <!-- 设备型号（可选） -->
          <element name ="Model" type="string" minOccurs= "0"/>
          <!-- 设备固件版本（可选） -->
          <element name ="Firmware" type="string" minOccurs= "0"/>
          <!-- 视频输入通道数（可选） -->
          <element name ="Channel" type="integer" minInclusive value = "0" minOccurs= "0"/ >
          <!-- 扩展信息，可多项 -->
          <element name= "Info" minOccurs= "0" maxOccurs="unbounded">
          <restriction base= "string">
          <maxLength value= "1024" />
          </restriction>
          </element>
      */

    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end device information query response message: ID = % s front-end equipment, IP address = % s, port = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

    /* 看看是否是用户查询或者上级查询的 */
    transfer_xml_sn = strtoul(strSN, NULL, 10);
    xml_pos = transfer_xml_msg_find(XML_QUERY_DEVICEINFO, strDeviceID, transfer_xml_sn);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_device_info_response_proc() transfer_xml_msg_find:Type=%d, DeviceID=%s, transfer_xml_sn=%d, xml_pos=%d \r\n", XML_QUERY_RECORDINFO, strDeviceID, transfer_xml_sn, xml_pos);

    if (xml_pos >= 0)
    {
        i = transfer_xml_message_to_dest(xml_pos, 0, 0, inPacket);

        if (i != 0)
        {
            SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=根据XML的SN转发给目的地失败, xml_pos=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device info information query response message process failed:front-end device ID=%s:front-end device ID=%s, cause=forward to destination failed accorrding to XML SN", caller_id);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_info_response_proc() transfer_xml_message_to_dest Error:device_id=%s\r\n", caller_id);
        }
        else
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备录像信息查询响应消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d,根据XML的SN转发给目的地, xml_pos=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment video information query response message processing success: the front-end device ID = % s, = % s IP address, port number = % d, according to the XML SN forwarded to destination, xml_pos = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_info_response_proc() transfer_xml_message_to_dest OK:device_id=%s\r\n", caller_id);
        }
    }
    /* 查看被叫是否是本CMS ID */
    else if (0 == strncmp(callee_id, local_cms_id_get(), 20))
    {
        /* 设备信息一般是设备注册成功之后CMS主动发起的查询 */
        inPacket.GetElementValue((char*)"Result", strResult);
        inPacket.GetElementValue((char*)"DeviceType", strDeviceType);
        inPacket.GetElementValue((char*)"Manufacturer", strManufacturer);
        inPacket.GetElementValue((char*)"Model", strModel);
        inPacket.GetElementValue((char*)"Firmware", strFirmware);
        inPacket.GetElementValue((char*)"MaxCamera", strMaxCamera);
        inPacket.GetElementValue((char*)"MaxAlarm", strMaxAlarm);
        inPacket.GetElementValue((char*)"OwnerFlag", strOwnerFlag);
        inPacket.GetElementValue((char*)"TransProtocol", strTransProtocol);

        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_device_info_response_proc() \
        \r\n XML Para: \
        \r\n SN=%s \
        \r\n DeviceID=%s \
        \r\n Result=%s \
        \r\n DeviceType=%s \
        \r\n Manufacturer=%s \
        \r\n Model=%s \
        \r\n Firmware=%s \
        \r\n MaxCamera=%s \
        \r\n MaxAlarm=%s \
        \r\n TransProtocol=%s \
        \r\n OwnerFlag=%s \r\n", strSN, strDeviceID, strResult, strDeviceType, strManufacturer, strModel, strFirmware, strMaxCamera, strMaxAlarm, strTransProtocol, strOwnerFlag);

        if (0 != sstrcmp(caller_id, strDeviceID))
        {
            SystemLog(EV9000_CMS_GET_DEVICE_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备信息查询响应消息处理失败:前端设备ID=%s, 原因=XML中的DeviceID不匹配, DeviceID=%s", caller_id, strDeviceID);
            EnSystemLog(EV9000_CMS_GET_DEVICE_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device info search response message process failed:front-end deviceID=%s, cause=DeviceID in XML do not match, DeviceID=%s", caller_id, strDeviceID);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_device_info_response_proc() exit---: Caller ID Error: DeviceID=%s \r\n", strDeviceID);
            return -1;
        }

        /* 查看状态 */
        if (strResult[0] == '\0' || 0 != sstrcmp(strResult, "OK"))
        {
            SystemLog(EV9000_CMS_GET_DEVICE_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备信息查询响应消息处理失败:前端设备ID=%s, 原因=XML中的结果失败, Result=%s", caller_id, strResult);
            EnSystemLog(EV9000_CMS_GET_DEVICE_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device info search response message process failed:front-end deviceID=%s, cause =XML result failed, Result=%s", caller_id, strResult);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_device_info_response_proc() exit---: Result Error \r\n");
            return -1;
        }

        if (0 != sstrcmp(strDeviceID, pGBDeviceInfo->device_id))
        {
            SystemLog(EV9000_CMS_GET_DEVICE_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备信息查询响应消息处理失败:前端设备ID=%s, 原因=前端设备的XML里面的设备ID错误, XML设备ID=%s", caller_id, strDeviceID);
            EnSystemLog(EV9000_CMS_GET_DEVICE_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device info search response message process failed:front-end deviceID=%s, cauae=device ID in XML from fron-edn device, XML device ID=%s", caller_id, strDeviceID);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_device_info_response_proc() exit---: DeviceID Error:DeviceID=%s \r\n", strDeviceID);
            return -1;
        }

        /* 是否是第三方平台标识，仅限于下级平台，其他类型设备从数据库读取 */
        if (EV9000_DEVICETYPE_SIPSERVER == pGBDeviceInfo->device_type)
        {
            if (strOwnerFlag[0] != 0
                && (0 == sstrcmp(strOwnerFlag, (char*)"WiscomV")))
            {
                pGBDeviceInfo->three_party_flag = 0;
            }
            else
            {
                pGBDeviceInfo->three_party_flag = 1;
            }
        }

        /* 传输协议类型,仅限于下级平台，DEC,媒体网关，其他类型设备从数据库读取 */
        if (EV9000_DEVICETYPE_SIPSERVER == pGBDeviceInfo->device_type
            || EV9000_DEVICETYPE_DECODER == pGBDeviceInfo->device_type
            || EV9000_DEVICETYPE_MGWSERVER == pGBDeviceInfo->device_type)
        {
            if (strTransProtocol[0] != 0 && 0 == sstrcmp(strTransProtocol, (char*)"TCP"))
            {
                pGBDeviceInfo->trans_protocol = 1;
            }
            else
            {
                pGBDeviceInfo->trans_protocol = 0;
            }
        }

        GBDevice_cfg.device_id = strDeviceID;

        /* 查看设备通道 */
        if (strMaxCamera[0] != '\0')
        {
            GBDevice_cfg.device_max_camera = osip_atoi(strMaxCamera);
        }
        else
        {
            GBDevice_cfg.device_max_camera = 1;
        }

        /* 查看报警通道 */
        if (strMaxAlarm[0] != '\0')
        {
            GBDevice_cfg.device_max_alarm = osip_atoi(strMaxAlarm);
        }
        else
        {
            GBDevice_cfg.device_max_alarm = 0;
        }

        GBDevice_cfg.device_manufacturer = strManufacturer;

        GBDevice_cfg.device_model = strModel;
        GBDevice_cfg.device_firmware = strFirmware;

        /* 看是否需要更新物理设备的厂家信息 */
        if (strlen((char*)GBDevice_cfg.device_manufacturer.c_str()) > 0)
        {
            if (0 != sstrcmp(pGBDeviceInfo->manufacturer, (char*)GBDevice_cfg.device_manufacturer.c_str()))
            {
                osip_strncpy(pGBDeviceInfo->manufacturer, (char*)GBDevice_cfg.device_manufacturer.c_str(), MAX_128CHAR_STRING_LEN);
            }
        }
        else
        {
            memset(pGBDeviceInfo->manufacturer, 0, MAX_128CHAR_STRING_LEN + 4);
        }

        /* 更新数据库信息 */
        i = UpdateGBDeviceInfo2DB(GBDevice_cfg, pDevice_Srv_dboper);

        if (i < 0)
        {
            SystemLog(EV9000_CMS_GET_DEVICE_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备信息查询响应消息处理失败:前端设备ID=%s, 原因=更新设备信息到数据库失败", caller_id);
            EnSystemLog(EV9000_CMS_GET_DEVICE_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device info search response message process failed:front-end deviceID=%s, cause= update device info in database failed", caller_id);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_device_info_response_proc() UpdateGBDeviceInfo2DB Error:device_id=%s, i=%d \r\n", strDeviceID, i);
        }
        else
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备信息查询响应消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end device information query response message processing success: ID = % s front-end equipment, IP address = % s, port = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_device_info_response_proc() UpdateGBDeviceInfo2DB OK:device_id=%s, i=%d \r\n", strDeviceID, i);
        }

        return 0;
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_query_device_config_response_proc
 功能描述  : 获取前端设备配置应答消息处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年7月15日 星期二
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_query_device_config_response_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket)
{
    int i = 0;
    int xml_pos = -1;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    unsigned int transfer_xml_sn = 0;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_device_config_response_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_device_config_response_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 获取前端配置参数的响应消息直接转发给客户端或者上级CMS，不做处理
      */
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_device_config_response_proc() \
    \r\n XML Para: \
    \r\n SN=%s \
    \r\n DeviceID=%s \r\n ", strSN, strDeviceID);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备配置查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end device configuration query response message: ID = % s front-end equipment, IP address = % s, port = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

    if (strSN[0] == '\0')
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_device_config_response_proc() exit---: Get XML SN Error\r\n");
        return -1;
    }

    if (strDeviceID[0] == '\0')
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_device_config_response_proc() exit---: Get XML DeviceID Error\r\n");
        return -1;
    }

    /* 看看是否是用户查询或者上级查询的 */
    transfer_xml_sn = strtoul(strSN, NULL, 10);
    xml_pos = transfer_xml_msg_find(XML_QUERY_DEVICECONFIG, strDeviceID, transfer_xml_sn);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_query_device_config_response_proc() transfer_xml_msg_find:Type=%d, DeviceID=%s, transfer_xml_sn=%d, xml_pos=%d \r\n", XML_QUERY_DEVICECONFIG, strDeviceID, transfer_xml_sn, xml_pos);

    if (xml_pos >= 0)
    {
        i = transfer_xml_message_to_dest2(xml_pos, inPacket);

        if (i != 0)
        {
            SystemLog(EV9000_CMS_SET_DEVICE_CONFIG_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备配置信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=根据XML的SN转发给目的地失败, xml_pos=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            EnSystemLog(EV9000_CMS_SET_DEVICE_CONFIG_ERROR, EV9000_LOG_LEVEL_ERROR, "The front-end device configuration information query response message processing failed:front-end device ID=%s, cause=forward to destination failed accorrding to XML SN", caller_id);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_device_config_response_proc() transfer_xml_message_to_dest Error:device_id=%s\r\n", caller_id);
        }
        else
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备配置信息查询响应消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 根据XML的SN转发给目的地, xml_pos=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment configuration information query response message processing success: the front-end device ID = % s, = % s IP address, port number = % d, according to the XML SN forwarded to destination, xml_pos = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_device_config_response_proc() transfer_xml_message_to_dest OK:device_id=%s\r\n", caller_id);
        }
    }
    else
    {
        SystemLog(EV9000_CMS_SET_VIDEO_PARAM_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备配置信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=根据XML的SN查找目的地失败, transfer_xml_sn=%d, strDeviceID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, transfer_xml_sn, strDeviceID);
        EnSystemLog(EV9000_CMS_SET_VIDEO_PARAM_ERROR, EV9000_LOG_LEVEL_ERROR, "The front-end device configuration information query response message processing failure: ID = % s front-end equipment, IP address = % s, port = % d, failure reason = according to XML SN find destination, transfer_xml_sn=%d, strDeviceID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, transfer_xml_sn, strDeviceID);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_device_config_response_proc() transfer_xml_message_to_dest Error:device_id=%s\r\n", caller_id);
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_device_config_response_proc
 功能描述  : 前端设备配置应答消息处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年7月15日 星期二
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_device_config_response_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket)
{
    int i = 0;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_device_config_response_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_device_config_response_proc() exit---: Param Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备配置响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end device configuration response message: ID = % s front-end equipment, IP address = % s, port = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

    /* 前端配置的响应消息直接转发给客户端或者上级CMS，不做处理

      */

    return i;
}

/*****************************************************************************
 函 数 名  : user_device_status_response_proc
 功能描述  : 用户设备状态查询响应处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月13日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_device_status_response_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strItemDeviceID[32] = {0};
    char strResult[32] = {0};
    char strOnline[32] = {0};
    char strStatus[32] = {0};
    char strEncode[32] = {0};
    char strRecord[32] = {0};
    char strDeviceTime[64] = {0};
    char strDutyStatus[32] = {0};
    string strAlarmstatusNum;
    int iAlarmstatusNum = 0;
    int iItemNumCount = 0;
    DOMElement* ItemAccNode = NULL;
    int iOldDeviceStatus = 0;
    intelligent_status_t iOldIntelligentDeviceStatus = INTELLIGENT_STATUS_NULL;
    alarm_status_t iOldAlarmDeviceStatus = ALARM_STATUS_NULL;
    GBLogicDevice_info_t* pGBLogicDeviceInfo = NULL;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_device_status_response_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_device_status_response_proc() exit---: Param Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备状态查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end device status query response message: ID = % s front-end equipment, IP address = % s, port = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

    /* 网络设备信息查询响应消息直接转发，不做处理
          控制流程见9.5.2

          命令包括如下字段:
          <!-- 命令类型：设备状态查询（必选） -->
          <element name="CmdType" fixed ="DeviceStatus" />
          <!-- 命令序列号（必选） -->
          <element name="SN" type="integer" minInclusive value = "1" />
          <!-- 目标设备的设备编码（必选） -->
          <element name="DeviceID" type="tg:deviceIDType" />
          <!-- 查询结果标志（必选） -->
          <element name="Result" type="tg:resultType" />
          <!-- 是否在线（必选） -->
          <element name="Online" >
          <restriction base= "string">
          <enumeration value= "ONLINE" />
          <enumeration value= "OFFLINE" />
          </restriction>
          </element>
          <!-- 是否正常工作（必选） -->
          <element name="Status" type="tg:relultType" />
          <!-- 不正常工作原因（可选） -->
          <element name="Reason" type="string" minOccurs= "0"/>
          <!-- 是否编码（可选） -->
          <element name="Encode" type="tg:statusType" minOccurs= "0"/>
          <!-- 是否录像（可选） -->
          <element name="Record" type=" tg:statusType" minOccurs= "0"/>
          <!-- 设备时间和日期（可选） -->
          <element name ="DeviceTime" type="dateTime" minOccurs= "0"/>
          <!-- 报警设备状态列表,num表示列表项个数（可选） -->
          <element name="Alarmstatus" minOccurs="0">
          <attribute name="Num" type="integer"/>
          <element name="Item" minOccurs="0" maxOccurs=" unbounded ">
          <simpleType>
          <sequence>
          <!-- 报警设备编码（必选） -->
          <element name="DeviceID" type=" tg:deviceIDType " minOccurs= "0"/>
          <!-- 报警设备状态（必选） -->
          <element name="Status" minOccurs= "0">
          <restriction base="string">
          <enumeration value="ONDUTY"/>
          <enumeration value="OFFDUTY"/>
          <enumeration value="ALARM"/>
          </restriction>
          </element>
          </sequence>
          </simpleType>
          </element>
          </element>
          <!-- 扩展信息，可多项 -->
          <element name= "Info" minOccurs= "0" maxOccurs="unbounded">
          <restriction base= "string">
          <maxLength value= "1024" />
          </restriction>
          </element>
      */

    /* 查看被叫是否是本CMS ID */
    if (0 == strncmp(callee_id, local_cms_id_get(), 20))
    {
        /* 取得数据*/
        inPacket.GetElementValue((char*)"SN", strSN);
        inPacket.GetElementValue((char*)"DeviceID", strDeviceID);
        inPacket.GetElementValue((char*)"Result", strResult);
        inPacket.GetElementValue((char*)"Online", strOnline);
        inPacket.GetElementValue((char*)"Status", strStatus);
        inPacket.GetElementValue((char*)"Encode", strEncode);
        inPacket.GetElementValue((char*)"Record", strRecord);
        inPacket.GetElementValue((char*)"DeviceTime", strDeviceTime);
        inPacket.GetElementAttr((char*)"Alarmstatus", (char*)"Num", strAlarmstatusNum);

        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_device_status_response_proc() \
        \r\n XML Para: \
        \r\n SN=%s \
        \r\n DeviceID=%s \
        \r\n Result=%s \
        \r\n Online=%s \
        \r\n Status=%s \
        \r\n Encode=%s \
        \r\n Record=%s \
        \r\n DeviceTime=%s \
        \r\n AlarmstatusNum=%s \r\n ", strSN, strDeviceID, strResult, strOnline, strStatus, strEncode, strRecord, strDeviceTime, (char*)strAlarmstatusNum.c_str());

        iAlarmstatusNum = osip_atoi((char*)strAlarmstatusNum.c_str());
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_device_status_response_proc() AlarmStatusNum=%d \r\n", iAlarmstatusNum);

        if (iAlarmstatusNum > 0)
        {
            /* 获取所有的Item 数据 */
            ItemAccNode = inPacket.SearchElement((char*)"Item");

            if (!ItemAccNode)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_device_status_response_proc() exit---: Get Item Node Error \r\n");
                return -1;
            }

            inPacket.SetCurrentElement(ItemAccNode);

            while (ItemAccNode)
            {
                iItemNumCount++;

                if (iItemNumCount > iAlarmstatusNum)
                {
                    break;
                }

                memset(strItemDeviceID, 0, 32);
                inPacket.GetElementValue((char*)"DeviceID", strItemDeviceID);

                memset(strDutyStatus, 0, 32);
                inPacket.GetElementValue((char*)"DutyStatus", strDutyStatus);

                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_device_status_response_proc() \
                \r\n XML Item %d: \
                \r\n DeviceID=%s \
                \r\n DutyStatus=%s \
                \r\n ", iItemNumCount, strItemDeviceID, strDutyStatus);

                ItemAccNode = inPacket.SearchNextElement(true);
            }
        }

        pGBLogicDeviceInfo = GBLogicDevice_info_find(strDeviceID);

        if (NULL == pGBLogicDeviceInfo)
        {
            SystemLog(EV9000_CMS_NOTIFY_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备查询设备状态响应消息处理失败:前端设备ID=%s, 原因=获取逻辑设备信息失败: DeviceID=%s", caller_id, strDeviceID);
            EnSystemLog(EV9000_CMS_NOTIFY_STATUS_ERROR, EV9000_LOG_LEVEL_ERROR, "The failure of the status message handling of the front-end device status response: the front end device ID=%s, cause = failure of the acquisition of the logic device information: DeviceID=%s", caller_id, strDeviceID);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_device_status_response_proc() exit---: Find GBLogic Device Info Error:DeviceID=%s \r\n", strDeviceID);
            return -1;
        }

        iOldDeviceStatus = pGBLogicDeviceInfo->status;
        iOldIntelligentDeviceStatus = pGBLogicDeviceInfo->intelligent_status;
        iOldAlarmDeviceStatus = pGBLogicDeviceInfo->alarm_status;

        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_device_status_response_proc() DeviceID=%s, OldDeviceStatus=%d, OldIntelligentDeviceStatus=%d, OldAlarmDeviceStatus=%d \r\n ", strDeviceID, iOldDeviceStatus, iOldIntelligentDeviceStatus, iOldAlarmDeviceStatus);

        /* 判断结果和状态 */
        if (0 == sstrcmp(strResult, (char*)"OK"))
        {
            if (0 == sstrcmp(strStatus, (char*)"OK"))
            {
                if (0 == sstrcmp(strOnline, (char*)"ON") || sstrcmp(strOnline, (char*)"ONLINE") == 0)
                {
                    pGBLogicDeviceInfo->status = 1;
                }
                else if (0 == sstrcmp(strOnline, (char*)"OFF") || sstrcmp(strOnline, (char*)"OFFLINE") == 0)
                {
                    pGBLogicDeviceInfo->status = 0;
                    pGBLogicDeviceInfo->intelligent_status = INTELLIGENT_STATUS_NULL;
                    pGBLogicDeviceInfo->alarm_status = ALARM_STATUS_NULL;
                }
                else if (sstrcmp(strOnline, (char*)"NOVIDEO") == 0)
                {
                    pGBLogicDeviceInfo->status = 2;
                }
                else if (sstrcmp(strOnline, (char*)"VLOST") == 0)
                {
                    pGBLogicDeviceInfo->status = 2;
                }
                else if (sstrcmp(strOnline, (char*)"INTELLIGENT") == 0)
                {
                    pGBLogicDeviceInfo->status = 1;
                    pGBLogicDeviceInfo->intelligent_status = INTELLIGENT_STATUS_ON;
                }
                else if (sstrcmp(strOnline, (char*)"CLOSE") == 0)
                {
                    pGBLogicDeviceInfo->status = 1;
                    pGBLogicDeviceInfo->alarm_status = ALARM_STATUS_CLOSE;
                }
                else if (sstrcmp(strOnline, (char*)"APART") == 0)
                {
                    pGBLogicDeviceInfo->status = 1;
                    pGBLogicDeviceInfo->alarm_status = ALARM_STATUS_APART;
                }
            }
            else if (0 == sstrcmp(strStatus, (char*)"ERROR"))
            {
                pGBLogicDeviceInfo->status = 0;
                pGBLogicDeviceInfo->intelligent_status = INTELLIGENT_STATUS_NULL;
                pGBLogicDeviceInfo->alarm_status = ALARM_STATUS_NULL;
            }
        }
        else if (0 == sstrcmp(strResult, (char*)"ERROR"))
        {
            pGBLogicDeviceInfo->status = 0;
            pGBLogicDeviceInfo->intelligent_status = INTELLIGENT_STATUS_NULL;
            pGBLogicDeviceInfo->alarm_status = ALARM_STATUS_NULL;
        }

        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_device_status_response_proc() DeviceID=%s, NewDeviceStatus=%d, NewIntelligentDeviceStatus=%d, NewAlarmDeviceStatus=%d \r\n ", strDeviceID, pGBLogicDeviceInfo->status, pGBLogicDeviceInfo->intelligent_status, pGBLogicDeviceInfo->alarm_status);

        /* 查看状态是否有变化 */
        if (pGBLogicDeviceInfo->status != iOldDeviceStatus
            || iOldIntelligentDeviceStatus != pGBLogicDeviceInfo->intelligent_status
            || iOldAlarmDeviceStatus != pGBLogicDeviceInfo->alarm_status)
        {
            if (pGBLogicDeviceInfo->status != iOldDeviceStatus)
            {
                /* 更新数据库 */
                i = UpdateGBLogicDeviceRegStatus2DB(pGBLogicDeviceInfo->device_id, pGBLogicDeviceInfo->status, pDevice_Srv_dboper);

                if (i < 0)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() UpdateGBLogicDeviceRegStatus2DB Error:device_id=%s, status=%d, i=%d \r\n", pGBLogicDeviceInfo->device_id, pGBLogicDeviceInfo->status, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() UpdateGBLogicDeviceRegStatus2DB OK:device_id=%s, status=%d, i=%d \r\n", pGBLogicDeviceInfo->device_id, pGBLogicDeviceInfo->status, i);
                }
            }

            /* 发送设备状态消息给客户端 */
            if (1 == pGBLogicDeviceInfo->status && INTELLIGENT_STATUS_ON == pGBLogicDeviceInfo->intelligent_status)
            {
                /* 发送设备状态变化消息  */
                i = SendDeviceStatusMessageProc(pGBLogicDeviceInfo, 4, pDevice_Srv_dboper);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() SendDeviceStatusMessageProc ERROR:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() SendDeviceStatusMessageProc OK:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
                }
            }
            else if (1 == pGBLogicDeviceInfo->status && ALARM_STATUS_CLOSE == pGBLogicDeviceInfo->alarm_status)
            {
                /* 发送设备状态变化消息  */
                i = SendDeviceStatusMessageProc(pGBLogicDeviceInfo, 5, pDevice_Srv_dboper);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() SendDeviceStatusMessageProc ERROR:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() SendDeviceStatusMessageProc OK:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
                }
            }
            else if (1 == pGBLogicDeviceInfo->status && ALARM_STATUS_APART == pGBLogicDeviceInfo->alarm_status)
            {
                /* 发送设备状态变化消息  */
                i = SendDeviceStatusMessageProc(pGBLogicDeviceInfo, 6, pDevice_Srv_dboper);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() SendDeviceStatusMessageProc ERROR:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() SendDeviceStatusMessageProc OK:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
                }
            }
            else
            {
                /* 发送设备状态变化消息  */
                i = SendDeviceStatusMessageProc(pGBLogicDeviceInfo, pGBLogicDeviceInfo->status, pDevice_Srv_dboper);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() SendDeviceStatusMessageProc ERROR:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() SendDeviceStatusMessageProc OK:device_id=%s, status=%d, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, 4, i);
                }
            }

            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_notify_status_proc() UpdateGBLogicDeviceRegStatus2DB:device_id=%s,status=%d\r\n", pGBLogicDeviceInfo->device_id, pGBLogicDeviceInfo->status);
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "前端设备通知设备状态消息:逻辑设备ID=%s, 老状态=%d, 新状态=%d", pGBLogicDeviceInfo->device_id, iOldDeviceStatus, pGBLogicDeviceInfo->status);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "The device status message handling of the front-end device notification:logic device ID=%s, old state=%d, new state=%d", pGBLogicDeviceInfo->device_id, iOldDeviceStatus, pGBLogicDeviceInfo->status);
        }

        if (iOldDeviceStatus == 1 && (pGBLogicDeviceInfo->status == 0 || pGBLogicDeviceInfo->status == 2))
        {
            if (iOldDeviceStatus == 1 && pGBLogicDeviceInfo->status == 0)
            {
                /* 发送告警信息到客户端 */
                i = SendDeviceOffLineAlarmToAllClientUser(pGBLogicDeviceInfo->device_id);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() SendDeviceOffLineAlarmToAllClientUser Error:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() SendDeviceOffLineAlarmToAllClientUser OK:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
                }
            }
            else if (iOldDeviceStatus == 1 && pGBLogicDeviceInfo->status == 2)
            {
                /* 发送告警信息到客户端 */
                i = SendDeviceNoStreamAlarmToAllClientUser(pGBLogicDeviceInfo->device_id);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() SendDeviceNoStreamAlarmToAllClientUser Error:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() SendDeviceNoStreamAlarmToAllClientUser OK:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
                }
            }

            if (pGBDeviceInfo->device_type == EV9000_DEVICETYPE_DECODER) /* 解码器通道根据主叫ID停止业务 */
            {
                i = StopAllServiceTaskByCallerID(pGBLogicDeviceInfo->device_id);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() StopAllServiceTaskByCallerID Error:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() StopAllServiceTaskByCallerID OK:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
                }
            }
            else if (EV9000_DEVICETYPE_INTELLIGENTANALYSIS == pGBDeviceInfo->device_type)
            {
                i = StopAllServiceTaskByLogicDeviceIDAndStreamType(pGBLogicDeviceInfo->device_id, EV9000_STREAM_TYPE_INTELLIGENCE);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() StopAllServiceTaskByLogicDeviceIDAndStreamType Error:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() StopAllServiceTaskByLogicDeviceIDAndStreamType OK:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
                }
            }
            else
            {
                i = StopAllServiceTaskByLogicDeviceID(pGBLogicDeviceInfo->device_id);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() StopAllServiceTaskByLogicDeviceID Error:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() StopAllServiceTaskByLogicDeviceID OK:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
                }

                /* 停止音频对讲业务 */
                i = StopAudioServiceTaskByLogicDeviceID(pGBLogicDeviceInfo->device_id);

                if (0 != i)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() StopAudioServiceTaskByLogicDeviceID Error:DeviceID=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() StopAudioServiceTaskByLogicDeviceID OK:DeviceID=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
                }
            }
        }
        else if (INTELLIGENT_STATUS_ON == iOldIntelligentDeviceStatus && INTELLIGENT_STATUS_NULL == pGBLogicDeviceInfo->intelligent_status)
        {
            /* 发送告警信息到客户端 */
            i = SendIntelligentDeviceOffLineAlarmToAllClientUser(pGBLogicDeviceInfo->device_id);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() SendIntelligentDeviceOffLineAlarmToAllClientUser Error:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() SendIntelligentDeviceOffLineAlarmToAllClientUser OK:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
            }

            i = StopAllServiceTaskByLogicDeviceIDAndStreamType(pGBLogicDeviceInfo->device_id, EV9000_STREAM_TYPE_INTELLIGENCE);

            if (0 != i)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_status_proc() StopAllServiceTaskByLogicDeviceIDAndStreamType Error:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_status_proc() StopAllServiceTaskByLogicDeviceIDAndStreamType OK:device_id=%s, iRet=%d \r\n", pGBLogicDeviceInfo->device_id, i);
            }
        }

        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备状态查询响应消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end device status query response message processing success: ID = % s front-end equipment, IP address = % s, port = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    }
    else /* 转发出去 */
    {

    }

    return i;
}

/*****************************************************************************
 函 数 名  : user_record_info_response_proc
 功能描述  : 用户录像信息查询响应处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月13日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_record_info_response_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket)
{
    /* 设备视音频文件检索, 转发给用户
      */
    int i = 0;
    int xml_pos = -1;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strSumNum[16] = {0};
    string strRecordListNum = "";
    int iSumNum = 0;
    int iRecordListNum = 0;
    unsigned int transfer_xml_sn = 0;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_record_info_response_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_record_info_response_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);
    inPacket.GetElementValue((char*)"SumNum", strSumNum);
    inPacket.GetElementAttr((char*)"RecordList", (char*)"Num", strRecordListNum);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_record_info_response_proc() \
    \r\n XML Para: \
    \r\n SN=%s \
    \r\n DeviceID=%s \
    \r\n SumNum=%s \
    \r\n RecordList Num=%s \r\n ", strSN, strDeviceID, strSumNum, (char*)strRecordListNum.c_str());

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备录像信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment video information query response message: the front-end device ID = % s, = % s IP address, port number = % d, logical device ID = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);

    if (strSumNum[0] == '\0')
    {
        SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备录像信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=没有获取到前端上报的录像记录总数", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end video information query response message process failed:front-end deviceID=%s, cause=did not get total number of video reported", caller_id);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_record_info_response_proc() exit---: Get Sun Num Error \r\n");
        return -1;
    }

    /* 将设备信息写入标准逻辑设备表 */
    iSumNum = osip_atoi(strSumNum);
    iRecordListNum = osip_atoi((char*)strRecordListNum.c_str());
    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_record_info_response_proc() SumNum=%d, RecordListNum=%d \r\n", iSumNum, iRecordListNum);
    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备录像信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的录像总数=%d, 本次上报的录像条数=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, iSumNum, iRecordListNum);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end video information query response message:front-end device ID=%s, total video number reported=%d, video number reported this time=%d", caller_id, iSumNum, iRecordListNum);

    /* 看看是否是用户查询或者上级查询的 */
    transfer_xml_sn = strtoul(strSN, NULL, 10);
    xml_pos = transfer_xml_msg_find(XML_QUERY_RECORDINFO, strDeviceID, transfer_xml_sn);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_record_info_response_proc() transfer_xml_msg_find:Type=%d, DeviceID=%s, transfer_xml_sn=%d, xml_pos=%d \r\n", XML_QUERY_RECORDINFO, strDeviceID, transfer_xml_sn, xml_pos);

    if (xml_pos >= 0)
    {
        i = transfer_xml_message_to_dest(xml_pos, iSumNum, iRecordListNum, inPacket);

        if (i != 0)
        {
            SystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备录像信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=根据XML的SN转发给目的地失败, xml_pos=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            EnSystemLog(EV9000_CMS_QUERY_RECORD_INFO_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end video information query response message process failed:front-end device ID=%s:front-end device ID=%s, cause=forward to destination failed accorrding to XML SN", caller_id);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_record_info_response_proc() transfer_xml_message_to_dest Error:device_id=%s\r\n", caller_id);
        }
        else
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备录像信息查询响应消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 根据XML的SN转发给目的地, xml_pos=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment video information query response message processing success: the front-end device ID = % s, = % s IP address, port number = % d, according to the XML SN forwarded to destination, xml_pos = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_record_info_response_proc() transfer_xml_message_to_dest OK:device_id=%s\r\n", caller_id);
        }
    }
    else
    {
        SystemLog(EV9000_CMS_SET_VIDEO_PARAM_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备录像信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=根据XML的SN查找目的地失败, transfer_xml_sn=%d, strDeviceID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, transfer_xml_sn, strDeviceID);
        EnSystemLog(EV9000_CMS_SET_VIDEO_PARAM_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end equipment video information query response message processing failure: the front-end device ID = % s, = % s IP address, port number = % d, failure reason = according to XML SN find destination, transfer_xml_sn = % d, strDeviceID = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, transfer_xml_sn, strDeviceID);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_record_info_response_proc() transfer_xml_message_to_dest Error:device_id=%s\r\n", caller_id);
    }

    return 0;
}

/*****************************************************************************
 函 数 名  : device_preset_info_response_proc
 功能描述  : 用户预置位信息查询响应处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年3月15日 星期六
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_preset_info_response_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket)
{
    /* 设备预置位信息, 可能是下级CMS返回的数据，需要转发给用户
      */
    int i = 0;
    int xml_pos = -1;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strSumNum[16] = {0};
    string strPresetConfigListNum = "";
    int iSumNum = 0;
    int iPresetConfigListNum = 0;
    unsigned int transfer_xml_sn = 0;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_preset_info_response_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_preset_info_response_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);
    inPacket.GetElementValue((char*)"SumNum", strSumNum);
    inPacket.GetElementAttr((char*)"PresetConfigList", (char*)"Num", strPresetConfigListNum);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_preset_info_response_proc() \
    \r\n XML Para: \
    \r\n SN=%s \
    \r\n DeviceID=%s \
    \r\n SumNum=%s \
    \r\n PresetConfigList Num=%s \r\n ", strSN, strDeviceID, strSumNum, (char*)strPresetConfigListNum.c_str());

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备预置位信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end video information query response message process: the front-end device ID = % s, = % s IP address, port number = % d, logical device ID = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);

    if (strSumNum[0] == '\0')
    {
        SystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备预置位信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=没有获取到前端上报的预置位总数", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        EnSystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end video information query response message process failed:front-end device ID=%s, cause= did not get total preset number from front-end", caller_id);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_preset_info_response_proc() exit---: Get Sun Num Error \r\n");
        return -1;
    }

    iSumNum = osip_atoi(strSumNum);
    iPresetConfigListNum = osip_atoi((char*)strPresetConfigListNum.c_str());
    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_preset_info_response_proc() SumNum=%d, RecordListNum=%d \r\n", iSumNum, iPresetConfigListNum);
    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备预置位信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的预置位总数=%d, 本次上报的预置位条数=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, iSumNum, iPresetConfigListNum);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end device preset info search response message:front-end device ID=%s, total preset number reported=%d, number of presets reported this time=%d", caller_id, iSumNum, iPresetConfigListNum);

    /* 看看是否是用户查询或者上级查询的 */
    transfer_xml_sn = strtoul(strSN, NULL, 10);
    xml_pos = transfer_xml_msg_find(XML_QUERY_GETPRESET, strDeviceID, transfer_xml_sn);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_preset_info_response_proc() transfer_xml_msg_find:Type=%d, DeviceID=%s, transfer_xml_sn=%d, xml_pos=%d \r\n", XML_QUERY_GETPRESET, strDeviceID, transfer_xml_sn, xml_pos);

    if (xml_pos >= 0)
    {
        i = transfer_xml_message_to_dest(xml_pos, iSumNum, iPresetConfigListNum, inPacket);

        if (i != 0)
        {
            SystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备预置位信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=根据XML的SN转发给目的地失败, xml_pos=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            EnSystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device preset info search response message process failed:front-end device ID=%s, cause=forward to destination accorrding to XML SN failed", caller_id);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_preset_info_response_proc() transfer_xml_message_to_dest Error:device_id=%s\r\n", caller_id);
        }
        else
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备预置位信息查询响应消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d,根据XML的SN转发给目的地, xml_pos=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end device preset info search response message process success: the front-end device ID = % s, = % s IP address, port number = % d, according to the XML SN forwarded to destination, xml_pos = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_preset_info_response_proc() transfer_xml_message_to_dest OK:device_id=%s\r\n", caller_id);
        }
    }
    else
    {
        SystemLog(EV9000_CMS_SET_VIDEO_PARAM_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备预置位信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=根据XML的SN查找目的地失败, transfer_xml_sn=%d, strDeviceID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, transfer_xml_sn, strDeviceID);
        EnSystemLog(EV9000_CMS_SET_VIDEO_PARAM_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device preset info search response message process failed: the front-end device ID = % s = % s IP address, port number = % d, failure reason = according to XML SN find destination, transfer_xml_sn = % d, strDeviceID = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, transfer_xml_sn, strDeviceID);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_preset_info_response_proc() transfer_xml_message_to_dest Error:device_id=%s\r\n", caller_id);
    }

    return 0;
}

/*****************************************************************************
 函 数 名  : device_query_device_group_response_proc
 功能描述  : 逻辑设备目录查询响应消息处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月21日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_query_device_group_response_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strSumNum[16] = {0};
    string strDeviceGropuConfigListNum = "";
    int iSumNum = 0;
    int iDeviceListNum = 0;
    int iItemNumCount = 0;
    char strGroupID[64] = {0};
    char strName[MAX_128CHAR_STRING_LEN + 4] = {0};
    char strSortID[64] = {0};
    char strParentID[64] = {0};
    DOMElement* ItemAccNode = NULL;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_device_group_response_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_device_group_response_proc() exit---: Param Error \r\n");
        return -1;
    }

    //SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备分组信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    //EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end device group information search response message process:the front-end device ID = % s = % s IP address, port number = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

    /* 查看被叫是否是本CMS ID */
    if (0 == strncmp(callee_id, local_cms_id_get(), 20))
    {
        /* 逻辑设备分组信息 是下级CMS 注册成功之后上级CMS主动发起的查询 */
        /* 取得数据*/
        inPacket.GetElementValue((char*)"SN", strSN);
        inPacket.GetElementValue((char*)"DeviceID", strDeviceID);
        inPacket.GetElementValue((char*)"SumNum", strSumNum);
        inPacket.GetElementAttr((char*)"LogicDeviceGroupConfigList", (char*)"Num", strDeviceGropuConfigListNum);

        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_device_group_response_proc() \
        \r\n XML Para: \
        \r\n SN=%s \
        \r\n DeviceID=%s \
        \r\n SumNum=%s \
        \r\n LogicDeviceGroupConfigList Num=%s \r\n ", strSN, strDeviceID, strSumNum, (char*)strDeviceGropuConfigListNum.c_str());

        if (strSumNum[0] == '\0')
        {
            SystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备分组信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=获取XML中携带的分组信息总数失败", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            EnSystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device group information search response message process failed:front-end device ID=%s, cause=get total number of group info from XML failed", caller_id);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_device_group_response_proc() exit---: Get Sun Num Error \r\n");
            return -1;
        }

        if (0 != sstrcmp(caller_id, strDeviceID))
        {
            SystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备分组信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=XML中携带的DeviceID不匹配:DeviceID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
            EnSystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device group information search response message process failed:front-end device ID=%s, cause=DeviceID from XML do not match:DeviceID=%s", caller_id, strDeviceID);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_device_group_response_proc() exit---: Caller ID Error:DeviceID=%s \r\n", strDeviceID);
            return -1;
        }

        if (0 != sstrcmp(strDeviceID, pGBDeviceInfo->device_id))
        {
            SystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备分组信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=前端设备的XML里面的设备ID错误, XML设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
            EnSystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device group information search response message process failed:front-end device ID=%s, cause=device ID from front-end device XML is incorrect, XML deviceID=%s", caller_id, strDeviceID);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_device_group_response_proc() exit---: DeviceID Error:DeviceID=%s \r\n", strDeviceID);
            return -1;
        }

        iSumNum = osip_atoi(strSumNum);
        iDeviceListNum = osip_atoi((char*)strDeviceGropuConfigListNum.c_str());
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_group_response_proc() SumNum=%d, DeviceListNum=%d \r\n", iSumNum, iDeviceListNum);
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备分组信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的分组信息总数=%d, 本次上报的分组信息数=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, iSumNum, iDeviceListNum);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end device group information search response message:the front-end device ID = % s = % s IP address, port number = % d, to total = % d, grouping the grouping of the reported information number = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, iSumNum, iDeviceListNum);

        if (iSumNum <= 0)
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "前端设备分组信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的分组信息总数为0", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "Front-end device group information search response message:the front-end device ID = % s = % s IP address, port number = % d, total number of grouping information reported to 0 ", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
#if 0

            /* 全部删除 */
            if (pGBDeviceInfo->LogicDeviceGroupSN == (unsigned int)osip_atoi(strSN))
            {
                if (pGBDeviceInfo->LogicDeviceGroupConfigCount == 0)
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备分组信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的分组信息总数为0, 将删除掉该设备的所有分组信息", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

                    /* 设置逻辑设备分组信息修改标识为3，表示全部删除 */
                    i = SetLogicDeviceGroupChangeFlag(pGBDeviceInfo, 3);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_group_response_proc() SetLogicDeviceGroupChangeFlag:i=%d \r\n", i);

                    /* 将变化同步到数据库 */
                    i = SynLogicDeviceGroupInfoToDB(pGBDeviceInfo, pDevice_Srv_dboper);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_group_response_proc() SynLogicDeviceGroupInfoToDB:i=%d \r\n", i);

                    /* 删除内存中多余的信息 */
                    i = DelLogicDeviceGroupInfo(pGBDeviceInfo);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_group_response_proc() DelLogicDeviceGroupInfo:i=%d \r\n", i);
                }
            }

#endif
        }
        else if (iSumNum > 0)
        {
            if (iDeviceListNum <= 0)
            {
                SystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备分组信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=XML中携带的分组信息数目不正确", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                EnSystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device group information search response message process failed:front-end device ID=%s, cause=number of group info in XML is incorrect", caller_id);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_device_group_response_proc() exit---: DeviceListNum Error \r\n");
                return -1;
            }

            /* 获取所有的Item 数据 */
            ItemAccNode = inPacket.SearchElement((char*)"Item");

            if (!ItemAccNode)
            {
                SystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备分组信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=获取XML中的Item条目信息失败", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                EnSystemLog(EV9000_CMS_GET_DEIVCE_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device group information search response message process failed:front-end device ID=%s, cause=access Item info in XML failed", caller_id);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_device_group_response_proc() exit---: Get Item Node Error \r\n");
                return -1;
            }

            /* 先删除该CMS所属的所有逻辑设备分组信息 */
            if (pGBDeviceInfo->LogicDeviceGroupSN == (unsigned int)osip_atoi(strSN))
            {
                if (pGBDeviceInfo->LogicDeviceGroupConfigCount == 0)
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备分组信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 收到第一个报文, 设置该设备下面的分组信息删除标识", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Receive front-end equipment grouping information query response message the first message: the front-end device ID = % s, = % s IP address, port number = % d, set up the equipment the following grouping information delete logo", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

                    /* 第一次收到下面上报的数据时候清理数据库 */
                    //i = DeleteLogicDeviceGroupConfigByCMSID(pGBDeviceInfo->device_id, pDevice_Srv_dboper);
                    //DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG,  "device_query_device_group_response_proc() DeleteLogicDeviceGroupConfigByCMSID:CMSID=%s, i=%d \r\n", pGBDeviceInfo->device_id, i);

                    /* 设置逻辑设备分组信息修改标识为3，表示全部删除 */
                    i = SetLogicDeviceGroupChangeFlag(pGBDeviceInfo, 3);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_group_response_proc() SetLogicDeviceGroupChangeFlag:i=%d \r\n", i);
                }

                /* 上报个数统计 */
                pGBDeviceInfo->LogicDeviceGroupConfigCount += osip_atoi(strDeviceGropuConfigListNum.c_str());
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_group_response_proc() DeviceGropuConfigListNum=%s, LogicDeviceGroupConfigCount=%d \r\n", strDeviceGropuConfigListNum.c_str(), pGBDeviceInfo->LogicDeviceGroupConfigCount);
            }

            /* 循环读取数据，插入新的数据 */
            inPacket.SetCurrentElement(ItemAccNode);

            while (ItemAccNode)
            {
                iItemNumCount++;

                if (iItemNumCount > iDeviceListNum)
                {
                    break;
                }

                /* 组编号 */
                memset(strGroupID, 0, 64);
                inPacket.GetElementValue((char*)"GroupID", strGroupID);

                /* 组名称 */
                memset(strName, 0, 128);
                inPacket.GetElementValue((char*)"Name", strName);

                /* 同一父节点下组排序编号，默认0不排序 */
                memset(strSortID, 0, 64);
                inPacket.GetElementValue((char*)"SortID", strSortID);

                /* 父节点编号 */
                memset(strParentID, 0, 64);
                inPacket.GetElementValue((char*)"ParentID", strParentID);

                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备分组信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的分组信息:组编号=%s, 组名称=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGroupID, strName);
                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment grouping information query response message, report the grouping of information: the group number=%s, group name=%s", strGroupID, strName);

                /* 插入数据库 */
                //i = InsertLogicDeviceGroupConfig(strGroupID, strCMSID, strName, strSortID, strParentID, pDevice_Srv_dboper);
                //DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_device_group_response_proc() ItemCount=%d, GroupID=%s, Name=%s, CMSID=%s, InsertLogicDeviceGroupConfig:i=%d \r\n", iItemNumCount, strGroupID, strName, strCMSID, i);

                i = DeviceGroupConfigInfoProc(pGBDeviceInfo, strGroupID, strName, strParentID, osip_atoi(strSortID), 1, pDevice_Srv_dboper, 0);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_group_response_proc() DeviceGroupConfigInfoProc:i=%d \r\n", i);

                ItemAccNode = inPacket.SearchNextElement(true);
            }

            if (pGBDeviceInfo->LogicDeviceGroupSN == (unsigned int)osip_atoi(strSN))
            {
                /* 上报结束，清零 */
                if (pGBDeviceInfo->LogicDeviceGroupConfigCount >= iSumNum)
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备分组信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 收到最后一个报文, 根据分组信息删除标识同步掉多余的分组信息", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Receive front-end equipment grouping information query response message last message: ID = % s front-end equipment, IP address = % s, port = % d, according to the grouping information delete logo synchronous off excess group", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_device_group_response_proc() Proc Item End---:device_id=%s, LogicDeviceGroupConfigCount=%d, SumNum=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->LogicDeviceGroupConfigCount, iSumNum);
                    pGBDeviceInfo->LogicDeviceGroupConfigCount = 0;

                    /* 将变化同步到数据库 */
                    i = SynLogicDeviceGroupInfoToDB(pGBDeviceInfo, pDevice_Srv_dboper);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_group_response_proc() SynLogicDeviceGroupInfoToDB:i=%d \r\n", i);

                    /* 删除内存中多余的信息 */
                    i = DelLogicDeviceGroupInfo(pGBDeviceInfo);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_group_response_proc() SynLogicDeviceGroupInfoToDB:i=%d \r\n", i);

                    if (!checkRoutIfHasSendCataProc())
                    {
                        /* 设置逻辑设备分组配置信息数据库更新操作标识 */
                        i = GBLogicDeviceGroupInfoConfig_db_refresh_proc();
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_group_response_proc() GBLogicDeviceGroupInfoConfig_db_refresh_proc:i=%d \r\n", i);
                    }
                    else
                    {
                        DEBUG_TRACE(MODULE_DEVICE, LOG_WARN,  "device_query_device_group_response_proc() Has Route Send Catalog Proc \r\n");
                    }
                }
            }
        }

        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备分组信息查询响应消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    }
    else /* 转发出去 */
    {

    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_query_device_map_group_response_proc
 功能描述  : 逻辑设备目录查询响应消息处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月21日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_query_device_map_group_response_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strSumNum[16] = {0};
    string strDeviceGroupMapConfigListNum = "";
    int iSumNum = 0;
    int iDeviceListNum = 0;
    int iItemNumCount = 0;
    char strGroupID[64] = {0};
    unsigned int iDeviceIndex = 0;
    char strDeviceIndex[64] = {0};
    char strSortID[64] = {0};
    DOMElement* ItemAccNode = NULL;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_device_map_group_response_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_device_map_group_response_proc() exit---: Param Error \r\n");
        return -1;
    }

    //SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备分组关系信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    //EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment group relationship information query response message: the front-end device ID = % s, = % s IP address, port number = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

    /* 查看被叫是否是本CMS ID */
    if (0 == strncmp(callee_id, local_cms_id_get(), 20))
    {
        /* 逻辑设备分组关系信息 是下级CMS 注册成功之后上级CMS主动发起的查询 */
        /* 取得数据*/
        inPacket.GetElementValue((char*)"SN", strSN);
        inPacket.GetElementValue((char*)"DeviceID", strDeviceID);
        inPacket.GetElementValue((char*)"SumNum", strSumNum);
        inPacket.GetElementAttr((char*)"LogicDeviceMapGroupConfigList", (char*)"Num", strDeviceGroupMapConfigListNum);

        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_device_map_group_response_proc() \
            \r\n XML Para: \
            \r\n SN=%s \
            \r\n DeviceID=%s \
            \r\n SumNum=%s \
            \r\n LogicDeviceMapGroupConfigList Num=%s \r\n", strSN, strDeviceID, strSumNum, (char*)strDeviceGroupMapConfigListNum.c_str());

        if (strSumNum[0] == '\0')
        {
            SystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备分组关系信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=获取XML中携带的分组信息总数失败", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            EnSystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device group relationship information search response message process failed:front-end device ID=%s, cause=access total number of group info in XML is incorrect", caller_id);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_device_map_group_response_proc() exit---: Get Sun Num Error \r\n");
            return -1;
        }

        if (0 != sstrcmp(caller_id, strDeviceID))
        {
            SystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备分组关系信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=XML中携带的DeviceID不匹配:DeviceID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
            EnSystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device group relationship information search response message process failed:front-end device ID=%s, cause=DeviceID in XML do not match:DeviceID=%s", caller_id, strDeviceID);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_device_map_group_response_proc() exit---: Caller ID Error:DeviceID=%s \r\n", strDeviceID);
            return -1;
        }

        if (0 != sstrcmp(strDeviceID, pGBDeviceInfo->device_id))
        {
            SystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备分组关系信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=前端设备的XML里面的设备ID错误, XML设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
            EnSystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device group relationship information search response message process failed:front-end device ID=%s, cause=device ID in front-end device XML is incorrect, XML device ID=%s", caller_id, strDeviceID);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_device_map_group_response_proc() exit---: DeviceID Error:DeviceID=%s \r\n", strDeviceID);
            return -1;
        }

        iSumNum = osip_atoi(strSumNum);
        iDeviceListNum = osip_atoi((char*)strDeviceGroupMapConfigListNum.c_str());
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_map_group_response_proc() SumNum=%d, DeviceListNum=%d \r\n", iSumNum, iDeviceListNum);
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备分组关系信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的分组关系信息总数=%d, 本次上报的分组关系信息数=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, iSumNum, iDeviceListNum);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment group relationship information query response message: the front-end device ID = % s, = % s IP address, port number = % d, total number of grouping relationship information reported = % d, the report on the number of group relationship information = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, iSumNum, iDeviceListNum);

        if (iSumNum <= 0)
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "前端设备分组关系信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的分组关系信息总数为0", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "Front-end equipment group relationship information query response message: the front-end device ID = % s, = % s IP address, port number = % d, total number of grouping relationship information reported to 0", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

#if 0

            /* 全部删除 */
            if (pGBDeviceInfo->LogicDeviceMapGroupSN == (unsigned int)osip_atoi(strSN))
            {
                if (pGBDeviceInfo->LogicDeviceMapGroupConfigCount == 0)
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备分组关系信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的分组关系信息总数为0, 将删除掉该设备的所有分组关系信息", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_map_group_response_proc() Proc Item Begin---:device_id=%s, SumNum=%d \r\n", pGBDeviceInfo->device_id, iSumNum);
                    /* 设置逻辑设备分组关系信息修改标识为3，表示全部删除 */
                    i = SetLogicDeviceMapGroupChangeFlag(pGBDeviceInfo, 3);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_map_group_response_proc() SetLogicDeviceMapGroupChangeFlag:i=%d \r\n", i);

                    /* 将变化同步到数据库 */
                    i = SynLogicDeviceMapGroupInfoToDB(pGBDeviceInfo, pDevice_Srv_dboper);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_map_group_response_proc() SynLogicDeviceMapGroupInfoToDB:i=%d \r\n", i);

                    /* 删除内存中多余的信息 */
                    i = DelLogicDeviceMapGroupInfo(pGBDeviceInfo);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_map_group_response_proc() DelLogicDeviceMapGroupInfo:i=%d \r\n", i);
                }
            }

#endif
        }
        else if (iSumNum > 0)
        {
            if (iDeviceListNum <= 0)
            {
                SystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备分组关系信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=XML中携带的分组信息数目不正确", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                EnSystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device group relationship information search response message process failed:front-end device ID=%s, cause=number of group info in XML is incorrect", caller_id);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_device_map_group_response_proc() exit---: DeviceListNum Error \r\n");
                return -1;
            }

            /* 获取所有的Item 数据 */
            ItemAccNode = inPacket.SearchElement((char*)"Item");

            if (!ItemAccNode)
            {
                SystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备分组关系信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=获取XML中的Item条目信息失败", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                EnSystemLog(EV9000_CMS_GET_DEIVCE_MAP_GROUP_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device group relationship information search response message process failed:front-end device ID=%s, cause=access Item info in XML failed", caller_id);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_device_map_group_response_proc() exit---: Get Item Node Error \r\n");
                return -1;
            }

            /* 先删除该CMS所属的所有逻辑设备分组信息 */
            if (pGBDeviceInfo->LogicDeviceMapGroupSN == (unsigned int)osip_atoi(strSN))
            {
                if (pGBDeviceInfo->LogicDeviceMapGroupConfigCount == 0)
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备分组关系信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 收到第一个报文, 设置该设备下面的分组关系信息删除标识", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Receive front-end equipment group relationship information query response message the first message: ID = % s front-end equipment, IP address = % s, port = % d, set up the equipment the following grouping relationship information delete logo", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_map_group_response_proc() Proc Item Begin---:device_id=%s, SumNum=%d \r\n", pGBDeviceInfo->device_id, iSumNum);
                    /* 第一次收到下面上报的数据时候清理数据库 */
                    //i = DeleteLogicDeviceMapGroupConfigByCMSID(pGBDeviceInfo->device_id, pDevice_Srv_dboper);
                    //DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG,  "device_query_device_map_group_response_proc() DeleteLogicDeviceMapGroupConfigByCMSID:CMSID=%s,i=%d \r\n", pGBDeviceInfo->device_id, i);

                    /* 设置逻辑设备分组关系信息修改标识为3，表示全部删除 */
                    i = SetLogicDeviceMapGroupChangeFlag(pGBDeviceInfo, 3);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_map_group_response_proc() SetLogicDeviceMapGroupChangeFlag:i=%d \r\n", i);
                }

                /* 上报个数统计 */
                pGBDeviceInfo->LogicDeviceMapGroupConfigCount += osip_atoi(strDeviceGroupMapConfigListNum.c_str());
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_map_group_response_proc() DeviceGroupMapConfigListNum=%s, GBDeviceInfo->LogicDeviceMapGroupConfigCount=%d \r\n", strDeviceGroupMapConfigListNum.c_str(), pGBDeviceInfo->LogicDeviceMapGroupConfigCount);
            }

            /* 循环读取数据，插入新的数据 */
            inPacket.SetCurrentElement(ItemAccNode);

            while (ItemAccNode)
            {
                iItemNumCount++;

                if (iItemNumCount > iDeviceListNum)
                {
                    break;
                }

                /* 组编号 */
                memset(strGroupID, 0, 64);
                inPacket.GetElementValue((char*)"GroupID", strGroupID);

                /* 逻辑设备索引 */
                memset(strDeviceIndex, 0, 64);
                inPacket.GetElementValue((char*)"DeviceIndex", strDeviceIndex);

                /* 同一父节点下组排序编号 */
                memset(strSortID, 0, 64);
                inPacket.GetElementValue((char*)"SortID", strSortID);

                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备分组关系信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 上报的分组关系信息:组编号=%s, 逻辑设备索引=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGroupID, strDeviceIndex);
                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment group relationship information query response message, report to the group relationship information: group number=%s, logical device index=%s", strGroupID, strDeviceIndex);

                /* 插入数据库 */
                //i = InsertLogicDeviceMapGroupConfig(strGroupID, strDeviceIndex, strCMSID, strSortID, pDevice_Srv_dboper);
                //DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_device_map_group_response_proc() ItemCount=%d, GroupID=%s, DeviceIndex=%s, CMSID=%s, InsertLogicDeviceMapGroupConfig:i=%d\r\n", iItemNumCount, strGroupID, strDeviceIndex, strCMSID, i);

                if (strDeviceIndex[0] != '\0')
                {
                    iDeviceIndex = strtoul(strDeviceIndex, NULL, 10);
                }
                else
                {
                    iDeviceIndex = 0;
                }

                /* 查找逻辑设备分组关系信息，看是否存在 */
                i = DeviceGroupMapConfigInfoProc(pGBDeviceInfo, strGroupID, iDeviceIndex, osip_atoi(strSortID), 1, pDevice_Srv_dboper, 0);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_device_map_group_response_proc() GroupID=%s, DeviceIndex=%u, DeviceGroupMapConfigInfoProc:i=%d\r\n", strGroupID, iDeviceIndex, i);

                ItemAccNode = inPacket.SearchNextElement(true);
            }

            /* 上报结束，清零 */
            if (pGBDeviceInfo->LogicDeviceMapGroupSN == (unsigned int)osip_atoi(strSN))
            {
                if (pGBDeviceInfo->LogicDeviceMapGroupConfigCount >= iSumNum)
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备分组关系信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 收到最后一个报文, 根据分组关系信息删除标识同步掉多余的分组信息", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Receive front-end equipment group relationship information query response message last message: the front-end device ID = % s, = % s IP address, port number = % d, according to the grouping the relationship information delete logo off redundant packet information", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_device_group_response_proc() Proc Item End---:device_id=%s, LogicDeviceMapGroupConfigCount=%d, SumNum=%d \r\n", pGBDeviceInfo->device_id, pGBDeviceInfo->LogicDeviceMapGroupConfigCount, iSumNum);
                    pGBDeviceInfo->LogicDeviceMapGroupConfigCount = 0;

                    /* 将变化同步到数据库 */
                    i = SynLogicDeviceMapGroupInfoToDB(pGBDeviceInfo, pDevice_Srv_dboper);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_map_group_response_proc() SynLogicDeviceMapGroupInfoToDB:i=%d \r\n", i);

                    /* 删除内存中多余的信息 */
                    i = DelLogicDeviceMapGroupInfo(pGBDeviceInfo);
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_map_group_response_proc() DelLogicDeviceMapGroupInfo:i=%d \r\n", i);

                    if (!checkRoutIfHasSendCataProc())
                    {
                        /* 设置逻辑设备分组关系配置信息数据库更新操作标识 */
                        i = GBLogicDeviceGroupMapInfoConfig_db_refresh_proc();
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_device_map_group_response_proc() GBLogicDeviceGroupMapInfoConfig_db_refresh_proc:i=%d \r\n", i);
                    }
                    else
                    {
                        DEBUG_TRACE(MODULE_DEVICE, LOG_WARN,  "device_query_device_map_group_response_proc() Has Route Send Catalog Proc \r\n");
                    }
                }
            }
        }

        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备分组信息关系查询响应消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment grouping information relational query response message processing success: ID = % s front-end equipment, IP address = % s, port = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    }
    else /* 转发出去 */
    {

    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_query_topology_phydevice_config_response_proc
 功能描述  : 拓扑物理设备配置查询响应消息处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年11月27日 星期四
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_query_topology_phydevice_config_response_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strSumNum[16] = {0};
    string strTopologyPhyDeviceConfigListNum = "";
    int iSumNum = 0;
    int iTopologyPhyDeviceNum = 0;
    int iItemNumCount = 0;

    char strItemDeviceID[64] = {0};
    char strDeviceName[128] = {0};
    char strDeviceType[64] = {0};
    char strDeviceIP[64] = {0};
    char strStatus[64] = {0};
    char strCMSID[64] = {0};
    char strLinkType[64] = {0};

    DOMElement* ItemAccNode = NULL;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_topology_phydevice_config_response_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_topology_phydevice_config_response_proc() exit---: Param Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备拓扑物理设备配置信息查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment topology physical device configuration information query response message: ID = % s front-end equipment, IP address = % s, port = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

    /* 查看被叫是否是本CMS ID */
    if (0 == strncmp(callee_id, local_cms_id_get(), 20))
    {
        /* 逻辑设备分组信息 是下级CMS 注册成功之后上级CMS主动发起的查询 */
        /* 取得数据*/
        inPacket.GetElementValue((char*)"SN", strSN);
        inPacket.GetElementValue((char*)"DeviceID", strDeviceID);
        inPacket.GetElementValue((char*)"SumNum", strSumNum);
        inPacket.GetElementAttr((char*)"TopologyPhyDeviceConfigList", (char*)"Num", strTopologyPhyDeviceConfigListNum);

        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_topology_phydevice_config_response_proc() \
        \r\n XML Para: \
        \r\n SN=%s \
        \r\n DeviceID=%s \
        \r\n SumNum=%s \
        \r\n TopologyPhyDeviceConfigList Num=%s \r\n ", strSN, strDeviceID, strSumNum, (char*)strTopologyPhyDeviceConfigListNum.c_str());

        if (strSumNum[0] == '\0')
        {
            SystemLog(EV9000_CMS_GET_TOP_DEVICE_CONFIG_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备拓扑物理设备配置信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=获取XML中携带的分组信息总数失败", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
            EnSystemLog(EV9000_CMS_GET_TOP_DEVICE_CONFIG_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device topology physical device configuration information search response message process failed:front-end device ID=%s, cause=access total number of group info from XML failed", caller_id);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_topology_phydevice_config_response_proc() exit---: Get Sun Num Error \r\n");
            return -1;
        }

        if (0 != sstrcmp(caller_id, strDeviceID))
        {
            SystemLog(EV9000_CMS_GET_TOP_DEVICE_CONFIG_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备拓扑物理设备配置信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=XML中携带的DeviceID不匹配:DeviceID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
            EnSystemLog(EV9000_CMS_GET_TOP_DEVICE_CONFIG_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device topology physical device configuration information search response message process failed:front-end device ID=%s, cause=DeviceID in XML do not match:DeviceID=%s", caller_id, strDeviceID);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_topology_phydevice_config_response_proc() exit---: Caller ID Error:DeviceID=%s \r\n", strDeviceID);
            return -1;
        }

        if (0 != sstrcmp(strDeviceID, pGBDeviceInfo->device_id))
        {
            SystemLog(EV9000_CMS_GET_TOP_DEVICE_CONFIG_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备拓扑物理设备配置信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=前端设备的XML里面的设备ID错误, XML设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
            EnSystemLog(EV9000_CMS_GET_TOP_DEVICE_CONFIG_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device topology physical device configuration information search response message process failed:front-end device ID=%s, cause=device ID in front-end device XML is incorrect, XML device ID=%s", caller_id, strDeviceID);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_topology_phydevice_config_response_proc() exit---: DeviceID Error:DeviceID=%s \r\n", strDeviceID);
            return -1;
        }

        iSumNum = osip_atoi(strSumNum);
        iTopologyPhyDeviceNum = osip_atoi((char*)strTopologyPhyDeviceConfigListNum.c_str());
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_topology_phydevice_config_response_proc() SumNum=%d, TopologyPhyDeviceNum=%d \r\n", iSumNum, iTopologyPhyDeviceNum);

        if (iSumNum > 0)
        {
            if (iTopologyPhyDeviceNum <= 0)
            {
                SystemLog(EV9000_CMS_GET_TOP_DEVICE_CONFIG_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备拓扑物理设备配置信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=XML中携带的分组信息数目不正确", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                EnSystemLog(EV9000_CMS_GET_TOP_DEVICE_CONFIG_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device topology physical device configuration information search response message process failed:front-end device ID=%s, cause=number of group info in XML is incorrect", caller_id);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_topology_phydevice_config_response_proc() exit---: DeviceListNum Error \r\n");
                return -1;
            }

            /* 获取所有的Item 数据 */
            ItemAccNode = inPacket.SearchElement((char*)"Item");

            if (!ItemAccNode)
            {
                SystemLog(EV9000_CMS_GET_TOP_DEVICE_CONFIG_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备拓扑物理设备配置信息查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=获取XML中的Item条目信息失败", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                EnSystemLog(EV9000_CMS_GET_TOP_DEVICE_CONFIG_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device topology physical device configuration information search response message process failed:front-end device ID=%s, cause=access Item number info in XML failed", caller_id);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_topology_phydevice_config_response_proc() exit---: Get Item Node Error \r\n");
                return -1;
            }

            /* 循环读取数据，插入新的数据 */
            inPacket.SetCurrentElement(ItemAccNode);

            while (ItemAccNode)
            {
                iItemNumCount++;

                if (iItemNumCount > iTopologyPhyDeviceNum)
                {
                    break;
                }

                /* 设备ID */
                memset(strItemDeviceID, 0, 64);
                inPacket.GetElementValue((char*)"DeviceID", strItemDeviceID);

                /* 设备名称 */
                memset(strDeviceName, 0, 128);
                inPacket.GetElementValue((char*)"DeviceName", strDeviceName);

                /* 设备类型 */
                memset(strDeviceType, 0, 64);
                inPacket.GetElementValue((char*)"DeviceType", strDeviceType);

                /* 设备IP */
                memset(strDeviceIP, 0, 64);
                inPacket.GetElementValue((char*)"DeviceIP", strDeviceIP);

                /* 设备状态 */
                memset(strStatus, 0, 64);
                inPacket.GetElementValue((char*)"Status", strStatus);

                if (osip_atoi(strDeviceType) == EV9000_DEVICETYPE_SIPSERVER) /* 如果是CMS单板设备 */
                {
                    /* 查看是否属于本CMS直属下级设备 */
                    if (0 == sstrcmp(strItemDeviceID, pGBDeviceInfo->device_id))
                    {
                        memset(strCMSID, 0, 64);
                        memset(strLinkType, 0, 64);

                        snprintf(strCMSID, 64, "%s", local_cms_id_get());

                        if (1 == pGBDeviceInfo->link_type) /* 同级的写1 */
                        {
                            snprintf(strLinkType, 64, "%d", 1);
                        }
                        else
                        {
                            snprintf(strLinkType, 64, "%d", 0);
                        }
                    }
                    else
                    {
                        /* 所属 CMS 编号 */
                        memset(strCMSID, 0, 64);
                        inPacket.GetElementValue((char*)"CMSID", strCMSID);

                        /* 是否同级 */
                        memset(strLinkType, 0, 64);
                        inPacket.GetElementValue((char*)"LinkType", strLinkType);
                    }
                }
                else
                {
                    /* 所属 CMS 编号 */
                    memset(strCMSID, 0, 64);
                    inPacket.GetElementValue((char*)"CMSID", strCMSID);

                    /* 是否同级 */
                    memset(strLinkType, 0, 64);
                    inPacket.GetElementValue((char*)"LinkType", strLinkType);
                }

                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备拓扑物理设备配置信息查询响应消息,上报的拓扑物理设备配置信息:设备ID=%s, 设备IP=%s, CMSID=%s, LinkType=%s", strItemDeviceID, strDeviceName, strCMSID, strLinkType);
                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment topology physical device configuration information query response message, report to the topology of a physical device configuration information: device ID = % s, equipment, IP = % s CMSID = % s, LinkType = % s", strItemDeviceID, strDeviceName, strCMSID, strLinkType);
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_topology_phydevice_config_response_proc() ItemCount=%d, DeviceID=%s, Name=%s, CMSID=%s, LinkType=%s \r\n", iItemNumCount, strItemDeviceID, strDeviceName, strCMSID, strLinkType);

                /* 写入或者更新数据库 */
                i = AddTopologyPhyDeviceInfo2DB(strItemDeviceID, strDeviceName, strDeviceType, strDeviceIP, strStatus, strCMSID, strLinkType, pDevice_Srv_dboper);

                if (i < 0)
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_query_topology_phydevice_config_response_proc() AddTopologyPhyDeviceInfo2DB ERROR:device_id=%s, iRet=%d \r\n", strItemDeviceID, i);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_query_topology_phydevice_config_response_proc() AddTopologyPhyDeviceInfo2DB OK:device_id=%s, iRet=%d \r\n", strItemDeviceID, i);
                }

                ItemAccNode = inPacket.SearchNextElement(true);
            }
        }

        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备拓扑物理设备配置信息查询响应消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment topology physical device configuration information query response message processing success: ID = % s front-end equipment, IP address = % s, port = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    }
    else /* 转发出去 */
    {

    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_channel_status_response_proc
 功能描述  : 获取解码器通道状态回应消息
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年5月5日 星期一
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_channel_status_response_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    char strSN[32] = {0};
    char strChannelID[32] = {0};

    int xml_pos = -1;
    unsigned int transfer_xml_sn = 0;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_channel_status_response_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_channel_status_response_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"ChannelID", strChannelID);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_channel_status_response_proc() \
    \r\n XML Para: SN=%s, ChannelID=%s \r\n", strSN, strChannelID);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备通道状态响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, ChannelID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strChannelID);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment channel status response message: ID = % s front-end equipment, IP address = % s, port = % d, ChannelID = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strChannelID);

    /* 解码器通道状态消息直接转发给客户端，不作处理
      */

    /* 看看是否是用户查询或者上级查询的 */
    transfer_xml_sn = strtoul(strSN, NULL, 10);
    xml_pos = transfer_xml_msg_find(XML_QUERY_CHANNELSTATUS, strChannelID, transfer_xml_sn);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_channel_status_response_proc() transfer_xml_msg_find:Type=%d, DeviceID=%s, transfer_xml_sn=%d, xml_pos=%d \r\n", XML_QUERY_CHANNELSTATUS, strChannelID, transfer_xml_sn, xml_pos);

    if (xml_pos >= 0)
    {
        i = transfer_xml_message_to_dest(xml_pos, 0, 0, inPacket);

        if (i != 0)
        {
            SystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通道状态查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=根据XML的SN转发给目的地失败, xml_pos=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            EnSystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device channel status search response message process failed:front-end device ID=%s, cause=forward to destination accorrding to XML SN failed", caller_id);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_channel_status_response_proc() transfer_xml_message_to_dest Error:device_id=%s\r\n", caller_id);
        }
        else
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备预置位信息查询响应消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 根据XML的SN转发给目的地, xml_pos=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end equipment preset information query response message processing success: the front-end device ID = % s, = % s IP address, port number = % d, according to the XML SN forwarded to destination, xml_pos = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_channel_status_response_proc() transfer_xml_message_to_dest OK:device_id=%s\r\n", caller_id);
        }
    }
    else
    {
        SystemLog(EV9000_CMS_SET_VIDEO_PARAM_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备通道状态查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=根据XML的SN查找目的地失败, transfer_xml_sn=%d, strDeviceID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, transfer_xml_sn, strChannelID);
        EnSystemLog(EV9000_CMS_SET_VIDEO_PARAM_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end equipment channel status query response message processing failure: the front-end device ID = % s, = % s IP address, port number = % d, failure reason = according to XML SN find destination, transfer_xml_sn = % d, strDeviceID = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, transfer_xml_sn, strChannelID);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_channel_status_response_proc() transfer_xml_message_to_dest Error:device_id=%s\r\n", caller_id);
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_data_value_response_proc
 功能描述  : 获取前端点位数据值回应消息
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年5月5日 星期一
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_data_value_response_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};

    int xml_pos = -1;
    unsigned int transfer_xml_sn = 0;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_data_value_response_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_data_value_response_proc() exit---: Param Error \r\n");
        return -1;
    }

    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_data_value_response_proc() \
    \r\n XML Para: SN=%s, DeviceID=%s \r\n", strSN, strDeviceID);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备数据值查询响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d, 逻辑设备ID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment data values query response message: front-end equipment, ID = % s = % s IP address, port number = % d, logical device ID = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strDeviceID);

    /* 直接转发给客户端，不作处理
      */

    /* 看看是否是用户查询或者上级查询的 */
    transfer_xml_sn = strtoul(strSN, NULL, 10);
    xml_pos = transfer_xml_msg_find(XML_QUERY_DATA_VALUE, strDeviceID, transfer_xml_sn);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_data_value_response_proc() transfer_xml_msg_find:Type=%d, DeviceID=%s, transfer_xml_sn=%d, xml_pos=%d \r\n", XML_QUERY_DATA_VALUE, strDeviceID, transfer_xml_sn, xml_pos);

    if (xml_pos >= 0)
    {
        i = transfer_xml_message_to_dest(xml_pos, 0, 0, inPacket);

        if (i != 0)
        {
            SystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备数据值查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=根据XML的SN转发给目的地失败, xml_pos=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            EnSystemLog(EV9000_CMS_GET_PRESET_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end device data value search response message process failed:front-end device ID=%s, cause=forward to destination accorrding to XML SN failed", caller_id);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_data_value_response_proc() transfer_xml_message_to_dest Error:device_id=%s\r\n", caller_id);
        }
        else
        {
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备数据值查询响应消息处理成功:前端设备ID=%s, IP地址=%s, 端口号=%d, 根据XML的SN转发给目的地, xml_pos=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment data values query response message processing success: the front-end device ID = % s, = % s IP address, port number = % d, according to the XML SN forwarded to destination, xml_pos = % d ", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, xml_pos);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_data_value_response_proc() transfer_xml_message_to_dest OK:device_id=%s\r\n", caller_id);
        }
    }
    else
    {
        SystemLog(EV9000_CMS_SET_VIDEO_PARAM_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备数据值查询响应消息处理失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=根据XML的SN查找目的地失败, transfer_xml_sn=%d, strDeviceID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, transfer_xml_sn, strDeviceID);
        EnSystemLog(EV9000_CMS_SET_VIDEO_PARAM_ERROR, EV9000_LOG_LEVEL_ERROR, "Front-end equipment data values query response message processing failure: the front-end device ID = % s, = % s IP address, port number = % d, failure reason = according to XML SN find destination, transfer_xml_sn = % d, strDeviceID = % s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, transfer_xml_sn, strDeviceID);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_data_value_response_proc() transfer_xml_message_to_dest Error:device_id=%s\r\n", caller_id);
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_query_dec_media_port_response_proc
 功能描述  : 获取DEC媒体端口响应消息处理
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* callee_id
             CPacket& inPacket
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年5月13日
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_query_dec_media_port_response_proc(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * callee_id, CPacket & inPacket, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    char strSN[32] = {0};
    char strDeviceID[32] = {0};
    char strGBLogicDeviceID[32] = {0};
    char strCameraID[32] = {0};
    char strStreamType[32] = {0};
    char strMediaPort[32] = {0};

    int iStreamType = 0;
    int iMediaPort = 0;
    int dialog_index = -1;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_dec_media_port_response_proc() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if (NULL == caller_id || NULL == callee_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_query_dec_media_port_response_proc() exit---: Param Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备获取解码器媒体端口响应消息:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front end device get dec media port response message:front-end device ID=%s, IP=%s, port=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

    /* <?xml version="1.0" ?>
          <Response>
              <CmdType>GetDECMediaPort</CmdType>
              <SN>1</SN>
              <DeviceID>32011501001140000001</DeviceID>
              <DECChannelID>32011501001330000001</DECChannelID>
              <CameraID>32011501001320000001</CameraID>
              <StreamType>1</StreamType>
              <MediaPort>14234</MediaPort>
          </Response>
     */

    /* 取得数据*/
    inPacket.GetElementValue((char*)"SN", strSN);
    inPacket.GetElementValue((char*)"DeviceID", strDeviceID);
    inPacket.GetElementValue((char*)"DECChannelID", strGBLogicDeviceID);
    inPacket.GetElementValue((char*)"CameraID", strCameraID);
    inPacket.GetElementValue((char*)"StreamType", strStreamType);
    inPacket.GetElementValue((char*)"MediaPort", strMediaPort);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_notify_reopen_proc() \
    \r\n XML Para: \
    \r\n SN=%s \
    \r\n DeviceID=%s \
    \r\n GBLogicDeviceID=%s \
    \r\n CameraID=%s \
    \r\n StreamType=%s \
    \r\n MediaPort=%s \r\n ", strSN, strDeviceID, strGBLogicDeviceID, strCameraID, strStreamType, strMediaPort);

    if (strMediaPort[0] == '\0')
    {
        SystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备获取解码器媒体端口响应消息处理失败:前端设备ID=%, IP地址=%s, 端口号=%d, 原因=没有获取到XML消息中的媒体端口信息", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        EnSystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "The front-end device get media port response message processing failure: the front end device ID=%, the cause = get XML messages media port error", caller_id);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_dec_media_port_response_proc() exit---: Get media port Error \r\n");
        return -1;
    }

    iMediaPort = osip_atoi(strMediaPort);
    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE,  "device_query_dec_media_port_response_proc() MediaPort=%d \r\n", iMediaPort);

    if (iMediaPort <= 0)
    {
        SystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备获取解码器媒体端口响应消息处理失败:前端设备ID=%, IP地址=%s, 端口号=%d, 原因=没有获取到XML消息中的媒体端口信息, MediaPort=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strMediaPort);
        EnSystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "The front-end device get media port response message processing failure: the front end device ID=%, the cause = get XML messages media port error", caller_id);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_dec_media_port_response_proc() exit---: Get media port Error \r\n");
        return -1;
    }

    /* DEC 通道编码 */
    if (strGBLogicDeviceID[0] == '\0' || (strGBLogicDeviceID[0] == '0' && strlen(strGBLogicDeviceID) == 1))
    {
        SystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备获取解码器媒体端口响应消息处理失败:前端设备ID=%, IP地址=%s, 端口号=%d, 原因=XML消息中的解码器通道信息错误, GBLogicDeviceID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strGBLogicDeviceID);
        EnSystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "The front-end device get media port response message processing failure: the front end device ID=%, the cause = get XML messages GBLogicDeviceID error", caller_id);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_dec_media_port_response_proc() exit---: Get media port Error \r\n");
        return -1;
    }

    /* DEC 通道解码的前端设备编码*/
    if (strCameraID[0] == '\0' || (strCameraID[0] == '0' && strlen(strCameraID) == 1))
    {
        SystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "前端设备获取解码器媒体端口响应消息处理失败:前端设备ID=%, IP地址=%s, 端口号=%d, 原因=XML消息中的解码器通道信息错误, CameraID=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, strCameraID);
        EnSystemLog(EV9000_CMS_NOTIFY_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "The front-end device get media port response message processing failure: the front end device ID=%, the cause = get XML messages CameraID error", caller_id);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_dec_media_port_response_proc() exit---: Get media port Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备获取解码器媒体端口响应消息:电视墙通道ID=%s, 逻辑设备ID=%s, 流类型=%s, 解码器媒体端口=%s", strGBLogicDeviceID, strCameraID, strStreamType, strMediaPort);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "The front-end device get media port response message processing: the TV wall ID=%s, the logic device ID=%s, the flow type =%s, DEC Media Port=%s", strGBLogicDeviceID, strCameraID, strStreamType, strMediaPort);

    if (strStreamType[0] == '\0')
    {
        dialog_index = start_connect_tv_proc(strCameraID, EV9000_STREAM_TYPE_MASTER, strGBLogicDeviceID, iMediaPort);
    }
    else
    {
        iStreamType = osip_atoi(strStreamType);

        if (strStreamType <= 0)
        {
            dialog_index = start_connect_tv_proc(strCameraID, EV9000_STREAM_TYPE_MASTER, strGBLogicDeviceID, iMediaPort);
        }
        else
        {
            dialog_index = start_connect_tv_proc(strCameraID, iStreamType, strGBLogicDeviceID, iMediaPort);
        }
    }

    if (dialog_index < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_dec_media_port_response_proc() start_connect_tv_proc Error:CameraID=%s, DECID=%s\r\n", strCameraID, strGBLogicDeviceID);

        i = SendConnectTVResponseToUserByDeviceIDAndDECID(0, strCameraID, strGBLogicDeviceID);

        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_dec_media_port_response_proc() SendConnectTVResponseToUserByDeviceIDAndDECID:CameraID=%s, DECID=%s, i=%d\r\n", strCameraID, strGBLogicDeviceID, i);
    }
    else
    {
        if (dialog_index == 999999)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "device_query_dec_media_port_response_proc() start_connect_tv_proc Error:CameraID=%s, DECID=%s\r\n", strCameraID, strGBLogicDeviceID);

            i = SendConnectTVResponseToUserByDeviceIDAndDECID(0, strCameraID, strGBLogicDeviceID);

            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_dec_media_port_response_proc() SendConnectTVResponseToUserByDeviceIDAndDECID:CameraID=%s, DECID=%s, i=%d\r\n", strCameraID, strGBLogicDeviceID, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_dec_media_port_response_proc() start_connect_tv_proc OK:CameraID=%s, DECID=%s\r\n", strCameraID, strGBLogicDeviceID);

            i = update_user_response_msg_dialog_index(XML_NOTIFY_CONNECT_TV, strCameraID, strGBLogicDeviceID, dialog_index);

            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_dec_media_port_response_proc() update_user_response_msg_dialog_index:CameraID=%s, DECID=%s, i=%d\r\n", strCameraID, strGBLogicDeviceID, i);

            if (i != 0)
            {
                i = SendConnectTVResponseToUserByDeviceIDAndDECID(0, strCameraID, strGBLogicDeviceID);

                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "device_query_dec_media_port_response_proc() SendConnectTVResponseToUserByDeviceIDAndDECID:CameraID=%s, DECID=%s, i=%d\r\n", strCameraID, strGBLogicDeviceID, i);
            }
        }
    }

    return 0;
}

/*****************************************************************************
 函 数 名  : device_answer_dc_invite_response_proc
 功能描述  : 用户启动DC后收到DC端的Invite响应处理
 输入参数  : cr_t* pCrData
             int response_code
             char* msg_body
             int msg_body_len
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年8月14日 星期三
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_answer_dc_invite_response_proc(cr_t * pCrData, int response_code, char * msg_body, int msg_body_len)
{
    int i = 0;
    sdp_message_t* pRemoteSDP = NULL;
    sdp_param_t stRemoteSDPParam;
    sdp_extend_param_t stRemoteSDPExParam;

    if (NULL == pCrData)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_answer_dc_invite_response_proc() exit---: Param Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "电视墙业务, 收到电视墙DC端的INVITE响应处理:逻辑设备ID=%s, 电视墙通道ID=%s", pCrData->callee_id, pCrData->caller_id);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "TV wall, received the TV wall in the DC side INVITE response processing: logical device ID = % s, TV wall channel ID = % s", pCrData->callee_id, pCrData->caller_id);

    /*  根据响应码作不同的处理 */
    if (200 == response_code)
    {
        if (NULL == msg_body || msg_body_len == 0)
        {
            SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 收到电视墙DC端的INVITE响应处理失败:逻辑设备ID=%s, 电视墙通道ID=%s, 原因=%s", pCrData->callee_id, pCrData->caller_id, (char*)"获源端逻辑设备的SDP信息失败");
            EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, the INVITE response to the DC side of the TV wall process failed:logic deviceID=%s, TV wall channel ID=%s, cause=%s", pCrData->callee_id, pCrData->caller_id, (char*)"Access SDP info from source end logic device failed");
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_answer_dc_invite_response_proc() exit---: Get Remote Message SDP Body Error \r\n");
            return -1;
        }

        if (!g_DECMediaTransferFlag
            && EV9000_DEVICETYPE_SIPSERVER == pCrData->callee_gb_device_type && pCrData->caller_sdp_port > 0) /* 下级平台媒体流不经过本级TSU转发 */
        {
            /* 不需要处理 */
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "电视墙业务, 收到电视墙DC端的INVITE响应处理:逻辑设备ID=%s, 电视墙通道ID=%s, 媒体流不经过本级转发, 本级不需要处理", pCrData->callee_id, pCrData->caller_id);
            return 0;
        }
        else
        {
            /* 获取200消息中的被叫的sdp信息 */
            i = sdp_message_init(&pRemoteSDP);

            if (0 != i)
            {
                SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 收到电视墙DC端的INVITE响应处理失败:逻辑设备ID=%s, 电视墙通道ID=%s, 原因=%s", pCrData->callee_id, pCrData->caller_id, (char*)"SDP初始化失败");
                EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, the INVITE response to the DC side of the TV wall process failed:logic deviceID=%s, TV wall channel ID=%s, cause=%s", pCrData->callee_id, pCrData->caller_id, (char*)"SDP initialization failed");
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_answer_dc_invite_response_proc() exit---: Remote SDP Message Init Error \r\n");
                return -1;
            }

            i = sdp_message_parse(pRemoteSDP, msg_body); /*parse body */

            if (0 != i)
            {
                sdp_message_free(pRemoteSDP);
                pRemoteSDP = NULL;
                SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 收到电视墙DC端的INVITE响应处理失败:逻辑设备ID=%s, 电视墙通道ID=%s, 原因=%s", pCrData->callee_id, pCrData->caller_id, (char*)"SDP解析失败");
                EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, the INVITE response to the DC side of the TV wall process failed:logic deviceID=%s, TV wall channel ID=%s, cause=%s", pCrData->callee_id, pCrData->caller_id, (char*)"SDP analysis failed");
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_answer_dc_invite_response_proc() exit---: Remote SDP Message Parse Error \r\n");
                return -1;
            }

            /* 获取协商的SDP信息 */
            memset(&stRemoteSDPParam, 0, sizeof(sdp_param_t));
            memset(&stRemoteSDPExParam, 0, sizeof(sdp_extend_param_t));

            i = SIP_GetSDPInfoEx(pRemoteSDP, &stRemoteSDPParam, &stRemoteSDPExParam);

            if (0 != i)
            {
                sdp_message_free(pRemoteSDP);
                pRemoteSDP = NULL;
                SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 收到电视墙DC端的INVITE响应处理失败:逻辑设备ID=%s, 电视墙通道ID=%s, 原因=%s", pCrData->callee_id, pCrData->caller_id, (char*)"获源协商的SDP编码格式失败");
                EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, the INVITE response to the DC side of the TV wall process failed:logic deviceID=%s, TV wall channel ID=%s, cause=%s", pCrData->callee_id, pCrData->caller_id, (char*)"Access source negotiation SDP encoding format failed");
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_answer_dc_invite_response_proc() exit---: Get SDP Video Info Error \r\n");
                return -1;
            }

            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_answer_dc_invite_response_proc() addr=%s,port=%d,code=%d,flag=%d \r\n", stRemoteSDPParam.sdp_ip, stRemoteSDPParam.video_port, stRemoteSDPParam.video_code_type, stRemoteSDPParam.media_direction);

            /* 添加DC 的SDP 信息 */
            osip_strncpy(pCrData->caller_sdp_ip, stRemoteSDPParam.sdp_ip, MAX_IP_LEN);
            pCrData->caller_sdp_port = stRemoteSDPParam.video_port;

            if (TRANSFER_PROTOCOL_TCP == pCrData->caller_transfer_type)
            {
                /* 通知TSU 开始转发*/
                if (1 == pCrData->callee_service_type)
                {
                    i = notify_tsu_add_transfer_task(pCrData, pCrData->callee_service_type, pCrData->callee_record_type);
                }
                else
                {
                    i = notify_tsu_add_transfer_task(pCrData, pCrData->callee_service_type, pCrData->callee_stream_type);
                }

                /* 更新一下TSU的发送端口号 */
                if (i > 0)
                {
                    pCrData->tsu_send_port = i;
                    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_answer_dc_invite_response_proc() tsu_send_port=%d \r\n", pCrData->tsu_send_port);
                }
                else
                {
                    DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_answer_dc_invite_response_proc() tsu_send_port=%d \r\n", pCrData->tsu_send_port);
                }
            }
            else
            {
                /* 通知TSU 开始转发*/
                if (1 == pCrData->callee_service_type)
                {
                    i = notify_tsu_add_transfer_task(pCrData, pCrData->callee_service_type, pCrData->callee_record_type);
                }
                else
                {
                    i = notify_tsu_add_transfer_task(pCrData, pCrData->callee_service_type, pCrData->callee_stream_type);
                }
            }

            if (i < 0)
            {
                sdp_message_free(pRemoteSDP);
                pRemoteSDP = NULL;
                SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 收到电视墙DC端的INVITE响应处理失败:逻辑设备ID=%s, 电视墙通道ID=%s, 原因=%s, TSU IP=%s, iRet=%d", pCrData->callee_id, pCrData->caller_id, (char*)"通知TSU添加转发任务失败", pCrData->tsu_ip, i);
                EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, the INVITE response to the DC side of the TV wall process failed:logic deviceID=%s, TV wall channel ID=%s, cause=%s, TSU IP=%s, iRet=%d", pCrData->callee_id, pCrData->caller_id, (char*)"notify TSU to add forwarding task failed", pCrData->tsu_ip, i);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_answer_dc_invite_response_proc() notify_tsu_add_transfer_task Error: TSU IP=%s, i=%d \r\n", pCrData->tsu_ip, i);
                return -1;
            }
            else
            {
                SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "电视墙业务, 收到电视墙DC端的INVITE响应处理:逻辑设备ID=%s, 电视墙通道ID=%s, 通知TSU添加转发任务成功, TSU IP=%s, task_id=%s, iRet=%d", pCrData->callee_id, pCrData->caller_id, pCrData->tsu_ip, pCrData->task_id, i);
                EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "TV wall, received the TV wall in the DC side INVITE response processing: logical device ID = % s, TV wall channel ID = % s, notify the TSU add forward mission success, TSU IP = % s, task_id = % s, iRet = % d", pCrData->callee_id, pCrData->caller_id, pCrData->tsu_ip, pCrData->task_id, i);
            }

            sdp_message_free(pRemoteSDP);
            pRemoteSDP = NULL;
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "电视墙业务, 收到电视墙DC端的INVITE响应处理成功:逻辑设备ID=%s, 电视墙通道ID=%s", pCrData->callee_id, pCrData->caller_id);
            EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "TV wall, received the TV wall in the DC side INVITE response processing success: logical device ID = % s, TV wall channel ID = % s", pCrData->callee_id, pCrData->caller_id);
            return 0;
        }
    }

    SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 收到电视墙DC端的INVITE响应处理失败:逻辑设备ID=%s, 电视墙通道ID=%s, 原因=%s, 错误码=%d", pCrData->callee_id, pCrData->caller_id, (char*)"收到电视墙DC端非200的错误响应消息", response_code);
    EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, the INVITE response to the DC side of the TV wall process failed:logic deviceID=%s, TV wall channel ID=%s, cause=%s, error code=%d", pCrData->callee_id, pCrData->caller_id, (char*)"receive non-200 failure response message from DC end of TV wall", response_code);
    return -1;
}

/*****************************************************************************
 函 数 名  : device_answer_source_invite_response_for_dc_proc
 功能描述  : 用户启动DC后收到源端的Invite响应处理
 输入参数  : cr_t* pCrData
             int response_code
             char* msg_body
             int msg_body_len
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年8月14日 星期三
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_answer_source_invite_response_for_dc_proc(cr_t * pCrData, int response_code, char * msg_body, int msg_body_len)
{
    int i = 0;
    int ua_index = -1;

    sdp_message_t* pRemoteSDP = NULL;
    sdp_param_t stRemoteSDPParam;
    sdp_extend_param_t stRemoteSDPExParam;

    if (NULL == pCrData)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_answer_source_invite_response_for_dc_proc() exit---: Param Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "电视墙业务, 收到源端逻辑设备的INVITE响应处理:逻辑设备ID=%s, 电视墙通道ID=%s", pCrData->callee_id, pCrData->caller_id);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "TV wall, received the source side INVITE response of the logical device processing: logical device ID = % s, TV wall channel ID = % s", pCrData->callee_id, pCrData->caller_id);

    /* 3、根据响应码作不同的处理 */
    if (200 == response_code)
    {
        if (NULL == msg_body || msg_body_len == 0)
        {
            SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 收到源端逻辑设备的INVITE响应处理失败:逻辑设备ID=%s, 电视墙通道ID=%s, 原因=%s", pCrData->callee_id, pCrData->caller_id, (char*)"获源端逻辑设备的SDP信息失败");
            EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, the INVITE response to the source end logic devic process failed:logic deviceID=%s, TV wall channel ID=%s, cause=%s", pCrData->callee_id, pCrData->caller_id, (char*)"Access SDP info from source end logic device failed");
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_answer_source_invite_response_for_dc_proc() exit---: Get Remote Message SDP Body Error \r\n");
            return -1;
        }

        /* 获取200消息中的被叫的sdp信息 */
        i = sdp_message_init(&pRemoteSDP);

        if (0 != i)
        {
            SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 收到源端逻辑设备的INVITE响应处理失败:逻辑设备ID=%s, 电视墙通道ID=%s, 原因=%s", pCrData->callee_id, pCrData->caller_id, (char*)"SDP初始化失败");
            EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, the INVITE response to the source end logic devic process failed:logic deviceID=%s, TV wall channel ID=%s, cause=%s", pCrData->callee_id, pCrData->caller_id, (char*)"SDP initialization failed");
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_answer_source_invite_response_for_dc_proc() exit---: Remote SDP Message Init Error \r\n");
            return -1;
        }

        i = sdp_message_parse(pRemoteSDP, msg_body); /*parse body */

        if (0 != i)
        {
            sdp_message_free(pRemoteSDP);
            pRemoteSDP = NULL;
            SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 收到源端逻辑设备的INVITE响应处理失败:逻辑设备ID=%s, 电视墙通道ID=%s, 原因=%s", pCrData->callee_id, pCrData->caller_id, (char*)"SDP信息解析失败");
            EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, the INVITE response to the source end logic devic process failed:logic deviceID=%s, TV wall channel ID=%s, cause=%s", pCrData->callee_id, pCrData->caller_id, (char*)"SDP info analysis failed");
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_answer_source_invite_response_for_dc_proc() exit---: Remote SDP Message Parse Error \r\n");
            return -1;
        }

        /* 获取协商的SDP信息 */
        memset(&stRemoteSDPParam, 0, sizeof(sdp_param_t));
        memset(&stRemoteSDPExParam, 0, sizeof(sdp_extend_param_t));

        i = SIP_GetSDPInfoEx(pRemoteSDP, &stRemoteSDPParam, &stRemoteSDPExParam);

        if (0 != i)
        {
            sdp_message_free(pRemoteSDP);
            pRemoteSDP = NULL;
            SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 收到源端逻辑设备的INVITE响应处理失败:逻辑设备ID=%s, 电视墙通道ID=%s, 原因=%s", pCrData->callee_id, pCrData->caller_id, (char*)"获取SDP中的信息失败");
            EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, the INVITE response to the source end logic devic process failed:logic deviceID=%s, TV wall channel ID=%s, cause=%s", pCrData->callee_id, pCrData->caller_id, (char*)"Access info from SDP failed");
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_answer_source_invite_response_for_dc_proc() exit---: Get SDP Video Info Error \r\n");
            return -1;
        }

        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_answer_source_invite_response_for_dc_proc() addr=%s,port=%d,code=%d,flag=%d \r\n", stRemoteSDPParam.sdp_ip, stRemoteSDPParam.video_port, stRemoteSDPParam.video_code_type, stRemoteSDPParam.media_direction);

        /* 判断前端设备的ONVIF URL */
        if (stRemoteSDPExParam.onvif_url[0] != '\0')
        {
            if (strlen(stRemoteSDPExParam.onvif_url) < 255)
            {
                osip_strncpy(pCrData->callee_onvif_url, stRemoteSDPExParam.onvif_url, strlen(stRemoteSDPExParam.onvif_url));
            }
            else
            {
                osip_strncpy(pCrData->callee_onvif_url, stRemoteSDPExParam.onvif_url, 255);
            }

            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_answer_source_invite_response_for_dc_proc() callee_onvif_url=%s \r\n", pCrData->callee_onvif_url);

            /* 被叫侧的协议类型改为RTSP */
            //pCrData->callee_transfer_type = TRANSFER_PROTOCOL_RTSP;
        }

        /* 添加源的SDP 信息 */
        osip_strncpy(pCrData->callee_sdp_ip, stRemoteSDPParam.sdp_ip, MAX_IP_LEN);
        pCrData->callee_sdp_port = stRemoteSDPParam.video_port;

        /* 添加TSU 的编码格式信息 */
        pCrData->tsu_code = stRemoteSDPParam.video_code_type;

        /* 发送呼叫请求到DC 端 */
        ua_index = device_send_invite_to_dc(pCrData);

        if (ua_index < 0)
        {
            sdp_message_free(pRemoteSDP);
            pRemoteSDP = NULL;
            SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 收到源端逻辑设备的INVITE响应处理失败:逻辑设备ID=%s, 电视墙通道ID=%s, 原因=%s", pCrData->callee_id, pCrData->caller_id, (char*)"发送INVITE消息到DC端失败");
            EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, the INVITE response to the source end logic devic process failed:logic deviceID=%s, TV wall channel ID=%s, cause=%s", pCrData->callee_id, pCrData->caller_id, (char*)"send INVITE message to DC end failed");
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_answer_source_invite_response_for_dc_proc() exit---: Device Send Invite To DEC Error \r\n");
            return -1;
        }

        sdp_message_free(pRemoteSDP);
        pRemoteSDP = NULL;

        pCrData->caller_ua_index = ua_index;

        /* 通知等待的呼叫任务，接受请求，通知TSU转发码流 */
        i = resumed_wait_answer_call_record1(pCrData);

        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "电视墙业务, 收到源端逻辑设备的INVITE响应处理成功:逻辑设备ID=%s, 电视墙通道ID=%s", pCrData->callee_id, pCrData->caller_id);
        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "TV wall, received the source side INVITE response of the logical device processing success: logical device ID = % s, TV wall channel ID = % s", pCrData->callee_id, pCrData->caller_id);
        return 0;
    }

    SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 收到源端逻辑设备的INVITE响应处理失败:逻辑设备ID=%s, 电视墙通道ID=%s, 原因=%s, 错误码=%d", pCrData->callee_id, pCrData->caller_id, (char*)"收到源端逻辑设备非200的错误响应消息", response_code);
    EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, the INVITE response to the source end logic devic process failed:logic deviceID=%s, TV wall channel ID=%s, cause=%s, error code=%d", pCrData->callee_id, pCrData->caller_id, (char*)"receive non-200 failure response message from source-end logic device", response_code);
    return -1;
}

/*****************************************************************************
 函 数 名  : device_send_invite_to_dc
 功能描述  : 发送请求到DC解码设备
 输入参数  : cr_t* pCrData
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年8月14日 星期三
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int device_send_invite_to_dc(cr_t * pCrData)
{
    int i = 0;
    int ua_index = -1;
    int send_port = 0;

    //char* sdp_ssrc = NULL;
    sdp_message_t* pLocalSDP = NULL;
    sdp_param_t sdp_param;
    sdp_extend_param_t sdp_exparam;
    char* sdp_tsu_ip = NULL;

    GBDevice_info_t* pDCGBDeviceInfo = NULL;
    GBLogicDevice_info_t* pDCGBLogicDeviceInfo = NULL;

    if (NULL == pCrData)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "device_send_invite_to_dc() exit---: Param Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "电视墙业务, 收到源端逻辑设备的INVITE响应, 发送INVITE消息到电视墙DC端:逻辑设备ID=%s, 电视墙通道ID=%s", pCrData->callee_id, pCrData->caller_id);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "TV wall, received the INVITE response of the logical device source end, sends the INVITE message to the TV wall in the DC side: logical device ID = % s, TV wall channel ID = % s ", pCrData->callee_id, pCrData->caller_id);

    /* 1、查找DC 逻辑设备信息 */
    pDCGBLogicDeviceInfo = GBLogicDevice_info_find(pCrData->caller_id);

    if (NULL == pDCGBLogicDeviceInfo)
    {
        SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 收到源端逻辑设备的INVITE响应, 发送INVITE消息到电视墙DC端失败:逻辑设备ID=%s, 电视墙通道ID=%s, 原因=%s", pCrData->callee_id, pCrData->caller_id, (char*)"没有找到电视墙通道逻辑设备信息");
        EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, receive source end logic device INVITE response, send INVITE message to TV wall DC side failed:logic deviceID=%s, TV wall channel ID=%s, cause=%s", pCrData->callee_id, pCrData->caller_id, (char*)"TV wall channel logic device info not found");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_send_invite_to_dc() exit---: Get DEC GBlogicDevice Info Error \r\n");
        return -1;
    }

    /* 2、查找对应的DC 物理设备 */
    pDCGBDeviceInfo = GBDevice_info_get_by_stream_type(pDCGBLogicDeviceInfo, EV9000_STREAM_TYPE_MASTER);

    if (NULL == pDCGBDeviceInfo)
    {
        SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 收到源端逻辑设备的INVITE响应, 发送INVITE消息到电视墙DC端失败:逻辑设备ID=%s, 电视墙通道ID=%s, 原因=%s", pCrData->callee_id, pCrData->caller_id, (char*)"没有找到电视墙物理设备信息");
        EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, receive source end logic device INVITE response, send INVITE message to TV wall DC side failed:logic deviceID=%s, TV wall channel ID=%s, cause=%s", pCrData->callee_id, pCrData->caller_id, (char*)"TV wall physical device info not found");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_send_invite_to_dc() exit---: Get DEC GBDevice Info Error \r\n");
        return -1;
    }

    if (!g_DECMediaTransferFlag
        && EV9000_DEVICETYPE_SIPSERVER == pCrData->callee_gb_device_type && pCrData->caller_sdp_port > 0) /* 下级平台媒体流不经过本级TSU转发 */
    {
        pCrData->tsu_send_port = pCrData->callee_sdp_port; /* 直接将前端的端口作为发送端口 */
        sdp_tsu_ip = pCrData->callee_sdp_ip; /* 直接取前端的IP地址 */
    }
    else
    {
        //发送端口号从新获取
        /* 获取TSU 发送端口号, 先判断一下主叫侧的链接类型，如果是TCP链接，先查看一下是否存在，如果存在，则使用原来的发送端口号 */
        if (TRANSFER_PROTOCOL_TCP == pCrData->caller_transfer_type)
        {
            //send_port = get_GBLogic_device_caller_tcp_send_port(pCrData->callee_id, pCrData->callee_stream_type);

            //if (send_port < 0)
            //{
            //send_port = get_send_port_by_tsu_resource(pCrData->tsu_ip);
            //}

            /* 不需要获取TSU的发送端口号, TSU的端口号在添加转发任务的时候返回 */
            send_port = 43111;
        }
        else
        {
            send_port = get_send_port_by_tsu_resource(pCrData->tsu_ip);
        }

        if (send_port <= 0)
        {
            SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 收到源端逻辑设备的INVITE响应, 发送INVITE消息到电视墙DC端失败:逻辑设备ID=%s, 电视墙通道ID=%s, 原因=%s, tsu_ip=%s ", pCrData->callee_id, pCrData->caller_id, (char*)"获取TSU的发送端口号失败", pCrData->tsu_ip);
            EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, receive source end logic device INVITE response, send INVITE message to TV wall DC side failed:logic deviceID=%s, TV wall channel ID=%s, cause=%s, tsu_ip=%s ", pCrData->callee_id, pCrData->caller_id, (char*)"Access TSU send port number failed", pCrData->tsu_ip);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_send_invite_to_dc() exit---: Get TSU Send Port Error:tsu_ip=%s \r\n", pCrData->tsu_ip);
            return -1;
        }

        pCrData->tsu_send_port = send_port;

        sdp_tsu_ip = get_cr_sdp_tsu_ip(pCrData, pCrData->caller_server_ip_ethname);

        if (NULL == sdp_tsu_ip)
        {
            SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 收到源端逻辑设备的INVITE响应, 发送INVITE消息到电视墙DC端失败:逻辑设备ID=%s, 电视墙通道ID=%s, 原因=%s, caller_server_ip_ethname=%s ", pCrData->callee_id, pCrData->caller_id, (char*)"获取主叫侧的SDP信息中的TSU的IP地址失败", pCrData->caller_server_ip_ethname);
            EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, receive source end logic device INVITE response, send INVITE message to TV wall DC side failed:logic deviceID=%s, TV wall channel ID=%s, cause=%s, caller_server_ip_ethname=%s ", pCrData->callee_id, pCrData->caller_id, (char*)"Access TUS IP address from called side SDP info failed", pCrData->caller_server_ip_ethname);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_send_invite_to_dc() exit---: Get Caller TSU SDP IP Error:caller_server_ip_ethname=%s \r\n", pCrData->caller_server_ip_ethname);
            return -1;
        }
    }

    /* 4、组建本地SDP信息*/
    memset(&sdp_param, 0, sizeof(sdp_param_t));
    osip_strncpy(sdp_param.o_username, local_cms_id_get(), 32);
    osip_strncpy(sdp_param.s_name, (char*)"Play", 32);
    osip_strncpy(sdp_param.sdp_ip, sdp_tsu_ip, MAX_IP_LEN);
    sdp_param.video_port = pCrData->tsu_send_port;
    sdp_param.video_code_type = pCrData->tsu_code;
    sdp_param.media_direction = MEDIA_DIRECTION_TYPE_SENDONLY;

    /* 被叫侧使用的码流类型，也需要带给解码器 */
    sdp_param.stream_type = pCrData->callee_stream_type;

    /* 传输方式赋值 */
    if (TRANSFER_PROTOCOL_TCP == pCrData->caller_transfer_type)
    {
        sdp_param.trans_type = 2;
    }
    else
    {
        sdp_param.trans_type = 1;
    }

    if (pCrData->callee_onvif_url[0] != '\0')
    {
        memset(&sdp_exparam, 0, sizeof(sdp_extend_param_t));

        osip_strncpy(sdp_exparam.onvif_url, pCrData->callee_onvif_url, 255);

        i = SIP_BuildSDPInfoEx(&pLocalSDP, &sdp_param, &sdp_exparam);
    }
    else
    {
        i = SIP_BuildSDPInfoEx(&pLocalSDP, &sdp_param, NULL);
    }

    if (0 != i)
    {
        sdp_message_free(pLocalSDP);
        pLocalSDP = NULL;

        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_send_invite_to_dc() exit---: SDP Build Offer Error:tsu_port=%d, local_sdp_code=%d \r\n", pCrData->tsu_send_port, pCrData->tsu_code);
        SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 收到源端逻辑设备的INVITE响应, 发送INVITE消息到电视墙DC端失败:逻辑设备ID=%s, 电视墙通道ID=%s, 原因=%s", pCrData->callee_id, pCrData->caller_id, (char*)"组建SDP消息失败");
        EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, receive source end logic device INVITE response, send INVITE message to TV wall DC side failed:logic deviceID=%s, TV wall channel ID=%s, cause=%s", pCrData->callee_id, pCrData->caller_id, (char*)"crear SDP massage failed");
        return -1;
    }

#if 0
    sdp_ssrc = sdp_message_y_ssrc_get(pLocalSDP);

    if (NULL == sdp_ssrc)
    {
        sdp_ssrc = osip_getcopy((char*)"0");
        sdp_message_y_ssrc_set(pLocalSDP, sdp_ssrc);
    }

#endif

    /* 5、发送呼叫给DC设备 */
    ua_index = SIP_SendInvite(pCrData->caller_id, pCrData->callee_id, pCrData->caller_server_ip, pCrData->caller_server_port, pCrData->caller_ip, pCrData->caller_port, NULL, NULL, pLocalSDP);
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "device_send_invite_to_dc() SIP_SendInvite:index=%d \r\n", ua_index);

    if (ua_index < 0)
    {
        sdp_message_free(pLocalSDP);
        pLocalSDP = NULL;

        SystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "电视墙业务, 收到源端逻辑设备的INVITE响应, 发送INVITE消息到电视墙DC端失败:逻辑设备ID=%s, 电视墙通道ID=%s, 原因=%s, ua_index=%d", pCrData->callee_id, pCrData->caller_id, (char*)"发送INVITE到电视墙DC端消息失败", ua_index);
        EnSystemLog(EV9000_CMS_CONNECT_TV_ERROR, EV9000_LOG_LEVEL_ERROR, "TV wall business, receive source end logic device INVITE response, send INVITE message to TV wall DC side failed:logic deviceID=%s, TV wall channel ID=%s, cause=%s", pCrData->callee_id, pCrData->caller_id, (char*)"send INVITE to DC end of TV wall message failed");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_send_invite_to_dc() exit---: SIP Send Invite Error \r\n");
        return -1;
    }

    sdp_message_free(pLocalSDP);
    pLocalSDP = NULL;

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "电视墙业务, 收到源端逻辑设备的INVITE响应, 发送INVITE消息到电视墙DC端成功:逻辑设备ID=%s, 电视墙通道ID=%s, 电视墙DC IP地址=%s, 端口号=%d, SIP会话句柄=%d", pCrData->callee_id, pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, ua_index);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "TV wall, received the INVITE response of the logical device source end, send the INVITE message to success: TV wall DC end logic device ID = % s, TV wall channel ID = % s, TV wall, DC = % s IP address, port number = % d, SIP session handle = % d", pCrData->callee_id, pCrData->caller_id, pCrData->caller_ip, pCrData->caller_port, ua_index);
    return ua_index;
}

/*****************************************************************************
 函 数 名  : StopDecService
 功能描述  : 停止DEC某个通道任务
 输入参数  : char* device_id
                            char* dec_id
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年8月28日 星期三
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int StopDecService(char * device_id, char * dec_id)
{
    int i = 0;
    int cr_pos = -1;
    int other_cr_pos = -1;
    cr_t* pOtherCrData = NULL;
    cr_t* pCrData = NULL;

    if ((NULL == dec_id) || (NULL == device_id))
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "StopDecService() exit---: Param Error \r\n");
        return -1;
    }

    if (device_id[0] == '\0' || dec_id[0] == '\0')
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "StopDecService() exit---: device_id or dec_id Error: device_id=%s, dec_id=%s \r\n", device_id, dec_id);
        return -1;
    }

    if ((device_id[0] == '0' && strlen(device_id) == 1) || (dec_id[0] == '0' && strlen(dec_id) == 1))
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "StopDecService() exit---: device_id or dec_id Error: device_id=%s, dec_id=%s \r\n", device_id, dec_id);
        return -1;
    }

    /* 1、根据DEC 端的Dialog Index 查找呼叫记录信息 */
    cr_pos = call_record_find_by_callerid_and_calleeid(dec_id, device_id);
    //DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDecService() call_record_find_by_callerid_and_calleeid:cr_pos=%d \r\n", cr_pos);

    if (cr_pos < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "StopDecService() exit---: Not Find Call Record Info:dec_id=%s, device_id=%s, cr_pos=%d \r\n", dec_id, device_id, cr_pos);
        return 0;
    }

    pCrData = call_record_get(cr_pos);

    if (NULL == pCrData)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "StopDecService() exit---: Get Call Record Error \r\n");
        return -1;
    }

    /* 2、查看呼叫记录类型是否是DC */
    if (CALL_TYPE_DC != pCrData->call_type)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "StopDecService() exit---: Call Record Type Error \r\n");
        return -1;
    }

    /* 3、查看呼叫记录里面的主被叫是否匹配 */
    if (0 != sstrcmp(pCrData->caller_id, dec_id))
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "StopDecService() exit---: Call Record Caller Not Equal \r\n");
        return -1;
    }

    /* 4、通知TSU停止接收码流*/
    if ((CALL_TYPE_RECORD_PLAY == pCrData->call_type)
        || (CALL_TYPE_DOWNLOAD == pCrData->call_type))
    {
        i = notify_tsu_delete_replay_task(pCrData->tsu_ip, pCrData->task_id);

        if (i < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "StopDecService() notify_tsu_delete_replay_task Error:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDecService() notify_tsu_delete_replay_task OK:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
        }
    }
    else
    {
        i = notify_tsu_delete_transfer_task(pCrData->tsu_ip, pCrData->task_id);

        if (i < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "StopDecService() notify_tsu_delete_transfer_task Error:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDecService() notify_tsu_delete_transfer_task OK:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
        }
    }

    /*5、发送Bye 给主叫侧 */
    i = SIP_SendBye(pCrData->caller_ua_index);
    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDecService() SIP_SendBye To Caller:caller_ua_index=%d, i=%d \r\n", pCrData->caller_ua_index, i);

    /* 看是否有前端连接 */
    if (pCrData->callee_ua_index >= 0)
    {
        /* 查看是否有其他客户端业务 */
        other_cr_pos = is_GBLogic_device_has_other_service(pCrData->callee_id, pCrData->callee_stream_type, cr_pos);
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDecService() is_GBLogic_device_has_other_service:other_cr_pos=%d \r\n", other_cr_pos);

        if (other_cr_pos < 0) /* 没有其他业务 */
        {
            /*发送Bye 给被叫侧 */
            i = SIP_SendBye(pCrData->callee_ua_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDecService() SIP_SendBye To Callee:callee_ua_index=%d, i=%d \r\n", pCrData->callee_ua_index, i);
        }
        else
        {
            pOtherCrData = call_record_get(other_cr_pos);

            if (NULL != pOtherCrData)
            {
                pOtherCrData->callee_ua_index = pCrData->callee_ua_index; /* 将前端的会话句柄拷贝到下个业务 */
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDecService() callee_ua_index=%d copy from %d to %d \r\n", pOtherCrData->callee_ua_index, cr_pos, other_cr_pos);
            }
        }
    }

    /* 6、移除呼叫记录信息 */
    i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
    i = call_record_remove(cr_pos);

    if (0 != i)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "StopDecService() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "StopDecService() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
    }

    return 0;
}

/*****************************************************************************
 函 数 名  : StopDecServiceByDecInfo
 功能描述  : 根据解码器侧的的SDP信息停止电视墙业务
 输入参数  : char* dec_id
             char* dec_sdp_ip
             int dec_sdp_port
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2015年5月11日 星期一
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int StopDecServiceByDecInfo(char * dec_id, char * dec_sdp_ip, int dec_sdp_port)
{
    int i = 0;
    int cr_pos = -1;
    int other_cr_pos = -1;
    cr_t* pOtherCrData = NULL;
    cr_t* pCrData = NULL;

    if ((NULL == dec_sdp_ip) || (NULL == dec_id) || dec_sdp_port <= 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "StopDecServiceByDecInfo() exit---: Param Error \r\n");
        return -1;
    }

    /* 1、根据DEC 端的Dialog Index 查找呼叫记录信息 */
    cr_pos = call_record_find_by_callerinfo(dec_id, dec_sdp_ip, dec_sdp_port);
    //DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDecService() call_record_find_by_callerid_and_calleeid:cr_pos=%d \r\n", cr_pos);

    if (cr_pos < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "StopDecServiceByDecInfo() exit---: Not Find Call Record Info:dec_id=%s, dec_sdp_ip=%s, dec_sdp_port=%d, cr_pos=%d \r\n", dec_id, dec_sdp_ip, dec_sdp_port, cr_pos);
        return 0;
    }

    pCrData = call_record_get(cr_pos);

    if (NULL == pCrData)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "StopDecServiceByDecInfo() exit---: Get Call Record Error \r\n");
        return -1;
    }

    /* 2、通知TSU停止接收码流*/
    if ((CALL_TYPE_RECORD_PLAY == pCrData->call_type)
        || (CALL_TYPE_DOWNLOAD == pCrData->call_type))
    {
        i = notify_tsu_delete_replay_task(pCrData->tsu_ip, pCrData->task_id);

        if (i < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "StopDecServiceByDecInfo() notify_tsu_delete_replay_task Error:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDecServiceByDecInfo() notify_tsu_delete_replay_task OK:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
        }
    }
    else
    {
        i = notify_tsu_delete_transfer_task(pCrData->tsu_ip, pCrData->task_id);

        if (i < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "StopDecServiceByDecInfo() notify_tsu_delete_transfer_task Error:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDecServiceByDecInfo() notify_tsu_delete_transfer_task OK:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
        }
    }

    /*3、发送Bye 给主叫侧 */
    i = SIP_SendBye(pCrData->caller_ua_index);
    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDecServiceByDecInfo() SIP_SendBye To Caller:caller_ua_index=%d, i=%d \r\n", pCrData->caller_ua_index, i);

    /* 看是否有前端连接 */
    if (pCrData->callee_ua_index >= 0)
    {
        /* 查看是否有其他客户端业务 */
        other_cr_pos = is_GBLogic_device_has_other_service(pCrData->callee_id, pCrData->callee_stream_type, cr_pos);
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDecServiceByDecInfo() is_GBLogic_device_has_other_service:other_cr_pos=%d \r\n", other_cr_pos);

        if (other_cr_pos < 0) /* 没有其他业务 */
        {
            /*发送Bye 给被叫侧 */
            i = SIP_SendBye(pCrData->callee_ua_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDecServiceByDecInfo() SIP_SendBye To Callee:callee_ua_index=%d, i=%d \r\n", pCrData->callee_ua_index, i);
        }
        else
        {
            pOtherCrData = call_record_get(other_cr_pos);

            if (NULL != pOtherCrData)
            {
                pOtherCrData->callee_ua_index = pCrData->callee_ua_index; /* 将前端的会话句柄拷贝到下个业务 */
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDecServiceByDecInfo() callee_ua_index=%d copy from %d to %d \r\n", pOtherCrData->callee_ua_index, cr_pos, other_cr_pos);
            }
        }
    }

    /* 4、移除呼叫记录信息 */
    i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
    i = call_record_remove(cr_pos);

    if (0 != i)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "StopDecServiceByDecInfo() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "StopDecServiceByDecInfo() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
    }

    return 0;
}

/*****************************************************************************
 函 数 名  : StopDiagnosisService
 功能描述  : 停止视频诊断或者分析任务
 输入参数  : char* device_id
             char* caller_id
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2015年1月21日 星期三
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int StopDiagnosisService(char * device_id, char * caller_id)
{
    int i = 0;
    int cr_pos = -1;
    int other_cr_pos = -1;
    cr_t* pOtherCrData = NULL;
    cr_t* pCrData = NULL;

    if ((NULL == caller_id) || (NULL == device_id))
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "StopDiagnosisService() exit---: Param Error \r\n");
        return -1;
    }

    /* 1、根据DEC 端的Dialog Index 查找呼叫记录信息 */
    cr_pos = call_record_find_by_callerid_and_calleeid(caller_id, device_id);
    //DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDecService() call_record_find_by_callerid_and_calleeid:cr_pos=%d \r\n", cr_pos);

    if (cr_pos < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "StopDiagnosisService() exit---: Not Find Call Record Info:dec_id=%s, device_id=%s, cr_pos=%d \r\n", caller_id, device_id, cr_pos);
        return 0;
    }

    pCrData = call_record_get(cr_pos);

    if (NULL == pCrData)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "StopDiagnosisService() exit---: Get Call Record Error \r\n");
        return -1;
    }

    /* 2、查看呼叫记录里面的主被叫是否匹配 */
    if (0 != sstrcmp(pCrData->caller_id, caller_id))
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "StopDiagnosisService() exit---: Call Record Caller Not Equal \r\n");
        return -1;
    }

    /* 3、通知TSU停止接收码流*/
    if ((CALL_TYPE_RECORD_PLAY == pCrData->call_type)
        || (CALL_TYPE_DOWNLOAD == pCrData->call_type))
    {
        i = notify_tsu_delete_replay_task(pCrData->tsu_ip, pCrData->task_id);

        if (i < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "StopDiagnosisService() notify_tsu_delete_replay_task Error:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDiagnosisService() notify_tsu_delete_replay_task OK:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
        }
    }
    else
    {
        i = notify_tsu_delete_transfer_task(pCrData->tsu_ip, pCrData->task_id);

        if (i < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "StopDiagnosisService() notify_tsu_delete_transfer_task Error:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDiagnosisService() notify_tsu_delete_transfer_task OK:tsu_ip=%s, task_id=%s, i=%d \r\n", pCrData->tsu_ip, pCrData->task_id, i);
        }
    }

    /* 4、发送Bye 给主叫侧 */
    i = SIP_SendBye(pCrData->caller_ua_index);
    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDiagnosisService() SIP_SendBye To Caller:caller_ua_index=%d, i=%d \r\n", pCrData->caller_ua_index, i);

    /* 看是否有前端连接 */
    if (pCrData->callee_ua_index >= 0)
    {
        /* 查看是否有其他客户端业务 */
        other_cr_pos = is_GBLogic_device_has_other_service(pCrData->callee_id, pCrData->callee_stream_type, cr_pos);
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDiagnosisService() is_GBLogic_device_has_other_service:other_cr_pos=%d \r\n", other_cr_pos);

        if (other_cr_pos < 0) /* 没有其他业务 */
        {
            /*发送Bye 给被叫侧 */
            i = SIP_SendBye(pCrData->callee_ua_index);
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDiagnosisService() SIP_SendBye To Callee:callee_ua_index=%d, i=%d \r\n", pCrData->callee_ua_index, i);
        }
        else
        {
            pOtherCrData = call_record_get(other_cr_pos);

            if (NULL != pOtherCrData)
            {
                pOtherCrData->callee_ua_index = pCrData->callee_ua_index; /* 将前端的会话句柄拷贝到下个业务 */
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "StopDiagnosisService() callee_ua_index=%d copy from %d to %d \r\n", pOtherCrData->callee_ua_index, cr_pos, other_cr_pos);
            }
        }
    }

    /* 5、移除呼叫记录信息 */
    i = call_record_set_call_status(cr_pos, CALL_STATUS_WAIT_RELEASE);
    i = call_record_remove(cr_pos);

    if (0 != i)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "StopDiagnosisService() call_record_remove Error:cr_pos=%d, i=%d \r\n", cr_pos, i);
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "StopDiagnosisService() call_record_remove OK:cr_pos=%d, i=%d \r\n", cr_pos, i);
    }

    return 0;
}

/*****************************************************************************
 函 数 名  : DeleteLogicDeviceGroupConfigByCMSID
 功能描述  : 根据CMSID删除逻辑设备分组配置表数据
 输入参数  : char* cms_id
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年2月13日 星期四
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int DeleteLogicDeviceGroupConfigByCMSID(char * cms_id, DBOper * pDevice_Srv_dboper)
{
    int iRet = 0;
    string strDeltetSQL = "";

    if (NULL == cms_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "DeleteLogicDeviceGroupConfigByCMSID() exit---: Param Error \r\n");
        return -1;
    }

    /* 删除SQL语句 */
    strDeltetSQL.clear();
    strDeltetSQL = "delete from LogicDeviceGroupConfig WHERE CMSID like '";
    strDeltetSQL += cms_id;
    strDeltetSQL += "'";

    iRet = pDevice_Srv_dboper->DB_Delete(strDeltetSQL.c_str(), 1);

    if (iRet < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "DeleteLogicDeviceGroupConfigByCMSID() DB Oper Error:strDeltetSQL=%s, iRet=%d \r\n", strDeltetSQL.c_str(), iRet);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "DeleteLogicDeviceGroupConfigByCMSID() ErrorMsg=%s\r\n", pDevice_Srv_dboper->GetLastDbErrorMsg());
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "DeleteLogicDeviceGroupConfigByCMSID() Delete Count=%d\r\n", iRet);
    }

    return iRet;
}

/*****************************************************************************
 函 数 名  : DeleteLogicDeviceMapGroupConfigByCMSID
 功能描述  : 根据CMSID删除逻辑设备分组关系配置表数据
 输入参数  : char* cms_id
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年2月13日 星期四
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int DeleteLogicDeviceMapGroupConfigByCMSID(char * cms_id, DBOper * pDevice_Srv_dboper)
{
    int iRet = 0;
    string strDeltetSQL = "";

    if (NULL == cms_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "DeleteLogicDeviceMapGroupConfigByCMSID() exit---: Param Error \r\n");
        return -1;
    }

    /* 删除SQL语句 */
    strDeltetSQL.clear();
    strDeltetSQL = "delete from LogicDeviceMapGroupConfig WHERE CMSID like '";
    strDeltetSQL += cms_id;
    strDeltetSQL += "'";

    iRet = pDevice_Srv_dboper->DB_Delete(strDeltetSQL.c_str(), 1);

    if (iRet < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "DeleteLogicDeviceMapGroupConfigByCMSID() DB Oper Error:strDeltetSQL=%s, iRet=%d \r\n", strDeltetSQL.c_str(), iRet);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "DeleteLogicDeviceMapGroupConfigByCMSID() ErrorMsg=%s\r\n", pDevice_Srv_dboper->GetLastDbErrorMsg());
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "DeleteLogicDeviceMapGroupConfigByCMSID() Delete Count=%d\r\n", iRet);
    }

    return iRet;
}

/*****************************************************************************
 函 数 名  : GetGBDeviceListAndSendCataLogToDeviceClient
 功能描述  : 前端设备发送过来的获取设备信息并将其发送给设备客户端
 输入参数  : GBDevice_info_t* pGBDeviceInfo
             char* caller_id
             char* strDeviceID
             char* strSN
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年8月6日 星期三
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int GetGBDeviceListAndSendCataLogToDeviceClient(GBDevice_info_t * pGBDeviceInfo, char * caller_id, char * strDeviceID, char * strSN, DBOper * pDevice_Srv_dboper)
{
    int i = 0;
    int index = 0;
    int record_count = 0; /* 记录数 */
    int send_count = 0;   /* 发送的次数 */
    int query_count = 0;  /* 查询数据统计 */
    DOMElement* ListAccNode = NULL;

    string strSQL = "";
    vector<string> DeviceIDVector;

    if (NULL == pGBDeviceInfo)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "GetGBDeviceListAndSendCataLogToDeviceClient() exit---: GBDevice Info Error \r\n");
        return -1;
    }

    if ((NULL == caller_id) || (NULL == strDeviceID) || (NULL == strSN) || (NULL == pDevice_Srv_dboper))
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "GetGBDeviceListAndSendCataLogToDeviceClient() exit---: Param Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备获取设逻辑备信息:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
    EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment set logic for information: ID = % s front-end equipment, IP address = % s, port = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);

    /* 上级cms查询的设备列表是本级cms中所有设备列表
     */
    DeviceIDVector.clear();

    /* 添加所有的逻辑设备 */
    i = AddAllGBLogicDeviceIDToVectorForDevice(DeviceIDVector, pGBDeviceInfo->device_type, pDevice_Srv_dboper);

    /* 4、获取容器中的设备个数 */
    record_count = DeviceIDVector.size();

    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "GetGBDeviceListAndSendCataLogToDeviceClient() device_type=%d, record_count=%d \r\n", pGBDeviceInfo->device_type, record_count);

    /* 5、如果记录数为0 */
    if (record_count == 0)
    {
        /* 回复响应,组建消息 */
        CPacket outPacket;
        DOMElement* AccNode = NULL;

        outPacket.SetRootTag("Response");

        AccNode = outPacket.CreateElement((char*)"CmdType");
        outPacket.SetElementValue(AccNode, (char*)"Catalog");

        AccNode = outPacket.CreateElement((char*)"SN");
        outPacket.SetElementValue(AccNode, strSN);

        AccNode = outPacket.CreateElement((char*)"DeviceID");

        if (NULL != strDeviceID)
        {
            outPacket.SetElementValue(AccNode, strDeviceID);
        }
        else
        {
            outPacket.SetElementValue(AccNode, (char*)"");
        }

        AccNode = outPacket.CreateElement((char*)"Result");
        outPacket.SetElementValue(AccNode, (char*)"OK");

        AccNode = outPacket.CreateElement((char*)"SumNum");
        outPacket.SetElementValue(AccNode, (char*)"0");

        ListAccNode = outPacket.CreateElement((char*)"DeviceList");
        outPacket.SetElementAttr(ListAccNode, (char*)"Num", (char*)"0");

        /* 转发消息给上级CMS */
        i = SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pGBDeviceInfo->strRegServerIP, pGBDeviceInfo->iRegServerPort, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)outPacket.GetXml(NULL).c_str(), outPacket.GetXml(NULL).length());

        if (i != 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "GetGBDeviceListAndSendCataLogToDeviceClient() SIP_SendMessage Error:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "GetGBDeviceListAndSendCataLogToDeviceClient() SIP_SendMessage OK:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
        }

        SystemLog(EV9000_CMS_GET_CATALOG_ERROR, EV9000_LOG_LEVEL_WARNING, "前端设备获取逻辑设备信息信息失败:前端设备ID=%s, IP地址=%s, 端口号=%d, 原因=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"未查询到数据库记录");
        EnSystemLog(EV9000_CMS_GET_CATALOG_ERROR, EV9000_LOG_LEVEL_WARNING, "Front-end device accress logic device info failed:requesterID=%s, IPaddress=%s, port number=%d, cause=%s", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)"database record not found");
        DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "GetGBDeviceListAndSendCataLogToDeviceClient() exit---: No Record Count \r\n");
        return i;
    }

    /* 6、循环查找容器，读取用户的设备信息，加入xml中 */
    CPacket* pOutPacket = NULL;

    /* 如果是智能诊断或者智能分析设备，泽发送点位ID和名称即可 */
    if (EV9000_DEVICETYPE_VIDEODIAGNOSIS == pGBDeviceInfo->device_type
        || EV9000_DEVICETYPE_INTELLIGENTANALYSIS == pGBDeviceInfo->device_type)
    {
        for (index = 0; index < record_count; index++)
        {
            //DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "RouteGetGBDeviceListAndSendCataLogToCMS() DeviceIndex=%u \r\n", device_index);

            /* 如果记录数大于4，则要分次发送 */
            query_count++;

            /* 创建XML头部 */
            i = CreateGBLogicDeviceCatalogResponseXMLHeadForDevice(&pOutPacket, query_count, record_count, strSN, strDeviceID, &ListAccNode);

            /* 加入Item 值 */
            i = AddLogicDeviceInfoToXMLItemForDevice(pOutPacket, ListAccNode, (char*)DeviceIDVector[index].c_str(), pDevice_Srv_dboper);

            if ((query_count % MAX_DEVICE_CATALOG_COUT_SEND == 0) || (query_count == record_count))
            {
                if (NULL != pOutPacket)
                {
                    send_count++;
                    /* 转发消息给上级CMS */
                    i |= SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pGBDeviceInfo->strRegServerIP, pGBDeviceInfo->iRegServerPort, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)pOutPacket->GetXml(NULL).c_str(), pOutPacket->GetXml(NULL).length());

                    if (i != 0)
                    {
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备获取设逻辑备信息, 发送Message消息到前端设备失败:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "Front-end equipment set logic for information, Message sending messages to the front-end equipment failure: device ID = % s recently, = % s IP address, port number = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "GetGBDeviceListAndSendCataLogToDeviceClient() SIP_SendMessage Error:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    }
                    else
                    {
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备获取设逻辑备信息, 发送Message消息到前端设备成功:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment set logic for information, Message sending messages to the front-end equipment success: device ID = % s recently, = % s IP address, port number = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "GetGBDeviceListAndSendCataLogToDeviceClient() SIP_SendMessage OK:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    }

                    delete pOutPacket;
                    pOutPacket = NULL;
                }
            }
        }
    }
    else
    {
        for (index = 0; index < record_count; index++)
        {
            //DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "RouteGetGBDeviceListAndSendCataLogToCMS() DeviceIndex=%u \r\n", device_index);

            /* 如果记录数大于4，则要分次发送 */
            query_count++;

            /* 创建XML头部 */
            i = CreateGBLogicDeviceCatalogResponseXMLHeadForRoute(&pOutPacket, query_count, record_count, strSN, strDeviceID, &ListAccNode);

            /* 加入Item 值 */
            i = AddLogicDeviceInfoToXMLItemForRoute(pOutPacket, ListAccNode, (char*)DeviceIDVector[index].c_str(), 0, pDevice_Srv_dboper);

            if ((query_count % MAX_ROUTE_CATALOG_COUT_SEND == 0) || (query_count == record_count))
            {
                if (NULL != pOutPacket)
                {
                    send_count++;
                    /* 转发消息给上级CMS */
                    i |= SIP_SendMessage(NULL, local_cms_id_get(), caller_id, pGBDeviceInfo->strRegServerIP, pGBDeviceInfo->iRegServerPort, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port, (char*)pOutPacket->GetXml(NULL).c_str(), pOutPacket->GetXml(NULL).length());

                    if (i != 0)
                    {
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "前端设备获取设逻辑备信息Message消息到前端设备失败:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "Front-end equipment set logic for information Message Message to the front-end equipment failure: ID = % s front-end equipment, IP address = % s, port = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "GetGBDeviceListAndSendCataLogToDeviceClient() SIP_SendMessage Error:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    }
                    else
                    {
                        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "前端设备获取设逻辑备信息Message消息到前端设备成功:前端设备ID=%s, IP地址=%s, 端口号=%d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        EnSystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "Front-end equipment set logic for information Message Message to the front-end equipment success: ID = % s front-end equipment, IP address = % s, port = % d", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "GetGBDeviceListAndSendCataLogToDeviceClient() SIP_SendMessage OK:caller_id=%s, caller_ip=%s, caller_port=%d \r\n", caller_id, pGBDeviceInfo->login_ip, pGBDeviceInfo->login_port);
                    }

                    delete pOutPacket;
                    pOutPacket = NULL;
                }
            }
        }
    }

    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "GetGBDeviceListAndSendCataLogToDeviceClient Exit--- \r\n");

    return 0;
}

/*****************************************************************************
 函 数 名  : AddTopologyPhyDeviceInfo2DB
 功能描述  : 添加拓扑物理设备配置到数据库
 输入参数  : char* strDeviceID
             char* strDeviceName
             char* strDeviceType
             char* strDeviceIP
             char* strStatus
             char* strCMSID
             char* strLinkType
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年11月27日 星期四
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int AddTopologyPhyDeviceInfo2DB(char * strDeviceID, char * strDeviceName, char * strDeviceType, char * strDeviceIP, char * strStatus, char * strCMSID, char * strLinkType, DBOper * pDevice_Srv_dboper)
{
    int iRet = 0;
    int record_count = 0;
    string strQuerySQL = "";
    string strInsertSQL = "";
    string strUpdateSQL = "";

    string strTmpDeviceName = "";
    int iTmpDeviceType = 0;
    string strTmpDeviceIP = "";
    int iTmpStatus = 0;
    string strTmpCMSID = "";
    int iTmpLinkType = 0;

    if (NULL == strDeviceID || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "AddTopologyPhyDeviceInfo2DB() exit---: Param Error \r\n");
        return -1;
    }

    if (strDeviceID[0] == '\0')
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "UpdateBoardConfigTableStatus() exit---:  DeviceID NULL \r\n");
        return -1;
    }

    /* 1、查询SQL 语句*/
    strQuerySQL.clear();
    strQuerySQL = "select * from TopologyPhyDeviceConfig WHERE DeviceID like '";
    strQuerySQL += strDeviceID;
    strQuerySQL += "'";

    /* 2、插入SQL 语句*/
    strInsertSQL.clear();
    strInsertSQL = "insert into TopologyPhyDeviceConfig (DeviceID,DeviceName,DeviceType,DeviceIP,Status,CMSID,LinkType) values (";

    /* 设备ID */
    strInsertSQL += "'";
    strInsertSQL += strDeviceID;
    strInsertSQL += "'";

    strInsertSQL += ",";

    /* 设备名称 */
    strInsertSQL += "'";

    if (NULL != strDeviceName)
    {
        strInsertSQL += strDeviceName;
    }
    else
    {
        strInsertSQL += "";
    }

    strInsertSQL += "'";

    strInsertSQL += ",";

    /* 设备类型 */
    if (NULL != strDeviceType)
    {
        strInsertSQL += strDeviceType;
    }
    else
    {
        strInsertSQL += "";
    }

    strInsertSQL += ",";

    /* 设备IP */
    strInsertSQL += "'";

    if (NULL != strDeviceIP)
    {
        strInsertSQL += strDeviceIP;
    }
    else
    {
        strInsertSQL += "";
    }

    strInsertSQL += "'";

    strInsertSQL += ",";

    /* 状态 */
    if (NULL != strStatus)
    {
        strInsertSQL += strStatus;
    }
    else
    {
        strInsertSQL += "";
    }

    strInsertSQL += ",";

    /* 所属的CMS ID */
    strInsertSQL += "'";

    if (NULL != strCMSID)
    {
        strInsertSQL += strCMSID;
    }
    else
    {
        strInsertSQL += "";
    }

    strInsertSQL += "'";

    strInsertSQL += ",";

    /* 是否同级 */
    if (NULL != strLinkType)
    {
        strInsertSQL += strLinkType;
    }
    else
    {
        strInsertSQL += "";
    }

    strInsertSQL += ")";

    /* 查询数据库 */
    record_count = pDevice_Srv_dboper->DB_Select(strQuerySQL.c_str(), 1);

    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "AddTopologyPhyDeviceInfo2DB() DB Select:record_count=%d,DeviceID=%s \r\n", record_count, strDeviceID);

    if (record_count < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "AddTopologyPhyDeviceInfo2DB() DB Oper Error:strQuerySQL=%s, record_count=%d \r\n", strQuerySQL.c_str(), record_count);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "AddTopologyPhyDeviceInfo2DB() ErrorMsg=%s\r\n", pDevice_Srv_dboper->GetLastDbErrorMsg());
        return -1;
    }
    else if (record_count == 0)
    {
        iRet = pDevice_Srv_dboper->DB_Insert(strQuerySQL.c_str(), strUpdateSQL.c_str(), strInsertSQL.c_str(), 1);

        if (iRet < 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "AddTopologyPhyDeviceInfo2DB() DB Oper Error:strInsertSQL=%s, iRet=%d \r\n", strInsertSQL.c_str(), iRet);
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "AddTopologyPhyDeviceInfo2DB() ErrorMsg=%s\r\n", pDevice_Srv_dboper->GetLastDbErrorMsg());
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "AddTopologyPhyDeviceInfo2DB() strInsertSQL=%s, iRet=%d \r\n", strInsertSQL.c_str(), iRet);
        }

        /* 上报给上级CMS */
        iRet = SendNotifyTopologyPhyDeviceToRouteCMS(1, strDeviceID, strDeviceName, strDeviceType, strDeviceIP, strStatus, strCMSID, strLinkType);
    }
    else
    {
        /* 先获取数据库中已经有的数据，看看数据是否有变化，有变化就更新 */

        /* 设备名称 */
        strTmpDeviceName.clear();
        pDevice_Srv_dboper->GetFieldValue("DeviceName", strTmpDeviceName);

        /* 设备类型 */
        pDevice_Srv_dboper->GetFieldValue("DeviceType", iTmpDeviceType);

        /* 设备IP */
        strTmpDeviceIP.clear();
        pDevice_Srv_dboper->GetFieldValue("DeviceIP", strTmpDeviceIP);

        /* 设备状态 */
        pDevice_Srv_dboper->GetFieldValue("Status", iTmpStatus);

        /* 所属CMSID */
        strTmpCMSID.clear();
        pDevice_Srv_dboper->GetFieldValue("CMSID", strTmpCMSID);

        /* 是否同级 */
        pDevice_Srv_dboper->GetFieldValue("LinkType", iTmpLinkType);

        /* 需要更新 */
        if (0 != sstrcmp((char*)strTmpDeviceName.c_str(), strDeviceName)
            || iTmpDeviceType != osip_atoi(strDeviceType)
            || 0 != sstrcmp((char*)strTmpDeviceIP.c_str(), strDeviceIP)
            || 0 != sstrcmp((char*)strTmpCMSID.c_str(), strCMSID)
            || iTmpLinkType != osip_atoi(strLinkType))
        {
            /* 3、更新SQL 语句*/
            strUpdateSQL.clear();
            strUpdateSQL = "UPDATE TopologyPhyDeviceConfig SET ";

            /* 设备名称 */
            strUpdateSQL += "DeviceName = ";
            strUpdateSQL += "'";

            if (NULL != strDeviceName)
            {
                strUpdateSQL += strDeviceName;
            }
            else
            {
                strUpdateSQL += "";
            }

            strUpdateSQL += "'";

            strUpdateSQL += ",";

            /* 设备类型 */
            strUpdateSQL += "DeviceType = ";

            if (NULL != strDeviceType)
            {
                strUpdateSQL += strDeviceType;
            }
            else
            {
                strUpdateSQL += "";
            }

            strUpdateSQL += ",";

            /* 设备IP */
            strUpdateSQL += "DeviceIP = ";
            strUpdateSQL += "'";

            if (NULL != strDeviceIP)
            {
                strUpdateSQL += strDeviceIP;
            }
            else
            {
                strUpdateSQL += "";
            }

            strUpdateSQL += "'";

            strUpdateSQL += ",";


            /* 状态 */
            strUpdateSQL += "Status = ";

            if (NULL != strStatus)
            {
                strUpdateSQL += strStatus;
            }
            else
            {
                strUpdateSQL += "0";
            }

            strUpdateSQL += ",";

            /* 所属的CMS ID */
            strUpdateSQL += "CMSID = ";
            strUpdateSQL += "'";

            if (NULL != strCMSID)
            {
                strUpdateSQL += strCMSID;
            }
            else
            {
                strUpdateSQL += "";
            }

            strUpdateSQL += "'";

            strUpdateSQL += ",";

            /* 是否同级 */
            strUpdateSQL += "LinkType = ";

            if (NULL != strLinkType)
            {
                strUpdateSQL += strLinkType;
            }
            else
            {
                strUpdateSQL += "";
            }

            strUpdateSQL += " WHERE DeviceID like '";
            strUpdateSQL += strDeviceID;
            strUpdateSQL += "'";

            iRet = pDevice_Srv_dboper->DB_Update(strUpdateSQL.c_str(), 1);

            if (iRet < 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "AddTopologyPhyDeviceInfo2DB() DB Oper Error:strUpdateSQL=%s, iRet=%d \r\n", strUpdateSQL.c_str(), iRet);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "AddTopologyPhyDeviceInfo2DB() ErrorMsg=%s\r\n", pDevice_Srv_dboper->GetLastDbErrorMsg());
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "AddTopologyPhyDeviceInfo2DB() strUpdateSQL=%s, iRet=%d \r\n", strUpdateSQL.c_str(), iRet);
            }

            /* 上报给上级CMS */
            iRet = SendNotifyTopologyPhyDeviceToRouteCMS(3, strDeviceID, strDeviceName, strDeviceType, strDeviceIP, strStatus, strCMSID, strLinkType);
        }
        else if (0 == sstrcmp((char*)strTmpDeviceName.c_str(), strDeviceName)
                 && iTmpDeviceType == osip_atoi(strDeviceType)
                 && 0 == sstrcmp((char*)strTmpDeviceIP.c_str(), strDeviceIP)
                 && 0 == sstrcmp((char*)strTmpCMSID.c_str(), strCMSID)
                 && iTmpLinkType == osip_atoi(strLinkType)
                 && iTmpStatus != osip_atoi(strStatus)) /* 状态有变化 */
        {
            /* 3、更新SQL 语句*/
            strUpdateSQL.clear();
            strUpdateSQL = "UPDATE TopologyPhyDeviceConfig SET Status = ";

            if (NULL != strStatus)
            {
                strUpdateSQL += strStatus;
            }
            else
            {
                strUpdateSQL += "0";
            }

            strUpdateSQL += " WHERE DeviceID like '";
            strUpdateSQL += strDeviceID;
            strUpdateSQL += "'";

            iRet = pDevice_Srv_dboper->DB_Update(strUpdateSQL.c_str(), 1);

            if (iRet < 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "AddTopologyPhyDeviceInfo2DB() DB Oper Error:strUpdateSQL=%s, iRet=%d \r\n", strUpdateSQL.c_str(), iRet);
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "AddTopologyPhyDeviceInfo2DB() ErrorMsg=%s\r\n", pDevice_Srv_dboper->GetLastDbErrorMsg());
            }
            else
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "AddTopologyPhyDeviceInfo2DB() strUpdateSQL=%s, iRet=%d \r\n", strUpdateSQL.c_str(), iRet);
            }

            /* 上报给上级CMS */
            iRet = SendNotifyTopologyPhyDeviceToRouteCMS(4, strDeviceID, strDeviceName, strDeviceType, strDeviceIP, strStatus, strCMSID, strLinkType);
        }
    }

    return iRet;
}

/*****************************************************************************
 函 数 名  : UpdateTopologyPhyDeviceStatus2DB
 功能描述  : 更新拓扑物理设备状态到数据库
 输入参数  : char* strDeviceID
             char* strStatus
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年11月28日 星期五
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int UpdateTopologyPhyDeviceStatus2DB(char * strDeviceID, char * strStatus, DBOper * pDevice_Srv_dboper)
{
    int iRet = 0;
    string strUpdateSQL = "";

    if (NULL == strDeviceID || strDeviceID[0] == '\0' || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "UpdateTopologyPhyDeviceStatus2DB() exit---: Param Error \r\n");
        return -1;
    }

    /* 更新SQL 语句*/
    strUpdateSQL.clear();
    strUpdateSQL = "UPDATE TopologyPhyDeviceConfig SET Status = ";

    if (NULL != strStatus)
    {
        strUpdateSQL += strStatus;
    }
    else
    {
        strUpdateSQL += "0";
    }

    strUpdateSQL += " WHERE DeviceID like '";
    strUpdateSQL += strDeviceID;
    strUpdateSQL += "'";

    iRet = pDevice_Srv_dboper->DB_Update(strUpdateSQL.c_str(), 1);

    if (iRet < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "UpdateTopologyPhyDeviceStatus2DB() DB Oper Error:strUpdateSQL=%s, iRet=%d \r\n", strUpdateSQL.c_str(), iRet);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "UpdateTopologyPhyDeviceStatus2DB() ErrorMsg=%s\r\n", pDevice_Srv_dboper->GetLastDbErrorMsg());
    }

    /* 上报给上级CMS */
    iRet = SendNotifyTopologyPhyDeviceToRouteCMS(4, strDeviceID, (char*)"", (char*)"", (char*)"", strStatus, (char*)"", (char*)"");

    return iRet;
}

/*****************************************************************************
 函 数 名  : UpdateAllTopologyPhyDeviceStatus2DB
 功能描述  : 更新拓扑结构表的所有数据状态
 输入参数  : char* strStatus
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年11月28日 星期五
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int UpdateAllTopologyPhyDeviceStatus2DB(char * strStatus, DBOper * pDevice_Srv_dboper)
{
    int iRet = 0;
    int record_count = 0;
    int while_count = 0;
    string strQuerySQL = "";
    string strUpdateSQL = "";

    if (NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "UpdateAllTopologyPhyDeviceStatus2DB() exit---: Param Error \r\n");
        return -1;
    }

    /* 更新SQL 语句*/
    strUpdateSQL.clear();
    strUpdateSQL = "UPDATE TopologyPhyDeviceConfig SET Status = ";

    if (NULL != strStatus)
    {
        strUpdateSQL += strStatus;
    }
    else
    {
        strUpdateSQL += "0";
    }

    iRet = pDevice_Srv_dboper->DB_Update(strUpdateSQL.c_str(), 1);

    if (iRet < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "UpdateAllTopologyPhyDeviceStatus2DB() DB Oper Error:strUpdateSQL=%s, iRet=%d \r\n", strUpdateSQL.c_str(), iRet);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "UpdateAllTopologyPhyDeviceStatus2DB() ErrorMsg=%s\r\n", pDevice_Srv_dboper->GetLastDbErrorMsg());
    }

    /* 循环查找数据库，通报上级CMS */
    strQuerySQL.clear();
    strQuerySQL = "select * from TopologyPhyDeviceConfig";
    record_count = pDevice_Srv_dboper->DB_Select(strQuerySQL.c_str(), 1);

    if (record_count < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "UpdateAllTopologyPhyDeviceStatus2DB() DB Oper Error:strQuerySQL=%s, record_count=%d \r\n", strQuerySQL.c_str(), record_count);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "UpdateAllTopologyPhyDeviceStatus2DB() ErrorMsg=%s\r\n", pDevice_Srv_dboper->GetLastDbErrorMsg());
        return -1;
    }

    do
    {
        string strItemDeviceID = "";

        while_count++;

        if (while_count % 10000 == 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_WARN, "UpdateAllTopologyPhyDeviceStatus2DB() While Count=%d \r\n", while_count);
        }

        /* 设备ID */
        strItemDeviceID.clear();
        pDevice_Srv_dboper->GetFieldValue("DeviceID", strItemDeviceID);

        /* 上报给上级CMS */
        iRet = SendNotifyTopologyPhyDeviceToRouteCMS(4, (char*)strItemDeviceID.c_str(), (char*)"", (char*)"", (char*)"", strStatus, (char*)"", (char*)"");
    }
    while (pDevice_Srv_dboper->MoveNext() >= 0);

    return iRet;
}

/*****************************************************************************
 函 数 名  : DeleteTopologyPhyDeviceInfoFromDB
 功能描述  : 从数据库中删除拓扑物理设备配置信息
 输入参数  : char* device_id
             DBOper* pDevice_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2014年11月28日 星期五
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int DeleteTopologyPhyDeviceInfoFromDB(char * device_id, DBOper * pDevice_Srv_dboper)
{
    int iRet = 0;
    string strDeltetSQL = "";

    if (NULL == device_id || NULL == pDevice_Srv_dboper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "DeleteTopologyPhyDeviceInfoFromDB() exit---: Param Error \r\n");
        return -1;
    }

    /* 删除SQL语句 */
    strDeltetSQL.clear();
    strDeltetSQL = "delete from TopologyPhyDeviceConfig WHERE DeviceID like '";
    strDeltetSQL += device_id;
    strDeltetSQL += "'";

    iRet = pDevice_Srv_dboper->DB_Delete(strDeltetSQL.c_str(), 1);

    if (iRet < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "DeleteTopologyPhyDeviceInfoFromDB() DB Oper Error:strDeltetSQL=%s, iRet=%d \r\n", strDeltetSQL.c_str(), iRet);
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "DeleteTopologyPhyDeviceInfoFromDB() ErrorMsg=%s\r\n", pDevice_Srv_dboper->GetLastDbErrorMsg());
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "DeleteLogicDeviceGroupConfigByCMSID() Delete Count=%d\r\n", iRet);
    }

    /* 上报给上级CMS */
    iRet = SendNotifyTopologyPhyDeviceToRouteCMS(2, device_id, (char*)"", (char*)"", (char*)"", (char*)"", (char*)"", (char*)"");

    return iRet;
}

/*****************************************************************************
 函 数 名  : CreateGBLogicDeviceCatalogResponseXMLHeadForDevice
 功能描述  : 创建前端设备过来的获取逻辑设备列表回应消息XML头部
 输入参数  : CPacket** pOutPacket
             int query_count
             int record_count
             char* strSN
             char* strDeviceID
             DOMElement** ListAccNode
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年7月27日 星期六
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int CreateGBLogicDeviceCatalogResponseXMLHeadForDevice(CPacket** pOutPacket, int query_count, int record_count, char * strSN, char * strDeviceID, DOMElement** ListAccNode)
{
    DOMElement* AccNode = NULL;

    char strSumNum[32] = {0};
    char strRecordCount[32] = {0};

    snprintf(strSumNum, 32, "%d", record_count);

    /* 添加发送的xml头部 */
    if (query_count == 1)
    {
        *pOutPacket = new CPacket();

        if (NULL == *pOutPacket)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "CreateGBLogicDeviceCatalogResponseXMLHeadForDevice() exit---: Create XML Packet Error \r\n");
            return -1;
        }

        if (record_count <= MAX_DEVICE_CATALOG_COUT_SEND)
        {
            snprintf(strRecordCount, 32, "%d", record_count);
        }
        else
        {
            snprintf(strRecordCount, 32, "%d", MAX_DEVICE_CATALOG_COUT_SEND);
        }

        (*pOutPacket)->SetRootTag("Response");

        AccNode = (*pOutPacket)->CreateElement((char*)"CmdType");
        (*pOutPacket)->SetElementValue(AccNode, (char*)"Catalog");

        AccNode = (*pOutPacket)->CreateElement((char*)"SN");
        (*pOutPacket)->SetElementValue(AccNode, strSN);

        AccNode = (*pOutPacket)->CreateElement((char*)"DeviceID");
        (*pOutPacket)->SetElementValue(AccNode, strDeviceID);

        AccNode = (*pOutPacket)->CreateElement((char*)"SumNum");
        (*pOutPacket)->SetElementValue(AccNode, strSumNum);

        (*ListAccNode) = (*pOutPacket)->CreateElement((char*)"DeviceList");
        (*pOutPacket)->SetElementAttr((*ListAccNode), (char*)"Num", strRecordCount);
    }
    else if ((query_count % MAX_DEVICE_CATALOG_COUT_SEND == 1) && (record_count - query_count >= MAX_DEVICE_CATALOG_COUT_SEND))
    {
        *pOutPacket = new CPacket();

        if (NULL == *pOutPacket)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "CreateGBLogicDeviceCatalogResponseXMLHeadForDevice() exit---: Create XML Packet Error \r\n");
            return -1;
        }

        snprintf(strRecordCount, 32, "%d", MAX_DEVICE_CATALOG_COUT_SEND);
        (*pOutPacket)->SetRootTag("Response");

        AccNode = (*pOutPacket)->CreateElement((char*)"CmdType");
        (*pOutPacket)->SetElementValue(AccNode, (char*)"Catalog");

        AccNode = (*pOutPacket)->CreateElement((char*)"SN");
        (*pOutPacket)->SetElementValue(AccNode, strSN);

        AccNode = (*pOutPacket)->CreateElement((char*)"DeviceID");
        (*pOutPacket)->SetElementValue(AccNode, strDeviceID);

        AccNode = (*pOutPacket)->CreateElement((char*)"SumNum");
        (*pOutPacket)->SetElementValue(AccNode, strSumNum);

        (*ListAccNode) = (*pOutPacket)->CreateElement((char*)"DeviceList");
        (*pOutPacket)->SetElementAttr((*ListAccNode), (char*)"Num", strRecordCount);
    }
    else if ((query_count % MAX_DEVICE_CATALOG_COUT_SEND == 1) && (record_count - query_count < MAX_DEVICE_CATALOG_COUT_SEND))
    {
        *pOutPacket = new CPacket();

        if (NULL == *pOutPacket)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "CreateGBLogicDeviceCatalogResponseXMLHeadForDevice() exit---: Create XML Packet Error \r\n");
            return -1;
        }

        snprintf(strRecordCount, 32, "%d", record_count - query_count + 1);
        (*pOutPacket)->SetRootTag("Response");

        AccNode = (*pOutPacket)->CreateElement((char*)"CmdType");
        (*pOutPacket)->SetElementValue(AccNode, (char*)"Catalog");

        AccNode = (*pOutPacket)->CreateElement((char*)"SN");
        (*pOutPacket)->SetElementValue(AccNode, strSN);

        AccNode = (*pOutPacket)->CreateElement((char*)"DeviceID");
        (*pOutPacket)->SetElementValue(AccNode, strDeviceID);

        AccNode = (*pOutPacket)->CreateElement((char*)"SumNum");
        (*pOutPacket)->SetElementValue(AccNode, strSumNum);

        (*ListAccNode) = (*pOutPacket)->CreateElement((char*)"DeviceList");
        (*pOutPacket)->SetElementAttr((*ListAccNode), (char*)"Num", strRecordCount);
    }

    return 0;
}

/*****************************************************************************
 函 数 名  : AddLogicDeviceInfoToXMLItemForDevice
 功能描述  : 添加逻辑设备信息到XML的Item
 输入参数  : CPacket* pOutPacket
             DOMElement* ListAccNode
             char* device_id
             DBOper* pRoute_Srv_dboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年7月27日 星期六
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int AddLogicDeviceInfoToXMLItemForDevice(CPacket * pOutPacket, DOMElement * ListAccNode, char * device_id, DBOper * pRoute_Srv_dboper)
{
    int iRet = 0;
    GBLogicDevice_info_t* pGBLogicDeviceInfo = NULL;
    //GBLogicDevice_info_t* pDBGBLogicDeviceInfo = NULL;
    DOMElement* ItemAccNode = NULL;
    DOMElement* AccNode = NULL;

    char strID[64] = {0};

#if 0
    char strParental[16] = {0};
    char strSafetyWay[16] = {0};
    char strRegisterWay[16] = {0};
    char strCertifiable[16] = {0};
    char strErrCode[16] = {0};
    char strSecrecy[16] = {0};
    char strPort[16] = {0};
    char strLongitude[64] = {0};
    char strLatitude[64] = {0};
    char strAlarmDeviceSubType[64] = {0};
    char strStreamCount[16] = {0};
    char strFrameCount[16] = {0};
    char strAlarmLengthOfTime[16] = {0};
#endif

    if (NULL == pOutPacket || NULL == ListAccNode || NULL == device_id)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "AddLogicDeviceInfoToXMLItemForDevice() exit---: Param Error \r\n");
        return -1;
    }

    /* 填写XML数据*/
    pOutPacket->SetCurrentElement(ListAccNode);
    ItemAccNode = pOutPacket->CreateElement((char*)"Item");
    pOutPacket->SetCurrentElement(ItemAccNode);

    /* 根据Index 获取逻辑设备信息，可能是只配置了物理设备，还没有上线，数据库和内存中都没有的*/
    pGBLogicDeviceInfo = GBLogicDevice_info_find(device_id);

    if (NULL != pGBLogicDeviceInfo)
    {
        /* 设备索引 */
        AccNode = pOutPacket->CreateElement((char*)"ID");
        snprintf(strID, 64, "%u", pGBLogicDeviceInfo->id);
        pOutPacket->SetElementValue(AccNode, strID);

        /* 设备统一编号 */
        AccNode = pOutPacket->CreateElement((char*)"DeviceID");
        pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->device_id);

        /* 点位名称 */
        AccNode = pOutPacket->CreateElement((char*)"Name");
        pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->device_name);

        /* 是否可控 */
        AccNode = pOutPacket->CreateElement((char*)"CtrlEnable");

        if (1 == pGBLogicDeviceInfo->ctrl_enable)
        {
            pOutPacket->SetElementValue(AccNode, (char*)"Enable");
        }
        else
        {
            pOutPacket->SetElementValue(AccNode, (char*)"Disable");
        }

#if 0
        /* 是否启用*/
        AccNode = pOutPacket->CreateElement((char*)"Enable");

        if (0 == pGBLogicDeviceInfo->enable)
        {
            pOutPacket->SetElementValue(AccNode, (char*)"0");
        }
        else
        {
            pOutPacket->SetElementValue(AccNode, (char*)"1");
        }

        /* 是否支持对讲 */
        AccNode = pOutPacket->CreateElement((char*)"MicEnable");

        if (0 == pGBLogicDeviceInfo->mic_enable)
        {
            pOutPacket->SetElementValue(AccNode, (char*)"Disable");
        }
        else
        {
            pOutPacket->SetElementValue(AccNode, (char*)"Enable");
        }

        /* 帧率 */
        AccNode = pOutPacket->CreateElement((char*)"FrameCount");
        snprintf(strFrameCount, 16, "%d", pGBLogicDeviceInfo->frame_count);
        pOutPacket->SetElementValue(AccNode, strFrameCount);

        /* 是否支持多码流 */
        AccNode = pOutPacket->CreateElement((char*)"StreamCount");
        snprintf(strStreamCount, 16, "%d", pGBLogicDeviceInfo->stream_count);
        pOutPacket->SetElementValue(AccNode, strStreamCount);

        /* 告警时长 */
        AccNode = pOutPacket->CreateElement((char*)"AlarmLengthOfTime");
        snprintf(strAlarmLengthOfTime, 16, "%d", pGBLogicDeviceInfo->alarm_duration);
        pOutPacket->SetElementValue(AccNode, strAlarmLengthOfTime);

        /* 设备生产商 */
        AccNode = pOutPacket->CreateElement((char*)"Manufacturer");

        if (NULL != pGBLogicDeviceInfo->manufacturer)
        {
            pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->manufacturer);
        }
        else
        {
            pOutPacket->SetElementValue(AccNode, (char*)"");
        }

        /* 设备型号 */
        AccNode = pOutPacket->CreateElement((char*)"Model");

        if (NULL != pGBLogicDeviceInfo->model)
        {
            pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->model);
        }
        else
        {
            pOutPacket->SetElementValue(AccNode, (char*)"");
        }

        /* 设备归属 */
        AccNode = pOutPacket->CreateElement((char*)"Owner");

        if (NULL != pGBLogicDeviceInfo->owner)
        {
            pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->owner);
        }
        else
        {
            pOutPacket->SetElementValue(AccNode, (char*)"");
        }

        /* 行政区域 */
        AccNode = pOutPacket->CreateElement((char*)"CivilCode");

        if (NULL != pGBLogicDeviceInfo->virtualParentID)
        {
            pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->virtualParentID);
        }
        else
        {
            pOutPacket->SetElementValue(AccNode, local_civil_code_get());
        }

        /* 警区 */
        AccNode = pOutPacket->CreateElement((char*)"Block");

        if (NULL != pGBLogicDeviceInfo->block)
        {
            pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->block);
        }
        else
        {
            pOutPacket->SetElementValue(AccNode, (char*)"");
        }

        /* 安装地址 */
        AccNode = pOutPacket->CreateElement((char*)"Address");

        if (NULL != pGBLogicDeviceInfo->address)
        {
            pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->address);
        }
        else
        {
            pOutPacket->SetElementValue(AccNode, (char*)"");
        }

        /* 是否有子设备 */
        AccNode = pOutPacket->CreateElement((char*)"Parental");
        snprintf(strParental, 16, "%d", pGBLogicDeviceInfo->parental);
        pOutPacket->SetElementValue(AccNode, strParental);

        /* 父设备/区域/系统ID, 和其他平台对接的时候，统一使用本级CMS ID */
        AccNode = pOutPacket->CreateElement((char*)"ParentID");


        if (NULL != pGBLogicDeviceInfo->parentID)
        {
            pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->parentID);
        }
        else
        {
            pOutPacket->SetElementValue(AccNode, (char*)"");
        }

        /* 信令安全模式*/
        AccNode = pOutPacket->CreateElement((char*)"SafetyWay");
        snprintf(strSafetyWay, 16, "%d", pGBLogicDeviceInfo->safety_way);
        pOutPacket->SetElementValue(AccNode, strSafetyWay);

        /* 注册方式 */
        AccNode = pOutPacket->CreateElement((char*)"RegisterWay");
        snprintf(strRegisterWay, 16, "%d", pGBLogicDeviceInfo->register_way);
        pOutPacket->SetElementValue(AccNode, strRegisterWay);

        /* 证书序列号*/
        AccNode = pOutPacket->CreateElement((char*)"CertNum");

        if (NULL != pGBLogicDeviceInfo->cert_num)
        {
            pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->cert_num);
        }
        else
        {
            pOutPacket->SetElementValue(AccNode, (char*)"");
        }

        /* 证书有效标识 */
        AccNode = pOutPacket->CreateElement((char*)"Certifiable");
        snprintf(strCertifiable, 16, "%d", pGBLogicDeviceInfo->certifiable);
        pOutPacket->SetElementValue(AccNode, strCertifiable);

        /* 无效原因码 */
        AccNode = pOutPacket->CreateElement((char*)"ErrCode");
        snprintf(strErrCode, 16, "%d", pGBLogicDeviceInfo->error_code);
        pOutPacket->SetElementValue(AccNode, strErrCode);

        /* 证书终止有效期*/
        AccNode = pOutPacket->CreateElement((char*)"EndTime");

        if (NULL != pGBLogicDeviceInfo->end_time)
        {
            pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->end_time);
        }
        else
        {
            pOutPacket->SetElementValue(AccNode, (char*)"");
        }

        /* 保密属性 */
        AccNode = pOutPacket->CreateElement((char*)"Secrecy");
        snprintf(strSecrecy, 16, "%d", pGBLogicDeviceInfo->secrecy);
        pOutPacket->SetElementValue(AccNode, strSecrecy);

        /* IP地址*/
        AccNode = pOutPacket->CreateElement((char*)"IPAddress");

        if (NULL != pGBLogicDeviceInfo->ip_address)
        {
            pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->ip_address);
        }
        else
        {
            pOutPacket->SetElementValue(AccNode, (char*)"");
        }

        /* 端口号 */
        AccNode = pOutPacket->CreateElement((char*)"Port");
        snprintf(strPort, 16, "%d", pGBLogicDeviceInfo->port);
        pOutPacket->SetElementValue(AccNode, strPort);

        /* 密码*/
        AccNode = pOutPacket->CreateElement((char*)"Password");

        if (NULL != pGBLogicDeviceInfo->password)
        {
            pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->password);
        }
        else
        {
            pOutPacket->SetElementValue(AccNode, (char*)"");
        }

        /* 点位状态 */
        AccNode = pOutPacket->CreateElement((char*)"Status");


        if (1 == pGBLogicDeviceInfo->status)
        {
            if (INTELLIGENT_STATUS_ON == pGBLogicDeviceInfo->intelligent_status)
            {
                pOutPacket->SetElementValue(AccNode, (char*)"INTELLIGENT");
            }
            else if (ALARM_STATUS_CLOSE == pGBLogicDeviceInfo->alarm_status)
            {
                pOutPacket->SetElementValue(AccNode, (char*)"CLOSE");
            }
            else if (ALARM_STATUS_APART == pGBLogicDeviceInfo->alarm_status)
            {
                pOutPacket->SetElementValue(AccNode, (char*)"APART");
            }
            else
            {
                pOutPacket->SetElementValue(AccNode, (char*)"ON");
            }
        }
        else if (2 == pGBLogicDeviceInfo->status)
        {
            pOutPacket->SetElementValue(AccNode, (char*)"NOVIDEO");
        }
        else
        {
            pOutPacket->SetElementValue(AccNode, (char*)"OFF");
        }

        /* 经度 */
        AccNode = pOutPacket->CreateElement((char*)"Longitude");
        snprintf(strLongitude, 64, "%.16lf", pGBLogicDeviceInfo->longitude);
        pOutPacket->SetElementValue(AccNode, strLongitude);

        /* 纬度 */
        AccNode = pOutPacket->CreateElement((char*)"Latitude");
        snprintf(strLatitude, 64, "%.16lf", pGBLogicDeviceInfo->latitude);
        pOutPacket->SetElementValue(AccNode, strLatitude);


        /* 所属图层 */
        AccNode = pOutPacket->CreateElement((char*)"MapLayer");

        if (NULL != pGBLogicDeviceInfo->map_layer)
        {
            pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->map_layer);
        }
        else
        {
            pOutPacket->SetElementValue(AccNode, (char*)"");
        }

        /* 报警设备子类型 */
        AccNode = pOutPacket->CreateElement((char*)"ChlType");
        snprintf(strAlarmDeviceSubType, 64, "%u", pGBLogicDeviceInfo->alarm_device_sub_type);
        pOutPacket->SetElementValue(AccNode, strAlarmDeviceSubType);

        /* 所属的CMS ID */
        AccNode = pOutPacket->CreateElement((char*)"CMSID");
        pOutPacket->SetElementValue(AccNode, local_cms_id_get());
#endif
    }
    else
    {
        iRet = load_db_data_to_LogicDevice_info_list_by_device_id(pRoute_Srv_dboper, device_id);

        if (iRet == 0)
        {
            pGBLogicDeviceInfo = GBLogicDevice_info_find(device_id);

            if (NULL != pGBLogicDeviceInfo)
            {
#if 0
                /* 设备索引 */
                AccNode = pOutPacket->CreateElement((char*)"ID");
                snprintf(strID, 64, "%u", pGBLogicDeviceInfo->id);
                pOutPacket->SetElementValue(AccNode, strID);
#endif

                /* 设备统一编号 */
                AccNode = pOutPacket->CreateElement((char*)"DeviceID");
                pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->device_id);

                /* 点位名称 */
                AccNode = pOutPacket->CreateElement((char*)"Name");
                pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->device_name);

#if 0
                /* 是否启用*/
                AccNode = pOutPacket->CreateElement((char*)"Enable");

                if (0 == pGBLogicDeviceInfo->enable)
                {
                    pOutPacket->SetElementValue(AccNode, (char*)"0");
                }
                else
                {
                    pOutPacket->SetElementValue(AccNode, (char*)"1");
                }

                /* 是否可控 */
                AccNode = pOutPacket->CreateElement((char*)"CtrlEnable");

                if (0 == pGBLogicDeviceInfo->ctrl_enable)
                {
                    pOutPacket->SetElementValue(AccNode, (char*)"Disable");
                }
                else
                {
                    pOutPacket->SetElementValue(AccNode, (char*)"Enable");
                }

                /* 是否支持对讲 */
                AccNode = pOutPacket->CreateElement((char*)"MicEnable");

                if (0 == pGBLogicDeviceInfo->mic_enable)
                {
                    pOutPacket->SetElementValue(AccNode, (char*)"Disable");
                }
                else
                {
                    pOutPacket->SetElementValue(AccNode, (char*)"Enable");
                }

                /* 帧率 */
                AccNode = pOutPacket->CreateElement((char*)"FrameCount");
                snprintf(strFrameCount, 16, "%d", pGBLogicDeviceInfo->frame_count);
                pOutPacket->SetElementValue(AccNode, strFrameCount);

                /* 是否支持多码流 */
                AccNode = pOutPacket->CreateElement((char*)"StreamCount");
                snprintf(strStreamCount, 16, "%d", pGBLogicDeviceInfo->stream_count);
                pOutPacket->SetElementValue(AccNode, strStreamCount);

                /* 告警时长 */
                AccNode = pOutPacket->CreateElement((char*)"AlarmLengthOfTime");
                snprintf(strAlarmLengthOfTime, 16, "%d", pGBLogicDeviceInfo->alarm_duration);
                pOutPacket->SetElementValue(AccNode, strAlarmLengthOfTime);

                /* 设备生产商 */
                AccNode = pOutPacket->CreateElement((char*)"Manufacturer");

                if (NULL != pGBLogicDeviceInfo->manufacturer)
                {
                    pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->manufacturer);
                }
                else
                {
                    pOutPacket->SetElementValue(AccNode, (char*)"");
                }

                /* 设备型号 */
                AccNode = pOutPacket->CreateElement((char*)"Model");

                if (NULL != pGBLogicDeviceInfo->model)
                {
                    pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->model);
                }
                else
                {
                    pOutPacket->SetElementValue(AccNode, (char*)"");
                }

                /* 设备归属 */
                AccNode = pOutPacket->CreateElement((char*)"Owner");

                if (NULL != pGBLogicDeviceInfo->owner)
                {
                    pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->owner);
                }
                else
                {
                    pOutPacket->SetElementValue(AccNode, (char*)"");
                }

                /* 行政区域 */
                AccNode = pOutPacket->CreateElement((char*)"CivilCode");

                if (NULL != pGBLogicDeviceInfo->virtualParentID)
                {
                    pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->virtualParentID);
                }
                else
                {
                    pOutPacket->SetElementValue(AccNode, local_civil_code_get());
                }

                /* 警区 */
                AccNode = pOutPacket->CreateElement((char*)"Block");

                if (NULL != pGBLogicDeviceInfo->block)
                {
                    pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->block);
                }
                else
                {
                    pOutPacket->SetElementValue(AccNode, (char*)"");
                }

                /* 安装地址 */
                AccNode = pOutPacket->CreateElement((char*)"Address");

                if (NULL != pGBLogicDeviceInfo->address)
                {
                    pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->address);
                }
                else
                {
                    pOutPacket->SetElementValue(AccNode, (char*)"");
                }

                /* 是否有子设备 */
                AccNode = pOutPacket->CreateElement((char*)"Parental");
                snprintf(strParental, 16, "%d", pGBLogicDeviceInfo->parental);
                pOutPacket->SetElementValue(AccNode, strParental);

                /* 父设备/区域/系统ID */
                AccNode = pOutPacket->CreateElement((char*)"ParentID");

                if (NULL != pGBLogicDeviceInfo->parentID)
                {
                    pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->parentID);
                }
                else
                {
                    pOutPacket->SetElementValue(AccNode, (char*)"");
                }

                /* 信令安全模式*/
                AccNode = pOutPacket->CreateElement((char*)"SafetyWay");
                snprintf(strSafetyWay, 16, "%d", pGBLogicDeviceInfo->safety_way);
                pOutPacket->SetElementValue(AccNode, strSafetyWay);

                /* 注册方式 */
                AccNode = pOutPacket->CreateElement((char*)"RegisterWay");
                snprintf(strRegisterWay, 16, "%d", pGBLogicDeviceInfo->register_way);
                pOutPacket->SetElementValue(AccNode, strRegisterWay);

                /* 证书序列号*/
                AccNode = pOutPacket->CreateElement((char*)"CertNum");

                if (NULL != pGBLogicDeviceInfo->cert_num)
                {
                    pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->cert_num);
                }
                else
                {
                    pOutPacket->SetElementValue(AccNode, (char*)"");
                }

                /* 证书有效标识 */
                AccNode = pOutPacket->CreateElement((char*)"Certifiable");
                snprintf(strCertifiable, 16, "%d", pGBLogicDeviceInfo->certifiable);
                pOutPacket->SetElementValue(AccNode, strCertifiable);

                /* 无效原因码 */
                AccNode = pOutPacket->CreateElement((char*)"ErrCode");
                snprintf(strErrCode, 16, "%d", pGBLogicDeviceInfo->error_code);
                pOutPacket->SetElementValue(AccNode, strErrCode);

                /* 证书终止有效期*/
                AccNode = pOutPacket->CreateElement((char*)"EndTime");

                if (NULL != pGBLogicDeviceInfo->end_time)
                {
                    pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->end_time);
                }
                else
                {
                    pOutPacket->SetElementValue(AccNode, (char*)"");
                }

                /* 保密属性 */
                AccNode = pOutPacket->CreateElement((char*)"Secrecy");
                snprintf(strSecrecy, 16, "%d", pGBLogicDeviceInfo->secrecy);
                pOutPacket->SetElementValue(AccNode, strSecrecy);

                /* IP地址*/
                AccNode = pOutPacket->CreateElement((char*)"IPAddress");

                if (NULL != pGBLogicDeviceInfo->ip_address)
                {
                    pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->ip_address);
                }
                else
                {
                    pOutPacket->SetElementValue(AccNode, (char*)"");
                }

                /* 端口号 */
                AccNode = pOutPacket->CreateElement((char*)"Port");
                snprintf(strPort, 16, "%d", pGBLogicDeviceInfo->port);
                pOutPacket->SetElementValue(AccNode, strPort);

                /* 密码*/
                AccNode = pOutPacket->CreateElement((char*)"Password");

                if (NULL != pGBLogicDeviceInfo->password)
                {
                    pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->password);
                }
                else
                {
                    pOutPacket->SetElementValue(AccNode, (char*)"");
                }

                /* 点位状态 */
                AccNode = pOutPacket->CreateElement((char*)"Status");

                if (1 == pGBLogicDeviceInfo->status)
                {
                    if (INTELLIGENT_STATUS_ON == pGBLogicDeviceInfo->intelligent_status)
                    {
                        pOutPacket->SetElementValue(AccNode, (char*)"INTELLIGENT");
                    }
                    else if (ALARM_STATUS_CLOSE == pGBLogicDeviceInfo->alarm_status)
                    {
                        pOutPacket->SetElementValue(AccNode, (char*)"CLOSE");
                    }
                    else if (ALARM_STATUS_APART == pGBLogicDeviceInfo->alarm_status)
                    {
                        pOutPacket->SetElementValue(AccNode, (char*)"APART");
                    }
                    else
                    {
                        pOutPacket->SetElementValue(AccNode, (char*)"ON");
                    }
                }
                else if (2 == pGBLogicDeviceInfo->status)
                {
                    pOutPacket->SetElementValue(AccNode, (char*)"NOVIDEO");
                }
                else
                {
                    pOutPacket->SetElementValue(AccNode, (char*)"OFF");
                }

                /* 经度 */
                AccNode = pOutPacket->CreateElement((char*)"Longitude");
                snprintf(strLongitude, 64, "%.16lf", pGBLogicDeviceInfo->longitude);
                pOutPacket->SetElementValue(AccNode, strLongitude);

                /* 纬度 */
                AccNode = pOutPacket->CreateElement((char*)"Latitude");
                snprintf(strLatitude, 64, "%.16lf", pGBLogicDeviceInfo->latitude);
                pOutPacket->SetElementValue(AccNode, strLatitude);

                /* 所属图层 */
                AccNode = pOutPacket->CreateElement((char*)"MapLayer");

                if (NULL != pGBLogicDeviceInfo->map_layer)
                {
                    pOutPacket->SetElementValue(AccNode, pGBLogicDeviceInfo->map_layer);
                }
                else
                {
                    pOutPacket->SetElementValue(AccNode, (char*)"");
                }

                /* 报警设备子类型 */
                AccNode = pOutPacket->CreateElement((char*)"ChlType");
                snprintf(strAlarmDeviceSubType, 64, "%u", pGBLogicDeviceInfo->alarm_device_sub_type);
                pOutPacket->SetElementValue(AccNode, strAlarmDeviceSubType);

                /* 所属的CMS ID */
                AccNode = pOutPacket->CreateElement((char*)"CMSID");
                pOutPacket->SetElementValue(AccNode, local_cms_id_get());
#endif
            }
            else
            {
#if 0
                /* 设备索引 */
                AccNode = pOutPacket->CreateElement((char*)"ID");
                pOutPacket->SetElementValue(AccNode, (char*)"");
#endif

                /* 设备统一编号 */
                AccNode = pOutPacket->CreateElement((char*)"DeviceID");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 点位名称 */
                AccNode = pOutPacket->CreateElement((char*)"Name");
                pOutPacket->SetElementValue(AccNode, (char*)"");

#if 0
                /* 设备生产商 */
                AccNode = pOutPacket->CreateElement((char*)"Manufacturer");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 设备型号 */
                AccNode = pOutPacket->CreateElement((char*)"Model");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 设备归属 */
                AccNode = pOutPacket->CreateElement((char*)"Owner");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 行政区域 */
                AccNode = pOutPacket->CreateElement((char*)"CivilCode");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 警区 */
                AccNode = pOutPacket->CreateElement((char*)"Block");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 安装地址 */
                AccNode = pOutPacket->CreateElement((char*)"Address");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 是否有子设备 */
                AccNode = pOutPacket->CreateElement((char*)"Parental");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 父设备/区域/系统ID */
                AccNode = pOutPacket->CreateElement((char*)"ParentID");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 信令安全模式*/
                AccNode = pOutPacket->CreateElement((char*)"SafetyWay");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 注册方式 */
                AccNode = pOutPacket->CreateElement((char*)"RegisterWay");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 证书序列号*/
                AccNode = pOutPacket->CreateElement((char*)"CertNum");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 证书有效标识 */
                AccNode = pOutPacket->CreateElement((char*)"Certifiable");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 无效原因码 */
                AccNode = pOutPacket->CreateElement((char*)"ErrCode");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 证书终止有效期*/
                AccNode = pOutPacket->CreateElement((char*)"EndTime");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 保密属性 */
                AccNode = pOutPacket->CreateElement((char*)"Secrecy");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* IP地址*/
                AccNode = pOutPacket->CreateElement((char*)"IPAddress");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 端口号 */
                AccNode = pOutPacket->CreateElement((char*)"Port");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 密码*/
                AccNode = pOutPacket->CreateElement((char*)"Password");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 点位状态 */
                AccNode = pOutPacket->CreateElement((char*)"Status");
                pOutPacket->SetElementValue(AccNode, (char*)"OFF");

                /* 经度 */
                AccNode = pOutPacket->CreateElement((char*)"Longitude");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 纬度 */
                AccNode = pOutPacket->CreateElement((char*)"Latitude");
                pOutPacket->SetElementValue(AccNode, (char*)"");

                /* 所属的CMS ID */
                AccNode = pOutPacket->CreateElement((char*)"CMSID");
                pOutPacket->SetElementValue(AccNode, (char*)"");
#endif
            }
        }
        else
        {
#if 0
            /* 设备索引 */
            AccNode = pOutPacket->CreateElement((char*)"ID");
            pOutPacket->SetElementValue(AccNode, (char*)"");
#endif

            /* 设备统一编号 */
            AccNode = pOutPacket->CreateElement((char*)"DeviceID");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 点位名称 */
            AccNode = pOutPacket->CreateElement((char*)"Name");
            pOutPacket->SetElementValue(AccNode, (char*)"");

#if 0
            /* 设备生产商 */
            AccNode = pOutPacket->CreateElement((char*)"Manufacturer");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 设备型号 */
            AccNode = pOutPacket->CreateElement((char*)"Model");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 设备归属 */
            AccNode = pOutPacket->CreateElement((char*)"Owner");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 行政区域 */
            AccNode = pOutPacket->CreateElement((char*)"CivilCode");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 警区 */
            AccNode = pOutPacket->CreateElement((char*)"Block");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 安装地址 */
            AccNode = pOutPacket->CreateElement((char*)"Address");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 是否有子设备 */
            AccNode = pOutPacket->CreateElement((char*)"Parental");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 父设备/区域/系统ID */
            AccNode = pOutPacket->CreateElement((char*)"ParentID");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 信令安全模式*/
            AccNode = pOutPacket->CreateElement((char*)"SafetyWay");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 注册方式 */
            AccNode = pOutPacket->CreateElement((char*)"RegisterWay");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 证书序列号*/
            AccNode = pOutPacket->CreateElement((char*)"CertNum");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 证书有效标识 */
            AccNode = pOutPacket->CreateElement((char*)"Certifiable");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 无效原因码 */
            AccNode = pOutPacket->CreateElement((char*)"ErrCode");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 证书终止有效期*/
            AccNode = pOutPacket->CreateElement((char*)"EndTime");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 保密属性 */
            AccNode = pOutPacket->CreateElement((char*)"Secrecy");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* IP地址*/
            AccNode = pOutPacket->CreateElement((char*)"IPAddress");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 端口号 */
            AccNode = pOutPacket->CreateElement((char*)"Port");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 密码*/
            AccNode = pOutPacket->CreateElement((char*)"Password");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 点位状态 */
            AccNode = pOutPacket->CreateElement((char*)"Status");
            pOutPacket->SetElementValue(AccNode, (char*)"OFF");

            /* 经度 */
            AccNode = pOutPacket->CreateElement((char*)"Longitude");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 纬度 */
            AccNode = pOutPacket->CreateElement((char*)"Latitude");
            pOutPacket->SetElementValue(AccNode, (char*)"");

            /* 所属的CMS ID */
            AccNode = pOutPacket->CreateElement((char*)"CMSID");
            pOutPacket->SetElementValue(AccNode, (char*)"");
#endif
        }
    }

    return 0;
}

#if DECS("ZRV设备TCP连接消息处理")
/*****************************************************************************
 函 数 名  : UserTCPLoginParseClientData
 功能描述  : 解析客户端命令
 输入参数  : char* user_ip
             int user_port
             int user_sock
             unsigned char* buf
             int len
             DBOper* pDbOper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2015年8月29日 星期六
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int ZRVDeviceParseTCPSocketDataProc(char* device_ip, int device_port, int device_sock, char* buf, int len, DBOper* pDbOper, int* run_thread_time)
{
    int i = 0;
    xml_type_t2 xml_type2 = XML_TYPE2_NULL;
    CPacket inPacket;
    vector<string> NodeName_Vector;

    if (NULL == device_ip || device_sock <= 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG,  "ZRVDeviceParseTCPSocketDataProc() exit---: Param Error \r\n");
        return -1;
    }

    if (buf == NULL || len <= 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG,  "ZRVDeviceParseTCPSocketDataProc() exit---: Buffer Error \r\n");
        return -1;
    }

    if (NULL == pDbOper)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG,  "ZRVDeviceParseTCPSocketDataProc() exit---: DB Oper Error \r\n");
        return -1;
    }


    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "ZRVDeviceParseTCPSocketDataProc() ZRV Device: IP=%s, Port=%d, Socket=%d, BodyLen=%d, buf=%s \r\n", device_ip, device_port, device_sock, len, buf);

    //解析XML
    i = inPacket.BuiltTree(buf, len);//生成DOM树结构.

    if (i < 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "ZRVDeviceParseTCPSocketDataProc() exit---: XML Build Tree Error \r\nmsg=%s \r\n", buf);
        return -99;
    }

    NodeName_Vector.clear();
    DOMDocument* pDOMDocument = inPacket.GetDOMDocument();
    DOMElement* pDOMElement = pDOMDocument->get_root();
    pDOMElement->ClearNodeNumber();

    if (pDOMElement->GetNodeName(NodeName_Vector) <= 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "ZRVDeviceParseTCPSocketDataProc() exit---: Get Node Name Error \r\n");
        return -1;
    }

    /* 解析出xml的消息类型 */
    xml_type2 = get_xml_type_from_xml_body2(NodeName_Vector, inPacket);
    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "ZRVDeviceParseTCPSocketDataProc() get_xml_type_from_xml_body:xml_type=%d \r\n", xml_type2);

    switch (xml_type2)
    {
        case XML_REQUEST_REGISTER:
            i = device_register_request_proc(device_ip, device_port, device_sock, inPacket, pDbOper, run_thread_time);
            break;

        case XML_RESPONSE_REGISTER:
            i = device_register_response_proc(device_ip, device_port, device_sock, inPacket, pDbOper);
            break;

        case XML_REQUEST_NOTIFY:
            i = device_notify_request_proc(device_ip, device_port, device_sock, inPacket, pDbOper);
            break;

        case XML_RESPONSE_NOTIFY:
            i = device_notify_response_proc(device_ip, device_port, device_sock, inPacket, pDbOper);
            break;

        case XML_REQUEST_MESSAGE:
            i = device_message_request_proc(device_ip, device_port, device_sock, inPacket, pDbOper);
            break;

        case XML_RESPONSE_MESSAGE:
            i = device_message_response_proc(device_ip, device_port, device_sock, inPacket, pDbOper);
            break;

        default:
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "ZRVDeviceParseTCPSocketDataProc() exit---: Not Support Message Type:%d \r\n", xml_type2);
            return -2;
    }

    return i;
}

/*****************************************************************************
 函 数 名  : device_register_request_proc
 功能描述  : 设备注册请求处理
 输入参数  : char* device_ip
             int device_port
             int device_sock
             CPacket& inPacket
             DBOper* pDbOper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2017年4月26日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_register_request_proc(char* device_ip, int device_port, int device_sock, CPacket& inPacket, DBOper* pDbOper, int* run_thread_time)
{
    int i = 0;
    xml_sub_type_t xml_sub_type = XML_SUB_TYPE_NULL;
    vector<string> NodeName_Vector;

    NodeName_Vector.clear();
    DOMDocument* pDOMDocument = inPacket.GetDOMDocument();
    DOMElement* pDOMElement = pDOMDocument->get_root();
    pDOMElement->ClearNodeNumber();

    if (pDOMElement->GetNodeName(NodeName_Vector) <= 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "ZRVDeviceParseTCPSocketDataProc() exit---: Get Node Name Error \r\n");
        return -1;
    }

    /* 解析出xml的消息子类型 */
    xml_sub_type = get_xml_sub_type_from_xml_body(NodeName_Vector, inPacket);
    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_register_request_proc() get_xml_sub_type_from_xml_body:xml_sub_type=%d \r\n", xml_sub_type);

    switch (xml_sub_type)
    {
        case XML_SUB_ZRV_REGISTER:
            i = zrv_device_register_request_proc(device_ip, device_port, device_sock, inPacket, pDbOper, run_thread_time);
            break;

        default:
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_register_request_proc() exit---: Not Support Message Type:%d \r\n", xml_sub_type);
            return -1;
    }

    return i;
}

/*****************************************************************************
 函 数 名  : zrv_device_register_request_proc
 功能描述  : ZRV设备注册请求处理
 输入参数  : char* device_ip
             int device_port
             int device_sock
             CPacket& inPacket
             DBOper* pDbOper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2017年4月26日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int zrv_device_register_request_proc(char* device_ip, int device_port, int device_sock, CPacket& inPacket, DBOper* pDbOper, int* run_thread_time)
{
    int iRet = 0;
    unsigned int iDeviceIndex = 0;
    ZRVDevice_info_t* pZRVDeviceInfo = NULL;

    char strGUID[64] = {0};
    char strRefreshFlag[32] = {0};
    char strExpires[32] = {0};
    int iExpires = 0;

    time_t now = time(NULL);

    /* 解析XML */
    inPacket.GetElementValue((char*)"GUID", strGUID);
    inPacket.GetElementValue((char*)"IsRefresh", strRefreshFlag);
    inPacket.GetElementValue((char*)"Expires", strExpires);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "zrv_device_register_request_proc() \
        \r\n XML Para: \
        \r\n GUID=%s, IsRefresh=%s,Expires=%s \r\n", strGUID, strRefreshFlag, strExpires);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "收到ZRV设备注册消息, ZRV设备IP=%s, device_port=%d, tcp_sock=%d, GUID=%s, IsRefresh=%s,Expires=%s", device_ip, device_port, device_sock, strGUID, strRefreshFlag, strExpires);

    iExpires = osip_atoi(strExpires);

    if (iExpires > 0) /* 正常注册 */
    {
        /* 查找内存中的TSU */
        pZRVDeviceInfo = ZRVDevice_info_find(device_ip);

        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "zrv_device_register_request_proc() ZRVDevice_info_find:device_ip=%s \r\n", device_ip);

        if (NULL != pZRVDeviceInfo) /* 已经存在 */
        {
            osip_strncpy(pZRVDeviceInfo->device_ip, device_ip, MAX_IP_LEN);
            pZRVDeviceInfo->reg_status = 1;
            pZRVDeviceInfo->tcp_sock = device_sock;
            pZRVDeviceInfo->last_register_time = now;
            pZRVDeviceInfo->register_expires = iExpires;
            pZRVDeviceInfo->register_expires_count = iExpires;
        }
        else
        {
            iRet = ZRVDevice_info_init(&pZRVDeviceInfo);

            if (iRet != 0)
            {
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "zrv_device_register_request_proc() ZRVDevice_info_init Error");
                return -1;
            }

            osip_strncpy(pZRVDeviceInfo->device_ip, device_ip, MAX_IP_LEN);
            pZRVDeviceInfo->reg_status = 1;
            pZRVDeviceInfo->tcp_sock = device_sock;
            pZRVDeviceInfo->last_register_time = now;
            pZRVDeviceInfo->register_expires = iExpires;
            pZRVDeviceInfo->register_expires_count = iExpires;

            if (ZRVDevice_info_add(pZRVDeviceInfo) < 0)
            {
                ZRVDevice_info_free(pZRVDeviceInfo);
                delete pZRVDeviceInfo;
                pZRVDeviceInfo = NULL;
                DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "zrv_device_register_request_proc() ZRVDevice_info_add Error");
                return -1;
            }
        }
    }
    else if (iExpires == 0) /* 注销 */
    {
        /* 查找内存中的TSU */
        pZRVDeviceInfo = ZRVDevice_info_find(device_ip);

        if (NULL != pZRVDeviceInfo) /* 已经存在 */
        {
            osip_strncpy(pZRVDeviceInfo->device_ip, device_ip, MAX_IP_LEN);
            pZRVDeviceInfo->reg_status = 0;
            pZRVDeviceInfo->tcp_sock = -1;
            pZRVDeviceInfo->last_register_time = now;
            pZRVDeviceInfo->register_expires = 0;
            pZRVDeviceInfo->register_expires_count = 0;
        }
    }
    else
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "zrv_device_register_request_proc() Expires Error:Expires=%d", iExpires);
        return -1;
    }

    /* 写入数据库 */
    iDeviceIndex = SetZRVDeviceToConfigTable(pZRVDeviceInfo, pDbOper);

    if (iDeviceIndex <= 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "zrv_device_register_request_proc() DeviceIndex Error:DeviceIndex=%u", iDeviceIndex);
        return -1;
    }

    pZRVDeviceInfo->id = iDeviceIndex;

    iRet = SendResponseToZRVRegister(strGUID, 0, 0, device_sock);
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "zrv_device_register_request_proc() SendResponseToZRVRegister:device_ip=%s, device_sock=%d, iRet=%d \r\n", device_ip, device_sock, iRet);

    if (iRet == -2) //连接异常，需要关闭
    {
        free_zrv_device_tcp_connect_by_socket(device_sock);
        pZRVDeviceInfo->reg_status = 0;
        pZRVDeviceInfo->tcp_sock = -1;
        return -2;
    }

    /* 如果是第一次上线，把之前没有完成的任务，再发送一次给ZRV设备 */
    if (0 == sstrcmp(strRefreshFlag, "NO"))
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "收到ZRV设备注册消息, ZRV设备IP=%s, device_port=%d, tcp_sock=%d, GUID=%s, IsRefresh=%s,Expires=%s, 该设备第一次注册上线, 下发之前没有完成的任务", device_ip, device_port, device_sock, strGUID, strRefreshFlag, strExpires);

        iRet = SendNotCompleteTaskToZRVDeviceForFristRegister(device_ip, run_thread_time);
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "zrv_device_register_request_proc() SendNotCompleteTaskToZRVDeviceForFristRegister:device_ip=%s, device_sock=%d, iRet=%d \r\n", device_ip, device_sock, iRet);
    }

    return 0;
}

/*****************************************************************************
 函 数 名  : device_register_response_proc
 功能描述  : 设备注册响应处理
 输入参数  : char* device_ip
             int device_port
             int device_sock
             CPacket& inPacket
             DBOper* pDbOper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2017年4月26日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_register_response_proc(char* device_ip, int device_port, int device_sock, CPacket& inPacket, DBOper* pDbOper)
{
    int i = 0;

    return i;
}

/*****************************************************************************
 函 数 名  : device_notify_request_proc
 功能描述  : 设备通知请求处理
 输入参数  : char* device_ip
             int device_port
             int device_sock
             CPacket& inPacket
             DBOper* pDbOper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2017年4月26日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_request_proc(char* device_ip, int device_port, int device_sock, CPacket& inPacket, DBOper* pDbOper)
{
    int i = 0;
    xml_sub_type_t xml_sub_type = XML_SUB_TYPE_NULL;
    vector<string> NodeName_Vector;

    NodeName_Vector.clear();
    DOMDocument* pDOMDocument = inPacket.GetDOMDocument();
    DOMElement* pDOMElement = pDOMDocument->get_root();
    pDOMElement->ClearNodeNumber();

    if (pDOMElement->GetNodeName(NodeName_Vector) <= 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "ZRVDeviceParseTCPSocketDataProc() exit---: Get Node Name Error \r\n");
        return -1;
    }

    /* 解析出xml的消息子类型 */
    xml_sub_type = get_xml_sub_type_from_xml_body(NodeName_Vector, inPacket);
    DEBUG_TRACE(MODULE_DEVICE, LOG_TRACE, "device_notify_request_proc() get_xml_sub_type_from_xml_body:xml_sub_type=%d \r\n", xml_sub_type);

    switch (xml_sub_type)
    {
        case XML_SUB_ZRV_COMPRESS_TASK_RESULT:
            i = zrv_device_compress_task_result_request_proc(device_ip, device_port, device_sock, inPacket, pDbOper);
            break;

        default:
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "device_notify_request_proc() exit---: Not Support Message Type:%d \r\n", xml_sub_type);
            return -1;
    }

    return i;
}

/*****************************************************************************
 函 数 名  : zrv_device_compress_task_result_request_proc
 功能描述  : ZRV设备通知压缩结果请求处理
 输入参数  : char* device_ip
             int device_port
             int device_sock
             CPacket& inPacket
             DBOper* pDbOper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2017年4月26日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int zrv_device_compress_task_result_request_proc(char* device_ip, int device_port, int device_sock, CPacket& inPacket, DBOper* pDbOper)
{
    int iRet = 0;
    char strGUID[64] = {0};
    string strTaskListNum = "";
    int iTaskListNum = 0;

    ZRVDevice_info_t* pZRVDeviceInfo = NULL;

    DOMElement* ItemAccNode = NULL;
    int iItemNumCount = 0;

    char strRecordNum[64] = {0};
    char strResult[32] = {0};
    char strCompressBeginTime[32] = {0};
    char strCompressEndTime[32] = {0};
    char strYSHFileSize[32] = {0};
    char strErrorCode[32] = {0};
    char strDestUrl[128 + 4] = {0};

    int iResult = 0;

    /* 查找内存中的TSU */
    pZRVDeviceInfo = ZRVDevice_info_find(device_ip);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "zrv_device_compress_task_result_request_proc() ZRVDevice_info_find:device_ip=%s \r\n", device_ip);

    if (NULL == pZRVDeviceInfo) /* 已经存在 */
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "zrv_device_compress_task_result_request_proc() ZRVDevice_info_find Error \r\n");
        return -1;
    }

    /* 取得数据*/
    inPacket.GetElementValue((char*)"GUID", strGUID);
    inPacket.GetElementAttr((char*)"TaskList", (char*)"Num", strTaskListNum);

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "zrv_device_compress_task_result_request_proc() \
    \r\n XML Para: \
    \r\n GUID=%s \
    \r\n TaskList Num=%s \r\n ", strGUID, (char*)strTaskListNum.c_str());

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_IMPORTANT, "收到ZRV设备通知压缩任务结果消息:ZRV设备IP=%s, device_port=%d, tcp_sock=%d, GUID=%s, 上报的任务总数=%s", device_ip, device_port, device_sock, strGUID, (char*)strTaskListNum.c_str());

    iTaskListNum = osip_atoi((char*)strTaskListNum.c_str());

    if (iTaskListNum <= 0)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "zrv_device_compress_task_result_request_proc() exit---: TaskList Error \r\n");
        return -1;
    }

    /* 获取所有的Item 数据 */
    ItemAccNode = inPacket.SearchElement((char*)"Item");

    if (!ItemAccNode)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "zrv_device_compress_task_result_request_proc() exit---: Get Item Node Error \r\n");
        return -1;
    }

    inPacket.SetCurrentElement(ItemAccNode);

    while (ItemAccNode)
    {
        iItemNumCount++;

        if (iItemNumCount > iTaskListNum)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR,  "zrv_device_compress_task_result_request_proc() exit---: ItemNumCount=%d > TaskListNum=%d Break \r\n", iItemNumCount, iTaskListNum);
            break;
        }

        /* 任务ID */
        memset(strRecordNum, 0, 64);
        inPacket.GetElementValue((char*)"RecordNum", strRecordNum);

        /* 结果 */
        memset(strResult, 0, 32);
        inPacket.GetElementValue((char*)"Result", strResult);

        /* 压缩开始时间 */
        memset(strCompressBeginTime, 0, 32);
        inPacket.GetElementValue((char*)"CompressBeginTime", strCompressBeginTime);

        /* 压缩结束时间 */
        memset(strCompressEndTime, 0, 32);
        inPacket.GetElementValue((char*)"CompressEndTime", strCompressEndTime);

        /* 压缩后的文件大小 */
        memset(strYSHFileSize, 0, 32);
        inPacket.GetElementValue((char*)"YSHFileSize", strYSHFileSize);

        /* 错误码 */
        memset(strErrorCode, 0, 32);
        inPacket.GetElementValue((char*)"ErrorCode", strErrorCode);

        /* 压缩后的文件路径 */
        memset(strDestUrl, 0, 128 + 4);
        inPacket.GetElementValue((char*)"DestUrl", strDestUrl);

        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_IMPORTANT, "ZRV设备通知压缩任务结果消息:ZRV设备IP=%s, device_port=%d, tcp_sock=%d, RecordNum=%s, Result=%s, CompressBeginTime=%s, CompressEndTime=%s, YSHFileSize=%s, ErrorCode=%s, DestUrl=%s", device_ip, device_port, device_sock, strRecordNum, strResult, strCompressBeginTime, strCompressEndTime, strYSHFileSize, strErrorCode, strDestUrl);

        if (0 == strncmp(strResult, (char*)"OK", 2))
        {
            iResult = 1;
        }
        else
        {
            iResult = 2;
        }

        /* 写入或者更新数据库 */
        iRet |= tsu_creat_task_result_msg_add(device_ip, strRecordNum, iResult, osip_atoi(strErrorCode), osip_atoi(strCompressBeginTime), osip_atoi(strCompressEndTime), osip_atoi(strYSHFileSize), strDestUrl);

        if (iRet != 0)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "zrv_device_compress_task_result_request_proc() tsu_creat_task_result_msg_add ERROR:device_ip=%s, iRet=%d \r\n", device_ip, iRet);
        }
        else
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "zrv_device_compress_task_result_request_proc() tsu_creat_task_result_msg_add OK:device_ip=%s, iRet=%d \r\n", device_ip, iRet);
        }

        ItemAccNode = inPacket.SearchNextElement(true);
    }

#if 0
    iRet = SendResponseToZRVTaskResult(strGUID, 0, 0, device_sock);
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "zrv_device_register_request_proc() SendResponseToZRVTaskResult:device_ip=%s, device_sock=%d, iRet=%d \r\n", device_ip, device_sock, iRet);

    if (iRet == -2) //连接异常，需要关闭
    {
        free_zrv_device_tcp_connect_by_socket(device_sock);
        pZRVDeviceInfo->reg_status = 0;
        pZRVDeviceInfo->tcp_sock = -1;
        return -2;
    }

#endif

    return iRet;
}

/*****************************************************************************
 函 数 名  : device_notify_response_proc
 功能描述  : 设备通知响应处理
 输入参数  : char* device_ip
             int device_port
             int device_sock
             CPacket& inPacket
             DBOper* pDbOper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2017年4月26日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_notify_response_proc(char* device_ip, int device_port, int device_sock, CPacket& inPacket, DBOper* pDbOper)
{
    int i = 0;

    return i;
}

/*****************************************************************************
 函 数 名  : device_message_request_proc
 功能描述  : 设备消息请求处理
 输入参数  : char* device_ip
             int device_port
             int device_sock
             CPacket& inPacket
             DBOper* pDbOper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2017年4月26日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_message_request_proc(char* device_ip, int device_port, int device_sock, CPacket& inPacket, DBOper* pDbOper)
{
    int i = 0;

    return i;
}

/*****************************************************************************
 函 数 名  : device_message_response_proc
 功能描述  : 设备消息响应处理
 输入参数  : char* device_ip
             int device_port
             int device_sock
             CPacket& inPacket
             DBOper* pDbOper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2017年4月26日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int device_message_response_proc(char* device_ip, int device_port, int device_sock, CPacket& inPacket, DBOper* pDbOper)
{
    int i = 0;

    return i;
}
#endif

int StringVectorClone(vector<string>& SourceVectorString, vector<string>& DestVectorString)
{
    int index = 0;

    DestVectorString.clear();

    for (index = 0; index < (int)SourceVectorString.size(); index++) /* 循环查找排序的所有index容器 */
    {
        DestVectorString.push_back((char*)SourceVectorString[index].c_str());
    }

    return 0;
}

/*****************************************************************************
 函 数 名  : check_need_to_re_assign
 功能描述  : 检测是否需要重新分配
 输入参数  : char* platform_ip
             int per_task_count_zrvdevice
             vector<string>& ZRVDeviceIP
             vector<string>& DestZRVDeviceIP
             vector<int>& DestZRVDeviceTaskCount
             int* remove_task_count
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2017年9月11日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int check_need_to_re_assign(char* platform_ip, int per_task_count_zrvdevice, vector<string>& ZRVDeviceIP, vector<string>& DestZRVDeviceIP, vector<int>& DestZRVDeviceTaskCount, int* remove_task_count)
{
    int device_index = 0;
    int re_assign_flag = 0;
    int task_count = 0;
    int tmp_remove_task_count = 0;

    /* 获取一下当前各个ZRV设备存在的任务 */
    DestZRVDeviceIP.clear();
    DestZRVDeviceTaskCount.clear();

    for (device_index = 0; device_index < (int)ZRVDeviceIP.size(); device_index++)
    {
        task_count = 0;
        task_count = GetCurrentCompressTaskCountByZRVDeviceIP(platform_ip, (char*)ZRVDeviceIP[device_index].c_str());
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_IMPORTANT, "获取ZRV设备当前处理的任务数:平台IP=%s, ZRV设备IP地址=%s, 需要分配的任务数=%d, 当前处理的任务数=%d", platform_ip, (char*)ZRVDeviceIP[device_index].c_str(), per_task_count_zrvdevice, task_count);

        if (task_count < per_task_count_zrvdevice) /* 如果当前处理的任务数大于需要分配的任务数，需要过滤掉 */
        {
            DestZRVDeviceIP.push_back((char*)ZRVDeviceIP[device_index].c_str());
            DestZRVDeviceTaskCount.push_back(task_count);
        }
        else
        {
            tmp_remove_task_count += task_count;
            SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "获取ZRV设备当前处理的任务数:平台IP=%s, ZRV设备IP地址=%s, 当前处理的任务数=%d大于或着等于需要分配的任务数,去除掉该ZRV设备,并去掉该设备中的任务", platform_ip, (char*)ZRVDeviceIP[device_index].c_str(), task_count);
            re_assign_flag = 1;
        }
    }

    *remove_task_count = tmp_remove_task_count;
    return re_assign_flag;/* 是否需要重新分配 */
}

/*****************************************************************************
 函 数 名  : assign_compress_task_to_zrv_device_proc
 功能描述  : 分配压缩任务到ZRV设备
 输入参数  : char* platform_ip
             DBOper* ptDBoper
             int* run_thread_time
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2017年9月11日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int assign_compress_task_to_zrv_device_proc(char* platform_ip, DBOper* ptDBoper, int* run_thread_time)
{
    int iRet = 0;
    int device_index = 0;
    vector<string> AllProcCompressTaskID;    /* 当前处理的任务总数 */
    vector<string> NeedAssignCompressTaskID; /* 待分配的任务总数 */
    vector<string> AllZRVDeviceIP;           /* ZRVIP地址 */
    vector<string> AssignZRVDeviceIP;        /* 需要下发任务的ZRVIP地址 */
    vector<int> AssignZRVDeviceTaskCount;    /* 需要下发任务的ZRV 当前任务数 */

    int all_proc_task_count = 0;             /* 正在处理的任务总数 */
    int need_assign_task_count = 0;          /* 等待分配的任务总数 */
    int remove_task_count = 0;               /* 需要删掉的任务总数 */

    int zrv_device_count = 0;                /* 总的ZRV个数 */

    int per_task_count_zrvdevice = 0;        /* 每个ZRV分配的任务数 */
    vector<string> PerCompressTaskID;        /* 每台ZRV设备分配的任务 */

    int re_assign_flag = 0;                  /* 是否需要重新分配 */

    int task_index_count = 0;
    int task_begin_index = 0;
    int task_end_index = 0;

    if (NULL == platform_ip || platform_ip[0] == '\0')
    {
        DEBUG_TRACE(MODULE_COMMON, LOG_ERROR, "assign_compress_task_to_zrv_device_proc() exit---: Param Error \r\n");
        return -1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "分配压缩任务信息到ZRV设备,平台IP=%s: 开始---", platform_ip);

    //获取任务总数
    AllProcCompressTaskID.clear();
    iRet = GetAllProcCompressTaskByPlatformIP(platform_ip, AllProcCompressTaskID);
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "assign_compress_task_to_zrv_device_proc() : GetAllProcCompressTaskByPlatformIP:platform_ip=%s, iRet=%d \r\n", platform_ip, iRet);

    all_proc_task_count = AllProcCompressTaskID.size();
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "assign_compress_task_to_zrv_device_proc() AllProcCompressTask count=%d \r\n", all_proc_task_count);

    /* 如果记录数为0 */
    if (all_proc_task_count == 0)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "分配压缩任务信息到ZRV设备失败,原因=%s", (char*)"获取的当前处理的任务数为0");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "assign_compress_task_to_zrv_device_proc() No CompressTask Need To Assign\r\n");
        return FILE_COMPRESS_COMPRESS_TASK_COUNT_ERROR;
    }

    //获取本次待分配的任务总数
    NeedAssignCompressTaskID.clear();
    iRet = GetNeedAssignCompressTaskByPlatformIP(platform_ip, NeedAssignCompressTaskID);
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "assign_compress_task_to_zrv_device_proc() : GetNeedAssignCompressTaskByPlatformIP:platform_ip=%s, iRet=%d \r\n", platform_ip, iRet);

    need_assign_task_count = NeedAssignCompressTaskID.size();
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "assign_compress_task_to_zrv_device_proc() NeedAssignCompressTask count=%d \r\n", need_assign_task_count);

    if (need_assign_task_count == 0)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "分配压缩任务信息到ZRV设备失败,原因=%s", (char*)"获取的本次需要分配的任务数为0");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "assign_compress_task_to_zrv_device_proc() No CompressTask Need To Assign\r\n");
        return FILE_COMPRESS_COMPRESS_TASK_COUNT_ERROR;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_IMPORTANT, "分配压缩任务信息到ZRV设备,平台IP=%s, 当前处理的任务总数=%d, 本次需要分配的任务总数=%d", platform_ip, all_proc_task_count, need_assign_task_count);

    //获取可用的ZRV设备总数,平均分配
    AllZRVDeviceIP.clear();
    iRet = GetZRVDeviceIPForAssginTask(AllZRVDeviceIP);
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "assign_compress_task_to_zrv_device_proc() : GetZRVDeviceIPForAssginTask:platform_ip=%s, iRet=%d \r\n", platform_ip, iRet);

    zrv_device_count = AllZRVDeviceIP.size();
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "assign_compress_task_to_zrv_device_proc() zrvdevice count=%d \r\n", zrv_device_count);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_IMPORTANT, "分配压缩任务信息到ZRV设备,平台IP=%s, 获取到在线的ZRV设备总数=%d", platform_ip, zrv_device_count);

    /* 如果记录数为0 */
    if (zrv_device_count == 0)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "分配压缩任务信息到ZRV设备失败,原因=%s", (char*)"获取到在线的ZRV设备数为0");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "assign_compress_task_to_zrv_device_proc() No zrvdevice can use\r\n");
        return FILE_COMPRESS_NO_ZRV_DEVICE;
    }

    /* 计算出各个ZRV需要分配的任务数 */
    if (all_proc_task_count % zrv_device_count == 0)
    {
        per_task_count_zrvdevice = all_proc_task_count / zrv_device_count;
    }
    else
    {
        per_task_count_zrvdevice = (all_proc_task_count / zrv_device_count) + 1;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_IMPORTANT, "分配压缩任务信息到ZRV设备,平台IP=%s, 按照在线ZRV计算, 当前处理的任务总数=%d, 本次需要分配的任务总数=%d, 每台ZRV设备需要分配的任务数=%d", platform_ip, all_proc_task_count, need_assign_task_count, per_task_count_zrvdevice);

    /* 可能当前ZRV设备上面有些的任务数大于这个分配的任务数，需要去掉这些ZRV设备，检查是否需要重新分配 */
    while (check_need_to_re_assign(platform_ip, per_task_count_zrvdevice, AllZRVDeviceIP, AssignZRVDeviceIP, AssignZRVDeviceTaskCount, &remove_task_count))
    {
        /* 重新计算任务数 */
        all_proc_task_count = all_proc_task_count - remove_task_count;
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "assign_compress_task_to_zrv_device_proc() AllProcCompressTask count=%d \r\n", all_proc_task_count);

        zrv_device_count = AssignZRVDeviceIP.size();
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "assign_compress_task_to_zrv_device_proc() zrvdevice count=%d \r\n", zrv_device_count);

        /* 计算出各个ZRV需要分配的任务数 */
        if (all_proc_task_count % zrv_device_count == 0)
        {
            per_task_count_zrvdevice = all_proc_task_count / zrv_device_count;
        }
        else
        {
            per_task_count_zrvdevice = (all_proc_task_count / zrv_device_count) + 1;
        }

        /* 重新拷贝到队列 */
        AllZRVDeviceIP.clear();
        StringVectorClone(AssignZRVDeviceIP, AllZRVDeviceIP);
    }

    /* 如果记录数为0 */
    if (zrv_device_count == 0)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "分配压缩任务信息到ZRV设备失败,原因=%s", (char*)"按照ZRV当前ZRV任务负载计算, 当前可分配的ZRV数量为0");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "assign_compress_task_to_zrv_device_proc() No zrvdevice can use\r\n");
        return FILE_COMPRESS_NO_ZRV_DEVICE;
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_IMPORTANT, "分配压缩任务信息到ZRV设备,平台IP=%s, 按照ZRV当前ZRV任务负载计算, 当前处理的任务总数=%d, 本次需要分配的任务总数=%d, 当前可分配的ZRV数量=%d, 每台ZRV设备需要分配的任务数=%d", platform_ip, all_proc_task_count, need_assign_task_count, zrv_device_count, per_task_count_zrvdevice);

    /* 循环ZRV，分配任务, 发送任务 */
    task_index_count = 0;

    for (device_index = 0; device_index < zrv_device_count; device_index++)
    {
        /* 添加要发的任务 */
        PerCompressTaskID.clear();

        task_begin_index += task_index_count;
        task_index_count = per_task_count_zrvdevice - AssignZRVDeviceTaskCount[device_index]; /* 任务数:需要分配的任务减去正在执行的 */
        task_end_index = task_begin_index + task_index_count;

        if (task_end_index > need_assign_task_count)
        {
            task_end_index = need_assign_task_count;
            task_index_count = task_end_index - task_begin_index;
        }

        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_IMPORTANT, "分配压缩任务信息到ZRV设备, 分配任务信息: ZRV设备IP地址=%s, 分配的任务开始索引=%d, 分配的任务结束索引=%d, 分配的任务数=%d", (char*)AssignZRVDeviceIP[device_index].c_str(), task_begin_index, task_end_index, task_index_count);

        AddAssignCompressTaskToPerZRVDevice(NeedAssignCompressTaskID, need_assign_task_count, task_begin_index, task_end_index, PerCompressTaskID);

        iRet |= SendAssignTaskToZRVDevice(PerCompressTaskID, (char*)AssignZRVDeviceIP[device_index].c_str(), ptDBoper, run_thread_time);
        DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "assign_compress_task_to_zrv_device_proc() SendAssignTaskToZRVDevice:ZRVDeviceIP=%s, iRet=%d \r\n", (char*)AssignZRVDeviceIP[device_index].c_str(), iRet);
        PerCompressTaskID.clear();
    }

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_NORMAL, "分配压缩任务信息到ZRV设备: 结束---");

    return iRet;
}

int add_compress_task_for_test(char* platform_ip, DBOper* ptDBoper)
{
    int i = 0;
    int iRet = 0;
    jly_yspb_t stYSPB;/* 对应的数据库结构字段 */

    if (NULL == platform_ip || platform_ip[0] == '\0' || NULL == ptDBoper)
    {
        DEBUG_TRACE(MODULE_COMMON, LOG_ERROR, "add_compress_task_for_test() exit---: Param Error \r\n");
        return -1;
    }

    /* 删除老的 */
    iRet = DeleteCompressTask(platform_ip, ptDBoper);
    DEBUG_TRACE(MODULE_COMMON, LOG_INFO,  "add_compress_task_for_test() : DeleteCompressTask:platform_ip=%s, iRet=%d \r\n", platform_ip, iRet);

    /* 增加新的 */
    for (i = 0; i < 100; i++)
    {
        memset(&stYSPB, 0, sizeof(jly_yspb_t));
        iRet = AddCompressTask(platform_ip, &stYSPB, ptDBoper);
        DEBUG_TRACE(MODULE_COMMON, LOG_INFO,  "add_compress_task_for_test() : AddCompressTask:platform_ip=%s, iRet=%d \r\n", platform_ip, iRet);
    }

    return iRet;
}

/*****************************************************************************
 函 数 名  : SendNotCompleteTaskToZRVDeviceForTimeOut
 功能描述  : 发送压缩任务超时的任务给ZRV设备
 输入参数  : char* task_id
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2017年9月2日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int SendNotCompleteTaskToZRVDeviceForTimeOut(char* task_id, int* run_thread_time)
{
    int iRet = 0;
    vector<string> ProcCompressTaskID; /* 任务总数 */
    compress_task_t* pCompressTaskData = NULL;

    if (NULL == task_id || task_id[0] == '\0')
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "SendNotCompleteTaskToZRVDeviceForTimeOut() task_id Error\r\n");
        return -1;
    }

    pCompressTaskData = compress_task_find(task_id);

    if (NULL == pCompressTaskData)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "SendNotCompleteTaskToZRVDeviceForTimeOut() CompressTaskData Error: task_id=%s\r\n", task_id);
        return -1;
    }

    if (1 != pCompressTaskData->iTaskStatus)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "SendNotCompleteTaskToZRVDeviceForTimeOut() TaskStatus Error: task_id=%s, TaskStatus=%d\r\n", task_id, pCompressTaskData->iTaskStatus);
        return -1;
    }

    ProcCompressTaskID.clear();
    ProcCompressTaskID.push_back(task_id);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_IMPORTANT, "压缩任务超时, 重新下发给ZRV设备, 记录编号=%s, ZRV设备IP=%s", task_id, pCompressTaskData->strZRVDeviceIP);

    iRet = SendAssignTaskToZRVDevice(ProcCompressTaskID, pCompressTaskData->strZRVDeviceIP, NULL, run_thread_time);
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "SendNotCompleteTaskToZRVDeviceForTimeOut() SendAssignTaskToZRVDevice:ZRVDeviceIP=%s, iRet=%d \r\n", pCompressTaskData->strZRVDeviceIP, iRet);

    return 0;
}

/*****************************************************************************
 函 数 名  : SendNotCompleteTaskToZRVDeviceForFristRegister
 功能描述  : ZRV设备第一次注册上线，下发之前没有完成的任务信息
 输入参数  : char* device_ip
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2017年9月1日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int SendNotCompleteTaskToZRVDeviceForFristRegister(char* device_ip, int* run_thread_time)
{
    int iRet = 0;
    vector<string> ProcCompressTaskID; /* 任务总数 */

    if (NULL == device_ip)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "SendNotCompleteTaskToZRVDeviceForFristRegister() device_ip Error\r\n");
        return -1;
    }

    ProcCompressTaskID.clear();
    iRet = GetAllAssignedCompressTaskByZRVDeviceIP(device_ip, ProcCompressTaskID);
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO,  "SendNotCompleteTaskToZRVDeviceForFristRegister() : GetAllAssignedCompressTaskByZRVDeviceIP:platform_ip=%s, iRet=%d \r\n", device_ip, iRet);

    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_IMPORTANT, "ZRV设备第一次注册上线, ZRV设备IP=%s, 获取到之前没有完成的任务数=%d", device_ip, (int)ProcCompressTaskID.size());

    iRet = SendAssignTaskToZRVDevice(ProcCompressTaskID, device_ip, NULL, run_thread_time);
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "SendNotCompleteTaskToZRVDeviceForFristRegister() SendAssignTaskToZRVDevice:ZRVDeviceIP=%s, iRet=%d \r\n", device_ip, iRet);

    return 0;
}

/*****************************************************************************
 函 数 名  : SendAssignTaskToZRVDevice
 功能描述  : 下发分配任务信息到ZRV设备
 输入参数  : vector<string>& CompressTaskID
             char* device_ip
             DBOper* pdboper
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2017年9月1日
    作    者   : 杨海锋
    修改内容   : 新生成函数

*****************************************************************************/
int SendAssignTaskToZRVDevice(vector<string>& CompressTaskID, char* device_ip, DBOper* pdboper, int* run_thread_time)
{
    int iRet = 0;
    int index = 0;
    int task_count_print = 0;   /* 记录数 */
    int task_count = 0;   /* 记录数 */
    int send_count = 0;   /* 发送的次数 */
    int query_count = 0;  /* 查询数据统计 */
    TCP_COMMON_Head stTCPCommonHead;
    char strBodyBuff[1024 * 1024] = {0}; /* 接收消息体*/

    DOMElement* ListAccNode = NULL;
    ZRVDevice_info_t* pZRVDeviceInfo = NULL;

    if (NULL == device_ip || device_ip[0] == '\0')
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "SendAssignTaskToZRVDevice() device_ip Error\r\n");
        return -1;
    }

    task_count = CompressTaskID.size();

    if (task_count == 0)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_WARNING, "发送压缩任务信息到ZRV设备失败, ZRV设备IP地址=%s, 原因=%s", device_ip, (char*)"任务数为0");
        return -1;
    }

    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "SendAssignTaskToZRVDevice() CompressTask count=%d \r\n", task_count);
    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_IMPORTANT, "发送压缩任务信息到ZRV设备, ZRV设备IP地址=%s, 分配的任务数=%d", device_ip, task_count);

    pZRVDeviceInfo = ZRVDevice_info_find(device_ip);

    if (NULL == pZRVDeviceInfo)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "发送压缩任务信息到ZRV设备失败, ZRV设备IP地址=%s, 原因=%s", device_ip, (char*)"查找对应的ZRV设备信息失败");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "SendAssignTaskToZRVDevice() ZRVDevice_info_find Error:device_ip=%s\r\n", device_ip);
        return -1;
    }

    if (pZRVDeviceInfo->reg_status <= 0)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "发送压缩任务信息到ZRV设备失败, ZRV设备IP地址=%s, 原因=%s", device_ip, (char*)"对应的ZRV设备没有注册");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "SendAssignTaskToZRVDevice() reg_status Error:reg_status=%s\r\n", pZRVDeviceInfo->reg_status);
        return -1;
    }

    if (pZRVDeviceInfo->tcp_sock < 0)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "发送压缩任务信息到ZRV设备失败, ZRV设备IP地址=%s, 原因=%s", device_ip, (char*)"对应的ZRV设备TCP Sock错误");
        DEBUG_TRACE(MODULE_DEVICE, LOG_ERROR, "SendAssignTaskToZRVDevice() tcp_sock Error:tcp_sock=%s\r\n", pZRVDeviceInfo->tcp_sock);
        return -1;
    }

    /* 7、循环查找排序容器，读取用户的设备信息，加入xml中 */
    CPacket* pOutPacket = NULL;

    for (index = 0; index < task_count; index++)
    {
        /* 如果记录数大于20，则要分次发送 */
        query_count++;

        /* 创建XML头部 */
        iRet = CreateAssignCompressTaskXMLHead(&pOutPacket, query_count, task_count, &ListAccNode);

        /* 加入Item 值 */
        iRet = AddCompressTaskInfoToXMLItem(pOutPacket, ListAccNode, (char*)CompressTaskID[index].c_str());
        task_count_print++;
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_IMPORTANT, "发送压缩任务信息到ZRV设备, ZRV设备IP地址=%s, 添加任务信息,任务计数=%d, 记录编号=%s", device_ip, task_count_print, (char*)CompressTaskID[index].c_str());

        if (NULL != pdboper)
        {
            /* 更新分配信息 */
            iRet = UpdateCompressTaskAssignInfo((char*)CompressTaskID[index].c_str(), 1, device_ip, pdboper);
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "SendAssignTaskToZRVDevice() UpdateCompressTaskAssignInfo:CompressTaskID=%s, device_ip=%s, iRet=%d\r\n", (char*)CompressTaskID[index].c_str(), device_ip, iRet);

            /* 更新状态信息 */
            iRet = UpdateCompressTaskResultInfo((char*)CompressTaskID[index].c_str(), 1, 0, 0, 0, 0, 0, NULL, pdboper);
            DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "SendAssignTaskToZRVDevice() UpdateCompressTaskResultInfo:CompressTaskID=%s, device_ip=%s, iRet=%d\r\n", (char*)CompressTaskID[index].c_str(), device_ip, iRet);
        }

        if ((query_count % MAX_ZRV_COMPRESS_TASL_COUT_SEND == 0) || (query_count == task_count))
        {
            if (NULL != pOutPacket)
            {
                send_count++;

                /* 生成TCP消息头 */
                memset(&stTCPCommonHead, 0, MAX_TCPHEAD_LEN);
                memcpy(stTCPCommonHead.strHeadMark, "ZBITCLOUDMSG", MAX_TCPHEAD_MARK_LEN);
                stTCPCommonHead.iMsgBodyLen = pOutPacket->GetXml(NULL).length();

                /* 发送出去 */
                memcpy(strBodyBuff, &stTCPCommonHead, MAX_TCPHEAD_LEN);
                memcpy(&strBodyBuff[MAX_TCPHEAD_LEN], (char*)pOutPacket->GetXml(NULL).c_str(), pOutPacket->GetXml(NULL).length());

                iRet = send(pZRVDeviceInfo->tcp_sock, strBodyBuff, pOutPacket->GetXml(NULL).length() + MAX_TCPHEAD_LEN, 0);
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "SendAssignTaskToZRVDevice() Body Send:device_ip=%s, tcp_sock=%d, MsgBodyLen=%d, iRet=%d\r\n", pZRVDeviceInfo->device_ip, pZRVDeviceInfo->tcp_sock, stTCPCommonHead.iMsgBodyLen, iRet);
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\r\n");
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "SendAssignTaskToZRVDevice() device_ip=%s, tcp_sock=%d, MsgBodyLen=%d, iRet=%d:\r\n%s\r\n", pZRVDeviceInfo->device_ip, pZRVDeviceInfo->tcp_sock, stTCPCommonHead.iMsgBodyLen, iRet, (char*)pOutPacket->GetXml(NULL).c_str());
                DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "--------------------------------------------\r\n");

                if (iRet <= 0)
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "发送压缩任务消息到ZRV设备失败:ZRV设备IP地址=%s, tcp_sock=%d, query_count=%d, MsgBodyLen=%d, iRet=%d", pZRVDeviceInfo->device_ip, pZRVDeviceInfo->tcp_sock, query_count, stTCPCommonHead.iMsgBodyLen, iRet);
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "发送的消息内容=%s\r\n", (char*)pOutPacket->GetXml(NULL).c_str());
                }
                else
                {
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_IMPORTANT, "发送压缩任务消息到ZRV设备成功:ZRV设备IP地址=%s, tcp_sock=%d, query_count=%d, MsgBodyLen=%d, iRet=%d", pZRVDeviceInfo->device_ip, pZRVDeviceInfo->tcp_sock, query_count, stTCPCommonHead.iMsgBodyLen, iRet);
                    SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_IMPORTANT, "发送的消息内容=%s\r\n", (char*)pOutPacket->GetXml(NULL).c_str());
                }

                delete pOutPacket;
                pOutPacket = NULL;

                if (iRet < 0 && (errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)) // 表示暂时发送失败, 需要重发
                {
                }
                else if (iRet <= 0 && errno != EINTR && errno != EWOULDBLOCK && errno != EAGAIN) //连接异常，需要关闭
                {
                    free_zrv_device_tcp_connect_by_socket(pZRVDeviceInfo->tcp_sock);
                    pZRVDeviceInfo->reg_status = 0;
                    pZRVDeviceInfo->tcp_sock = -1;
                    return -2;
                }

                if (NULL != run_thread_time)
                {
                    *run_thread_time = time(NULL);
                }
            }
        }
    }

    return 0;
}

int SendResponseToZRVRegister(char* pcGUID, int iResult, int iErrorCode, int tcp_sock)
{
    int iRet = 0;
    string strBody = "";
    TCP_COMMON_Head stTCPCommonHead;
    char strBodyBuff[1024 * 1024] = {0}; /* 接收消息体*/

    /* 生成消息体 */
    iRet = GeneratingResponseXMLForZRVRegister(pcGUID, iResult, iErrorCode, strBody);

    if (0 != iRet)
    {
        return iRet;
    }

    /* 生成消息头 */
    memset(&stTCPCommonHead, 0, MAX_TCPHEAD_LEN);
    memcpy(stTCPCommonHead.strHeadMark, "ZBITCLOUDMSG", MAX_TCPHEAD_MARK_LEN);
    stTCPCommonHead.iMsgBodyLen = strBody.length();

    memcpy(strBodyBuff, &stTCPCommonHead, MAX_TCPHEAD_LEN);
    memcpy(&strBodyBuff[MAX_TCPHEAD_LEN], (char*)strBody.c_str(), strBody.length());

    iRet = send(tcp_sock, strBodyBuff, strBody.length() + MAX_TCPHEAD_LEN, 0);
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\r\n");
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "SendResponseToZRVRegister: TCP Send:HeadMark=%s, MsgBodyLen=%d, iRet=%d:\r\n%s\r\n", stTCPCommonHead.strHeadMark, stTCPCommonHead.iMsgBodyLen, iRet, (char*)strBody.c_str());
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "--------------------------------------------\r\n");

#if 0

    if (iRet <= 0)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "发送注册响应消息到ZRV设备失败:tcp_sock=%d, MsgBodyLen=%d, iRet=%d", tcp_sock, strBody.length(), iRet);
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "发送的消息内容=%s\r\n", (char*)strBody.c_str());
    }
    else
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_IMPORTANT, "发送注册响应消息到ZRV设备成功:tcp_sock=%d, MsgBodyLen=%d, iRet=%d", tcp_sock, strBody.length(), iRet);
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_IMPORTANT, "发送的消息内容=%s\r\n", (char*)strBody.c_str());
    }

#endif

    if (iRet < 0 && (errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)) // 表示暂时发送失败, 需要重发
    {

    }
    else if (iRet <= 0 && errno != EINTR && errno != EWOULDBLOCK && errno != EAGAIN) //连接异常，需要关闭
    {
        return -2;
    }

    return 0;
}

int GeneratingResponseXMLForZRVRegister(char* pcGUID, int iResult, int iErrorCode, std::string & outBuff)
{
    time_t utc_time;
    struct tm local_time = { 0 };
    char strDateTime[48] = {0};

    CPacket outPacket;
    DOMElement* AccNode = NULL;
    DOMElement* ErrorItemAccNode = NULL;
    char strErrorCode[32] = {0};
    char strTime[32] = {0};

    utc_time = time(NULL);
    localtime_r(&utc_time, &local_time);

    strftime(strDateTime, sizeof(strDateTime), "%Y-%m-%d %H:%M:%S", &local_time);

    /* 回复响应,组建消息 */
    outPacket.SetRootTag("ZBITCloudResponse");

    AccNode = outPacket.CreateElement((char*)"CmdType");
    outPacket.SetElementValue(AccNode, (char*)"REGISTER");

    AccNode = outPacket.CreateElement((char*)"SubType");
    outPacket.SetElementValue(AccNode, (char*)"ZRV-REGISTER");

    AccNode = outPacket.CreateElement((char*)"TriggerTime");
    outPacket.SetElementValue(AccNode, strDateTime);

    AccNode = outPacket.CreateElement((char*)"GUID");
    outPacket.SetElementValue(AccNode, pcGUID);

    if (0 == iResult)
    {
        AccNode = outPacket.CreateElement((char*)"StatusCode");
        outPacket.SetElementValue(AccNode, (char*)"200");

        AccNode = outPacket.CreateElement((char*)"Result");
        outPacket.SetElementValue(AccNode, (char*)"OK");

        AccNode = outPacket.CreateElement((char*)"Time");
        snprintf(strTime, 32, "%d", utc_time);
        outPacket.SetElementValue(AccNode, strTime);
    }
    else
    {
        AccNode = outPacket.CreateElement((char*)"StatusCode");
        outPacket.SetElementValue(AccNode, (char*)"403");

        AccNode = outPacket.CreateElement((char*)"Result");
        outPacket.SetElementValue(AccNode, (char*)"Error");

        AccNode = outPacket.CreateElement((char*)"Time");
        snprintf(strTime, 32, "%d", utc_time);
        outPacket.SetElementValue(AccNode, strTime);

        AccNode = outPacket.CreateElement((char*)"ErrorCode");
        snprintf(strErrorCode, 32, "%d", iErrorCode);
        outPacket.SetElementValue(AccNode, strErrorCode);
    }

    outBuff = outPacket.GetXml(NULL);

    return 0;
}

int SendResponseToZRVTaskResult(char* pcGUID, int iResult, int iErrorCode, int tcp_sock)
{
    int iRet = 0;
    string strBody = "";
    TCP_COMMON_Head stTCPCommonHead;
    char strBodyBuff[1024 * 1024] = {0}; /* 接收消息体*/

    /* 生成消息体 */
    iRet = GeneratingResponseXMLForZRVTaskResult(pcGUID, iResult, iErrorCode, strBody);

    if (0 != iRet)
    {
        return iRet;
    }

    /* 生成消息头 */
    memset(&stTCPCommonHead, 0, MAX_TCPHEAD_LEN);
    memcpy(stTCPCommonHead.strHeadMark, "ZBITCLOUDMSG", MAX_TCPHEAD_MARK_LEN);
    stTCPCommonHead.iMsgBodyLen = strBody.length();

    memcpy(strBodyBuff, &stTCPCommonHead, MAX_TCPHEAD_LEN);
    memcpy(&strBodyBuff[MAX_TCPHEAD_LEN], (char*)strBody.c_str(), strBody.length());

    iRet = send(tcp_sock, strBodyBuff, strBody.length() + MAX_TCPHEAD_LEN, 0);
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\r\n");
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "SendResponseToZRVTaskResult: TCP Send:HeadMark=%s, MsgBodyLen=%d, iRet=%d:\r\n%s\r\n", stTCPCommonHead.strHeadMark, stTCPCommonHead.iMsgBodyLen, iRet, (char*)strBody.c_str());
    DEBUG_TRACE(MODULE_DEVICE, LOG_INFO, "--------------------------------------------\r\n");

    if (iRet < 0 && (errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)) // 表示暂时发送失败, 需要重发
    {

    }
    else if (iRet <= 0 && errno != EINTR && errno != EWOULDBLOCK && errno != EAGAIN) //连接异常，需要关闭
    {
        return -2;
    }

#if 0

    if (iRet <= 0)
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "发送任务响应消息到ZRV设备失败:tcp_sock=%d, MsgBodyLen=%d, iRet=%d", tcp_sock, strBody.length(), iRet);
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_ERROR, "发送的消息内容=%s\r\n", (char*)strBody.c_str());
    }
    else
    {
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_IMPORTANT, "发送任务响应消息到ZRV设备成功:tcp_sock=%d, MsgBodyLen=%d, iRet=%d", tcp_sock, strBody.length(), iRet);
        SystemLog(EV9000_CMS_SYSTEM_RUN_INFO, EV9000_LOG_LEVEL_IMPORTANT, "发送的消息内容=%s\r\n", (char*)strBody.c_str());
    }

#endif

    return 0;
}

int GeneratingResponseXMLForZRVTaskResult(char* pcGUID, int iResult, int iErrorCode, std::string & outBuff)
{
    time_t utc_time;
    struct tm local_time = { 0 };
    char strDateTime[48] = {0};

    CPacket outPacket;
    DOMElement* AccNode = NULL;
    DOMElement* ErrorItemAccNode = NULL;
    char strErrorCode[32] = {0};
    char strTime[32] = {0};

    utc_time = time(NULL);
    localtime_r(&utc_time, &local_time);

    strftime(strDateTime, sizeof(strDateTime), "%Y-%m-%d %H:%M:%S", &local_time);

    /* 回复响应,组建消息 */
    outPacket.SetRootTag("ZBITCloudResponse");

    AccNode = outPacket.CreateElement((char*)"CmdType");
    outPacket.SetElementValue(AccNode, (char*)"NOTIFY");

    AccNode = outPacket.CreateElement((char*)"SubType");
    outPacket.SetElementValue(AccNode, (char*)"ZRV-COMPRESS-TASK-RESULT");

    AccNode = outPacket.CreateElement((char*)"TriggerTime");
    outPacket.SetElementValue(AccNode, strDateTime);

    AccNode = outPacket.CreateElement((char*)"GUID");
    outPacket.SetElementValue(AccNode, pcGUID);

    if (0 == iResult)
    {
        AccNode = outPacket.CreateElement((char*)"StatusCode");
        outPacket.SetElementValue(AccNode, (char*)"200");

        AccNode = outPacket.CreateElement((char*)"Result");
        outPacket.SetElementValue(AccNode, (char*)"OK");

        AccNode = outPacket.CreateElement((char*)"Time");
        snprintf(strTime, 32, "%d", utc_time);
        outPacket.SetElementValue(AccNode, strTime);
    }
    else
    {
        AccNode = outPacket.CreateElement((char*)"StatusCode");
        outPacket.SetElementValue(AccNode, (char*)"403");

        AccNode = outPacket.CreateElement((char*)"Result");
        outPacket.SetElementValue(AccNode, (char*)"Error");

        AccNode = outPacket.CreateElement((char*)"Time");
        snprintf(strTime, 32, "%d", utc_time);
        outPacket.SetElementValue(AccNode, strTime);

        AccNode = outPacket.CreateElement((char*)"ErrorCode");
        snprintf(strErrorCode, 32, "%d", iErrorCode);
        outPacket.SetElementValue(AccNode, strErrorCode);
    }

    outBuff = outPacket.GetXml(NULL);

    return 0;
}

int CreateAssignCompressTaskXMLHead(CPacket** pOutPacket, int query_count, int record_count, DOMElement** ListAccNode)
{
    DOMElement* AccNode = NULL;
    char strRecordCount[32] = {0};

    /* 添加发送的xml头部 */
    if (query_count == 1)
    {
        *pOutPacket = new CPacket();

        if (NULL == *pOutPacket)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "CreateAssignCompressTaskXMLHead() exit---: Create XML Packet Error \r\n");
            return -1;
        }

        if (record_count <= MAX_ZRV_COMPRESS_TASL_COUT_SEND)
        {
            snprintf(strRecordCount, 32, "%d", record_count);
        }
        else
        {
            snprintf(strRecordCount, 32, "%d", MAX_ZRV_COMPRESS_TASL_COUT_SEND);
        }

        (*pOutPacket)->SetRootTag("ZBITCloudRequest");

        AccNode = (*pOutPacket)->CreateElement((char*)"CmdType");
        (*pOutPacket)->SetElementValue(AccNode, (char*)"NOTIFY");

        AccNode = (*pOutPacket)->CreateElement((char*)"SubType");
        (*pOutPacket)->SetElementValue(AccNode, (char*)"ZRV-COMPRESS-TASK");

        (*ListAccNode) = (*pOutPacket)->CreateElement((char*)"TaskList");
        (*pOutPacket)->SetElementAttr((*ListAccNode), (char*)"Num", strRecordCount);
    }
    else if ((query_count % MAX_ZRV_COMPRESS_TASL_COUT_SEND == 1) && (record_count - query_count >= MAX_ZRV_COMPRESS_TASL_COUT_SEND))
    {
        *pOutPacket = new CPacket();

        if (NULL == *pOutPacket)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "CreateAssignCompressTaskXMLHead() exit---: Create XML Packet Error \r\n");
            return -1;
        }

        snprintf(strRecordCount, 32, "%d", MAX_ZRV_COMPRESS_TASL_COUT_SEND);

        (*pOutPacket)->SetRootTag("ZBITCloudRequest");

        AccNode = (*pOutPacket)->CreateElement((char*)"CmdType");
        (*pOutPacket)->SetElementValue(AccNode, (char*)"NOTIFY");

        AccNode = (*pOutPacket)->CreateElement((char*)"SubType");
        (*pOutPacket)->SetElementValue(AccNode, (char*)"ZRV-COMPRESS-TASK");

        (*ListAccNode) = (*pOutPacket)->CreateElement((char*)"TaskList");
        (*pOutPacket)->SetElementAttr((*ListAccNode), (char*)"Num", strRecordCount);
    }
    else if ((query_count % MAX_ZRV_COMPRESS_TASL_COUT_SEND == 1) && (record_count - query_count < MAX_ZRV_COMPRESS_TASL_COUT_SEND))
    {
        *pOutPacket = new CPacket();

        if (NULL == *pOutPacket)
        {
            DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "CreateAssignCompressTaskXMLHead() exit---: Create XML Packet Error \r\n");
            return -1;
        }

        snprintf(strRecordCount, 32, "%d", record_count - query_count + 1);

        (*pOutPacket)->SetRootTag("ZBITCloudRequest");

        AccNode = (*pOutPacket)->CreateElement((char*)"CmdType");
        (*pOutPacket)->SetElementValue(AccNode, (char*)"NOTIFY");

        AccNode = (*pOutPacket)->CreateElement((char*)"SubType");
        (*pOutPacket)->SetElementValue(AccNode, (char*)"ZRV-COMPRESS-TASK");

        (*ListAccNode) = (*pOutPacket)->CreateElement((char*)"TaskList");
        (*pOutPacket)->SetElementAttr((*ListAccNode), (char*)"Num", strRecordCount);
    }

    return 0;
}

/*****************************************************************************
 函 数 名  : AddLogicDeviceInfoToXMLItem
 功能描述  : 添加逻辑设备信息到XML的Item
 输入参数  : CPacket* pOutPacket
             DOMElement* ListAccNode
             char* device_id
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

 修改历史      :
  1.日    期   : 2013年7月27日 星期六
    作    者   : yanghaifeng
    修改内容   : 新生成函数

*****************************************************************************/
int AddCompressTaskInfoToXMLItem(CPacket* pOutPacket, DOMElement* ListAccNode, char* task_id)
{
    compress_task_t* pCompressTaskData = NULL;
    DOMElement* ItemAccNode = NULL;
    DOMElement* AccNode = NULL;
    DOMElement* ItemInfoNode = NULL;

    char strID[64] = {0};
    char strFrameCount[64] = {0};
    char strStreamCount[64] = {0};
    char strLongitude[64] = {0};
    char strLatitude[64] = {0};
    char strAlarmDeviceSubType[64] = {0};
    char strPTZType[16] = {0};
    char strwjdx[32] = {0};
    int iRet = 0;
    time_t now = time(NULL);

    if (NULL == pOutPacket || NULL == ListAccNode)
    {
        DEBUG_TRACE(MODULE_DEVICE, LOG_DEBUG, "AddLogicDeviceInfoToXMLItem() exit---: Param Error \r\n");
        return -1;
    }

    /* 填写XML数据*/
    pOutPacket->SetCurrentElement(ListAccNode);
    ItemAccNode = pOutPacket->CreateElement((char*)"Item");
    pOutPacket->SetCurrentElement(ItemAccNode);

    /* 根据Index 获取逻辑设备信息，可能是只配置了物理设备，还没有上线，数据库和内存中都没有的*/
    pCompressTaskData = compress_task_find(task_id);

    if (NULL != pCompressTaskData)
    {
        /* 设备索引 */
        AccNode = pOutPacket->CreateElement((char*)"RecordNum");
        pOutPacket->SetElementValue(AccNode, task_id);

        AccNode = pOutPacket->CreateElement((char*)"SourceURL");
        pOutPacket->SetElementValue(AccNode, pCompressTaskData->stYSPB.cclj);

        AccNode = pOutPacket->CreateElement((char*)"SourceFileName");
        pOutPacket->SetElementValue(AccNode, pCompressTaskData->stYSPB.wjmc);

        AccNode = pOutPacket->CreateElement((char*)"SourceFileSuffixName");
        pOutPacket->SetElementValue(AccNode, pCompressTaskData->stYSPB.kzm);

        AccNode = pOutPacket->CreateElement((char*)"SourceFileSize");
        snprintf(strwjdx, 32, "%d", pCompressTaskData->stYSPB.wjdx);
        pOutPacket->SetElementValue(AccNode, strwjdx);

        AccNode = pOutPacket->CreateElement((char*)"DestURL");
        pOutPacket->SetElementValue(AccNode, pCompressTaskData->stYSPB.yshlj);
    }

    return 0;
}
